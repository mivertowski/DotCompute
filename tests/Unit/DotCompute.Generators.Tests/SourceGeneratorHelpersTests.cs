// Copyright(c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using DotCompute.Generators.Utils;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Xunit;
using FluentAssertions;

namespace DotCompute.Tests.Unit;

public class SourceGeneratorHelpersTests
{
    [Fact]
    public void GenerateHeader_WithUsings_ShouldCreateValidHeader()
    {
        // Arrange
        var usings = new[] { "System", "System.Collections.Generic", "Microsoft.CodeAnalysis" };

        // Act
        var result = SourceGeneratorHelpers.GenerateHeader(usings);

        // Assert
        Assert.StartsWith("// <auto-generated/>", result);
        Assert.Contains("#nullable enable", result);
        Assert.Contains("#pragma warning disable CS8019", result);
        Assert.Contains("using System;", result);
        Assert.Contains("using System.Collections.Generic;", result);
        Assert.Contains("using Microsoft.CodeAnalysis;", result);
    }

    [Fact]
    public void GenerateHeader_WithNoUsings_ShouldCreateValidHeaderWithoutUsings()
    {
        // Act
        var result = SourceGeneratorHelpers.GenerateHeader();

        // Assert
        Assert.StartsWith("// <auto-generated/>", result);
        Assert.Contains("#nullable enable", result);
        Assert.Contains("#pragma warning disable CS8019", result);
        result.Should().NotContain("using ");
    }

    [Fact]
    public void BeginNamespace_ShouldCreateValidNamespaceDeclaration()
    {
        // Arrange
        var namespaceName = "DotCompute.Generated.Tests";

        // Act
        var result = SourceGeneratorHelpers.BeginNamespace(namespaceName);

        // Assert
        Assert.Equal($"namespace {namespaceName}\n{{", result);
    }

    [Fact]
    public void EndNamespace_ShouldReturnClosingBrace()
    {
        // Act
        var result = SourceGeneratorHelpers.EndNamespace();

        // Assert
        Assert.Equal("}", result);
    }

    [Theory]
    [InlineData("code", 1, "    code")]
    [InlineData("line1\nline2", 2, "        line1\n        line2")]
    [InlineData("", 3, "")]
    [InlineData("  already indented", 1, "      already indented")]
    public void Indent_ShouldIndentCodeCorrectly(string input, int level, string expected)
    {
        // Act
        var result = SourceGeneratorHelpers.Indent(input, level);

        // Assert
        Assert.Equal(expected, result);
    }

    [Fact]
    public void Indent_WithWhitespaceOnlyLines_ShouldPreserveWhitespace()
    {
        // Arrange
        var code = "line1\n   \nline2";
        
        // Act
        var result = SourceGeneratorHelpers.Indent(code, 1);

        // Assert
        Assert.Equal("    line1\n   \n    line2", result);
    }

    [Fact]
    public void GenerateParameterValidation_WithBufferParameters_ShouldGenerateNullChecks()
    {
        // Arrange
        var parameters = new[]
        {
           ("input", "float[]", true),
           ("output", "int[]", true),
           ("length", "int", false)
        };

        // Act
        var result = SourceGeneratorHelpers.GenerateParameterValidation(parameters);

        // Assert
        result.Contain("ArgumentNullException.ThrowIfNull(input, nameof(input));");
        result.Contain("ArgumentNullException.ThrowIfNull(output, nameof(output));");
        result.Should().NotContain("length");
    }

    [Fact]
    public void GenerateParameterValidation_WithSpanParameters_ShouldGenerateEmptyChecks()
    {
        // Arrange
        var parameters = new[]
        {
           ("spanInput", "Span<float>", true),
           ("memoryInput", "Memory<int>", true),
           ("value", "double", false)
        };

        // Act
        var result = SourceGeneratorHelpers.GenerateParameterValidation(parameters);

        // Assert
        result.Contain("ifspanInput.IsEmpty) throw new ArgumentException(\"Buffer cannot be empty\", nameof(spanInput));");
        result.Contain("ifmemoryInput.IsEmpty) throw new ArgumentException(\"Buffer cannot be empty\", nameof(memoryInput));");
        result.Should().NotContain("value");
    }

    [Fact]
    public void GenerateParameterValidation_WithNoBuffers_ShouldReturnEmpty()
    {
        // Arrange
        var parameters = new[]
        {
           ("value1", "int", false),
           ("value2", "float", false)
        };

        // Act
        var result = SourceGeneratorHelpers.GenerateParameterValidation(parameters);

        // Assert
        Assert.Empty(result);
    }

    [Theory]
    [InlineData("i", "length", "ProcessElement();", false, 4)]
    [InlineData("j", "count", "output[j] = input[j];", true, 8)]
    public void GenerateOptimizedLoop_ShouldCreateCorrectLoop(string indexVar, string limitVar, string body, bool unroll, int unrollFactor)
    {
        // Act
        var result = SourceGeneratorHelpers.GenerateOptimizedLoop(indexVar, limitVar, body, unroll, unrollFactor);

        // Assert
        Assert.Contains($"forint {indexVar}", result);
        Assert.Contains(limitVar, result);
        Assert.Contains(body, result);

        if(unroll)
        {
            Assert.Contains($"var remainder = {limitVar} % {unrollFactor};", result);
            Assert.Contains("// Handle remainder", result);
        }
        else
        {
            result.Should().NotContain("remainder");
            result.Should().NotContain("Handle remainder");
        }
    }

    [Fact]
    public void ExtractMethodBody_WithBlockBody_ShouldExtractStatements()
    {
        // Arrange
        var source = @"
public static void TestMethod()
{
    var x = 5;
    Console.WriteLine(x);
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.ExtractMethodBody(method);

        // Assert
        Assert.NotNull(result);
        Assert.Contains("var x = 5;", result);
        Assert.Contains("Console.WriteLine(x, result);");
    }

    [Fact]
    public void ExtractMethodBody_WithExpressionBody_ShouldExtractExpression()
    {
        // Arrange
        var source = @"
public static int TestMethod() => 42;";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.ExtractMethodBody(method);

        // Assert
        Assert.NotNull(result);
        Assert.Equal("42;", result);
    }

    [Fact]
    public void ExtractMethodBody_WithNoBody_ShouldReturnNull()
    {
        // Arrange
        var source = @"
public abstract void AbstractMethod();";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.ExtractMethodBody(method);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void AnalyzeVectorization_WithVectorizableLoop_ShouldDetectVectorization()
    {
        // Arrange
        var source = @"
public static void VectorizableMethod()
{
    for(int i = 0; i < length; i++)
    {
        output[i] = input[i] + 2.0f;
    }
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(1);
        result.VectorizableLoops.Should().Be(1);
        result.HasArrayAccess.Should().BeTrue();
(result.ArithmeticOperationCount > 0.Should().BeTrue();
        result.IsVectorizable.Should().BeTrue();
        result.IsArithmetic.Should().BeTrue();
        result.IsMemoryOperation.Should().BeTrue();
    }

    [Fact]
    public void AnalyzeVectorization_WithComplexLoop_ShouldNotVectorize()
    {
        // Arrange
        var source = @"
public static void ComplexMethod()
{
    for(int i = 0; i < length; i += 2)
    {
        if(condition)
        {
            DoSomething();
        }
    }
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(1);
        result.VectorizableLoops.Should().Be(0);
        result.IsVectorizable.Should().BeFalse();
    }

    [Fact]
    public void AnalyzeVectorization_WithMultipleLoops_ShouldCountAll()
    {
        // Arrange
        var source = @"
public static void MultipleLoopsMethod()
{
    for(int i = 0; i < length; i++)
    {
        output[i] = input[i] * 2.0f;
    }
    
    for(int j = 0; j < width; j++)
    {
        result[j] = data[j] + 1.0f;
    }
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(2);
        result.VectorizableLoops.Should().Be(2);
        result.HasArrayAccess.Should().BeTrue();
        result.IsVectorizable.Should().BeTrue();
    }

    [Fact]
    public void AnalyzeVectorization_WithNoBody_ShouldReturnDefaultValues()
    {
        // Arrange
        var source = @"
public abstract void AbstractMethod();";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(0);
        result.VectorizableLoops.Should().Be(0);
        result.HasArrayAccess.Should().BeFalse();
        result.ArithmeticOperationCount.Should().Be(0);
        result.IsVectorizable.Should().BeFalse();
        result.IsArithmetic.Should().BeFalse();
        result.IsMemoryOperation.Should().BeFalse();
    }

    [Theory]
    [InlineData("float", 4, "Vector128<float>")]
    [InlineData("double", 4, "Vector128<double>")]
    [InlineData("int", 8, "Vector256<int>")]
    [InlineData("uint", 8, "Vector256<uint>")]
    [InlineData("long", 16, "Vector512<long>")]
    [InlineData("byte", 32, "Vector1024<byte>")]
    public void GetSimdType_ShouldReturnCorrectType(string elementType, int vectorSize, string expected)
    {
        // Act
        var result = SourceGeneratorHelpers.GetSimdType(elementType, vectorSize);

        // Assert
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("unsupported")]
    public void GetSimdType_WithUnsupportedType_ShouldThrow(string elementType)
    {
        // Act & Assert
        var action =() => SourceGeneratorHelpers.GetSimdType(elementType, 8);
        Assert.Throws<NotSupportedException>(() => action());
    }

    [Theory]
    [InlineData("+", "Vector", "Vector.Add")]
    [InlineData("-", "Vector", "Vector.Subtract")]
    [InlineData("*", "Vector", "Vector.Multiply")]
    [InlineData("/", "Vector", "Vector.Divide")]
    [InlineData("min", "Vector", "Vector.Min")]
    [InlineData("max", "Vector", "Vector.Max")]
    [InlineData("sqrt", "Vector", "Vector.SquareRoot")]
    [InlineData("abs", "Vector", "Vector.Abs")]
    public void GetIntrinsicOperation_ShouldReturnCorrectOperation(string operation, string vectorType, string expected)
    {
        // Act
        var result = SourceGeneratorHelpers.GetIntrinsicOperation(operation, vectorType);

        // Assert
        Assert.Equal(expected, result);
    }

    [Fact]
    public void GetIntrinsicOperation_WithUnsupportedOperation_ShouldThrow()
    {
        // Act & Assert
        var action =() => SourceGeneratorHelpers.GetIntrinsicOperation("unsupported", "Vector");
        Assert.Throws<NotSupportedException>(() => action());
    }

    [Fact]
    public void VectorizationInfo_Properties_ShouldWorkCorrectly()
    {
        // Arrange
        var info = new VectorizationInfo
        {
            LoopCount = 2,
            VectorizableLoops = 1,
            HasArrayAccess = true,
            ArithmeticOperationCount = 5
        };

        // Assert
        info.IsVectorizable.Should().BeTrue();
        info.IsArithmetic.Should().BeTrue();
        info.IsMemoryOperation.Should().BeTrue();
    }

    [Fact]
    public void VectorizationInfo_WithNoVectorizableLoops_ShouldNotBeVectorizable()
    {
        // Arrange
        var info = new VectorizationInfo
        {
            LoopCount = 1,
            VectorizableLoops = 0,
            HasArrayAccess = true,
            ArithmeticOperationCount = 0
        };

        // Assert
        info.IsVectorizable.Should().BeFalse("No vectorizable loops");
        info.IsArithmetic.Should().BeFalse("No arithmetic operations");
        info.IsMemoryOperation.Should().BeTrue();
    }

    private static MethodDeclarationSyntax ParseMethod(string source)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);
        return syntaxTree.GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>().First();
    }
}
