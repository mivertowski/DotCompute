// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using DotCompute.Generators.Utils;
using FluentAssertions;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Xunit;

namespace DotCompute.Tests.Unit;

public class SourceGeneratorHelpersTests
{
    [Fact]
    public void GenerateHeader_WithUsings_ShouldCreateValidHeader()
    {
        // Arrange
        var usings = new[] { "System", "System.Collections.Generic", "Microsoft.CodeAnalysis" };

        // Act
        var result = SourceGeneratorHelpers.GenerateHeader(usings);

        // Assert
        result.Should().StartWith("// <auto-generated/>");
        result.Should().Contain("#nullable enable");
        result.Should().Contain("#pragma warning disable CS8019");
        result.Should().Contain("using System;");
        result.Should().Contain("using System.Collections.Generic;");
        result.Should().Contain("using Microsoft.CodeAnalysis;");
    }

    [Fact]
    public void GenerateHeader_WithNoUsings_ShouldCreateValidHeaderWithoutUsings()
    {
        // Act
        var result = SourceGeneratorHelpers.GenerateHeader();

        // Assert
        result.Should().StartWith("// <auto-generated/>");
        result.Should().Contain("#nullable enable");
        result.Should().Contain("#pragma warning disable CS8019");
        result.Should().NotContain("using ");
    }

    [Fact]
    public void BeginNamespace_ShouldCreateValidNamespaceDeclaration()
    {
        // Arrange
        var namespaceName = "DotCompute.Generated.Tests";

        // Act
        var result = SourceGeneratorHelpers.BeginNamespace(namespaceName);

        // Assert
        result.Should().Be($"namespace {namespaceName}\n{{");
    }

    [Fact]
    public void EndNamespace_ShouldReturnClosingBrace()
    {
        // Act
        var result = SourceGeneratorHelpers.EndNamespace();

        // Assert
        result.Should().Be("}");
    }

    [Theory]
    [InlineData("code", 1, "    code")]
    [InlineData("line1\nline2", 2, "        line1\n        line2")]
    [InlineData("", 3, "")]
    [InlineData("  already indented", 1, "      already indented")]
    public void Indent_ShouldIndentCodeCorrectly(string input, int level, string expected)
    {
        // Act
        var result = SourceGeneratorHelpers.Indent(input, level);

        // Assert
        result.Should().Be(expected);
    }

    [Fact]
    public void Indent_WithWhitespaceOnlyLines_ShouldPreserveWhitespace()
    {
        // Arrange
        var code = "line1\n   \nline2";
        
        // Act
        var result = SourceGeneratorHelpers.Indent(code, 1);

        // Assert
        result.Should().Be("    line1\n   \n    line2");
    }

    [Fact]
    public void GenerateParameterValidation_WithBufferParameters_ShouldGenerateNullChecks()
    {
        // Arrange
        var parameters = new[]
        {
            ("input", "float[]", true),
            ("output", "int[]", true),
            ("length", "int", false)
        };

        // Act
        var result = SourceGeneratorHelpers.GenerateParameterValidation(parameters);

        // Assert
        result.Should().Contain("ArgumentNullException.ThrowIfNull(input, nameof(input));");
        result.Should().Contain("ArgumentNullException.ThrowIfNull(output, nameof(output));");
        result.Should().NotContain("length");
    }

    [Fact]
    public void GenerateParameterValidation_WithSpanParameters_ShouldGenerateEmptyChecks()
    {
        // Arrange
        var parameters = new[]
        {
            ("spanInput", "Span<float>", true),
            ("memoryInput", "Memory<int>", true),
            ("value", "double", false)
        };

        // Act
        var result = SourceGeneratorHelpers.GenerateParameterValidation(parameters);

        // Assert
        result.Should().Contain("if (spanInput.IsEmpty) throw new ArgumentException(\"Buffer cannot be empty\", nameof(spanInput));");
        result.Should().Contain("if (memoryInput.IsEmpty) throw new ArgumentException(\"Buffer cannot be empty\", nameof(memoryInput));");
        result.Should().NotContain("value");
    }

    [Fact]
    public void GenerateParameterValidation_WithNoBuffers_ShouldReturnEmpty()
    {
        // Arrange
        var parameters = new[]
        {
            ("value1", "int", false),
            ("value2", "float", false)
        };

        // Act
        var result = SourceGeneratorHelpers.GenerateParameterValidation(parameters);

        // Assert
        result.Should().BeEmpty();
    }

    [Theory]
    [InlineData("i", "length", "ProcessElement();", false, 4)]
    [InlineData("j", "count", "output[j] = input[j];", true, 8)]
    public void GenerateOptimizedLoop_ShouldCreateCorrectLoop(string indexVar, string limitVar, string body, bool unroll, int unrollFactor)
    {
        // Act
        var result = SourceGeneratorHelpers.GenerateOptimizedLoop(indexVar, limitVar, body, unroll, unrollFactor);

        // Assert
        result.Should().Contain($"for (int {indexVar}");
        result.Should().Contain(limitVar);
        result.Should().Contain(body);

        if (unroll)
        {
            result.Should().Contain($"var remainder = {limitVar} % {unrollFactor};");
            result.Should().Contain("// Handle remainder");
        }
        else
        {
            result.Should().NotContain("remainder");
            result.Should().NotContain("Handle remainder");
        }
    }

    [Fact]
    public void ExtractMethodBody_WithBlockBody_ShouldExtractStatements()
    {
        // Arrange
        var source = @"
public static void TestMethod()
{
    var x = 5;
    Console.WriteLine(x);
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.ExtractMethodBody(method);

        // Assert
        result.Should().NotBeNull();
        result.Should().Contain("var x = 5;");
        result.Should().Contain("Console.WriteLine(x);");
    }

    [Fact]
    public void ExtractMethodBody_WithExpressionBody_ShouldExtractExpression()
    {
        // Arrange
        var source = @"
public static int TestMethod() => 42;";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.ExtractMethodBody(method);

        // Assert
        result.Should().NotBeNull();
        result.Should().Be("42;");
    }

    [Fact]
    public void ExtractMethodBody_WithNoBody_ShouldReturnNull()
    {
        // Arrange
        var source = @"
public abstract void AbstractMethod();";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.ExtractMethodBody(method);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public void AnalyzeVectorization_WithVectorizableLoop_ShouldDetectVectorization()
    {
        // Arrange
        var source = @"
public static void VectorizableMethod()
{
    for (int i = 0; i < length; i++)
    {
        output[i] = input[i] + 2.0f;
    }
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(1);
        result.VectorizableLoops.Should().Be(1);
        result.HasArrayAccess.Should().BeTrue();
        result.ArithmeticOperationCount.Should().BeGreaterThan(0);
        result.IsVectorizable.Should().BeTrue();
        result.IsArithmetic.Should().BeTrue();
        result.IsMemoryOperation.Should().BeTrue();
    }

    [Fact]
    public void AnalyzeVectorization_WithComplexLoop_ShouldNotVectorize()
    {
        // Arrange
        var source = @"
public static void ComplexMethod()
{
    for (int i = 0; i < length; i += 2)
    {
        if (condition)
        {
            DoSomething();
        }
    }
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(1);
        result.VectorizableLoops.Should().Be(0);
        result.IsVectorizable.Should().BeFalse();
    }

    [Fact]
    public void AnalyzeVectorization_WithMultipleLoops_ShouldCountAll()
    {
        // Arrange
        var source = @"
public static void MultipleLoopsMethod()
{
    for (int i = 0; i < length; i++)
    {
        output[i] = input[i] * 2.0f;
    }
    
    for (int j = 0; j < width; j++)
    {
        result[j] = data[j] + 1.0f;
    }
}";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(2);
        result.VectorizableLoops.Should().Be(2);
        result.HasArrayAccess.Should().BeTrue();
        result.IsVectorizable.Should().BeTrue();
    }

    [Fact]
    public void AnalyzeVectorization_WithNoBody_ShouldReturnDefaultValues()
    {
        // Arrange
        var source = @"
public abstract void AbstractMethod();";
        var method = ParseMethod(source);

        // Act
        var result = SourceGeneratorHelpers.AnalyzeVectorization(method);

        // Assert
        result.LoopCount.Should().Be(0);
        result.VectorizableLoops.Should().Be(0);
        result.HasArrayAccess.Should().BeFalse();
        result.ArithmeticOperationCount.Should().Be(0);
        result.IsVectorizable.Should().BeFalse();
        result.IsArithmetic.Should().BeFalse();
        result.IsMemoryOperation.Should().BeFalse();
    }

    [Theory]
    [InlineData("float", 4, "Vector128<float>")]
    [InlineData("double", 4, "Vector128<double>")]
    [InlineData("int", 8, "Vector256<int>")]
    [InlineData("uint", 8, "Vector256<uint>")]
    [InlineData("long", 16, "Vector512<long>")]
    [InlineData("byte", 32, "Vector1024<byte>")]
    public void GetSimdType_ShouldReturnCorrectType(string elementType, int vectorSize, string expected)
    {
        // Act
        var result = SourceGeneratorHelpers.GetSimdType(elementType, vectorSize);

        // Assert
        result.Should().Be(expected);
    }

    [Theory]
    [InlineData("unsupported")]
    public void GetSimdType_WithUnsupportedType_ShouldThrow(string elementType)
    {
        // Act & Assert
        var action = () => SourceGeneratorHelpers.GetSimdType(elementType, 8);
        action.Should().Throw<NotSupportedException>();
    }

    [Theory]
    [InlineData("+", "Vector", "Vector.Add")]
    [InlineData("-", "Vector", "Vector.Subtract")]
    [InlineData("*", "Vector", "Vector.Multiply")]
    [InlineData("/", "Vector", "Vector.Divide")]
    [InlineData("min", "Vector", "Vector.Min")]
    [InlineData("max", "Vector", "Vector.Max")]
    [InlineData("sqrt", "Vector", "Vector.SquareRoot")]
    [InlineData("abs", "Vector", "Vector.Abs")]
    public void GetIntrinsicOperation_ShouldReturnCorrectOperation(string operation, string vectorType, string expected)
    {
        // Act
        var result = SourceGeneratorHelpers.GetIntrinsicOperation(operation, vectorType);

        // Assert
        result.Should().Be(expected);
    }

    [Fact]
    public void GetIntrinsicOperation_WithUnsupportedOperation_ShouldThrow()
    {
        // Act & Assert
        var action = () => SourceGeneratorHelpers.GetIntrinsicOperation("unsupported", "Vector");
        action.Should().Throw<NotSupportedException>();
    }

    [Fact]
    public void VectorizationInfo_Properties_ShouldWorkCorrectly()
    {
        // Arrange
        var info = new VectorizationInfo
        {
            LoopCount = 2,
            VectorizableLoops = 1,
            HasArrayAccess = true,
            ArithmeticOperationCount = 5
        };

        // Assert
        info.IsVectorizable.Should().BeTrue("Has vectorizable loops and array access");
        info.IsArithmetic.Should().BeTrue("Has arithmetic operations");
        info.IsMemoryOperation.Should().BeTrue("Has array access");
    }

    [Fact]
    public void VectorizationInfo_WithNoVectorizableLoops_ShouldNotBeVectorizable()
    {
        // Arrange
        var info = new VectorizationInfo
        {
            LoopCount = 1,
            VectorizableLoops = 0,
            HasArrayAccess = true,
            ArithmeticOperationCount = 0
        };

        // Assert
        info.IsVectorizable.Should().BeFalse("No vectorizable loops");
        info.IsArithmetic.Should().BeFalse("No arithmetic operations");
        info.IsMemoryOperation.Should().BeTrue("Has array access");
    }

    private static MethodDeclarationSyntax ParseMethod(string source)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);
        return syntaxTree.GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>().First();
    }
}