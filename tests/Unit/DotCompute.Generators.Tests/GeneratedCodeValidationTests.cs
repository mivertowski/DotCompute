// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Text.RegularExpressions;
using DotCompute.Generators.Kernel;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;
using FluentAssertions;

namespace DotCompute.Tests.Unit;

public class GeneratedCodeValidationTests
{
    private readonly KernelSourceGenerator _generator = new();

    [Fact]
    public void GeneratedCode_ShouldCompileWithoutErrors()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "AddArrays",
            TestHelper.Parameters.TwoArrays,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var generatedSources = result.GeneratedSources.Select(s => s.SourceText.ToString()).ToArray();
        var allSources = new[] { source }.Concat(generatedSources).ToArray();
        var compilation = TestHelper.CreateUnsafeCompilation(allSources);

        // Assert
        var diagnostics = compilation.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();

        diagnostics.Should().BeEmpty($"Generated code should compile without errors. Errors: {string.Join(", ", diagnostics.Select(d => d.GetMessage()}");
    }

    [Fact]
    public void GeneratedKernelRegistry_ShouldHaveValidStructure()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "AddArrays",
            TestHelper.Parameters.TwoArrays,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var registryCode = TestHelper.GetGeneratedSource(result, "KernelRegistry.g.cs");

        // Assert
        Assert.NotNull(registryCode);
        Assert.Contains("namespace DotCompute.Generated", registryCode);
        Assert.Contains("public static class KernelRegistry", registryCode);
        registryCode.Contain("public static KernelRegistration GetKernel(string name)");
        registryCode.Contain("public static bool TryGetKernel(string name, out KernelRegistration kernel)");
        registryCode.Contain("public static IEnumerable<KernelRegistration> GetAllKernels()");
        Assert.Contains("TestKernels.AddArrays", registryCode);
    }

    [Fact]
    public void GeneratedCpuImplementation_ShouldHaveAllRequiredMethods()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "ProcessData",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.ScalarOperation);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();

        // Assert
        Assert.NotNull(cpuCode);
        Assert.Contains("ExecuteScalar", cpuCode);
        Assert.Contains("ExecuteSIMD", cpuCode);
        Assert.Contains("ExecuteParallel", cpuCode);
        Assert.Contains("public static unsafe class ProcessDataCpuKernel", cpuCode);
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidNamespaces()
    {
        // Arrange
        var source = @"
using DotCompute.Generators.Kernel;
using FluentAssertions;

namespace MyProject.Kernels
{
    public class MathKernels
    {
        [Kernel]
        public static void Add(float[] a, float[] b, float[] result, int length)
        {
            for (int i = 0; i < length; i++)
            {
                result[i] = a[i] + b[i];
            }
        }
    }
}";

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            if (code.Contains("namespace"))
            {
                // Should contain valid namespace declarations
                code.Should().MatchRegex(@"namespace\s+[\w\.]+\s*\{");
                
                // Should not contain invalid characters in namespace
                code.Should().NotContain("namespace  {");
                code.Should().NotContain("namespace {");
            }
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveProperAutoGeneratedHeaders()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "TestMethod",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.MemoryCopy);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            Assert.StartsWith("// <auto-generated/>", code);
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidUsings()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "TestMethod",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            
            // Should have required using statements for CPU implementations
            if (code.Contains("ExecuteScalar") || code.Contains("ExecuteSIMD"))
            {
                Assert.Contains("using System;", code);
                Assert.Contains("using System.Runtime.CompilerServices;", code);
                Assert.Contains("using System.Runtime.Intrinsics;", code);
            }
        }
    }

    [Fact]
    public void GeneratedInvoker_ShouldHaveValidSwitchStatement()
    {
        // Arrange
        var source = @"
using DotCompute.Generators.Kernel;
using FluentAssertions;

public class MultiKernels
{
    [Kernel]
    public static void Add(float[] a, float[] b, float[] result, int length) { }
    
    [Kernel]
    public static void Multiply(float[] a, float[] b, float[] result, int length) { }
}";

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var invokerCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("Invoker.g.cs"))?.SourceText.ToString();

        // Assert
        Assert.NotNull(invokerCode);
        invokerCode.Contain("switch (methodName)");
        Assert.Contains("case \"Add\":", invokerCode);
        Assert.Contains("case \"Multiply\":", invokerCode);
        Assert.Contains("InvokeAdd", invokerCode);
        Assert.Contains("InvokeMultiply", invokerCode);
        Assert.Contains("default:", invokerCode);
    }

    [Fact]
    public void GeneratedCode_ShouldHandleSpecialCharactersInNames()
    {
        // Arrange
        var source = @"
using DotCompute.Generators.Kernel;
using FluentAssertions;

public class Special_Class_123
{
    [Kernel]
    public static void Method_With_Underscores(float[] input_data, float[] output_data, int data_length)
    {
        for (int i = 0; i < data_length; i++)
        {
            output_data[i] = input_data[i];
        }
    }
}";

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        var compilation = TestHelper.CreateUnsafeCompilation(
            new[] { source }.Concat(result.GeneratedSources.Select(s => s.SourceText.ToString().ToArray());
        
        var errors = compilation.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();
        
        Assert.Empty(errors);
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidParameterHandling()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "ComplexParameters",
            "float[] input, double[] weights, int[] indices, float scale, int count",
            "// Complex parameter handling");

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();
        Assert.NotNull(cpuCode);
        
        // Should handle all parameter types
        Assert.Contains("float[] input", cpuCode);
        Assert.Contains("double[] weights", cpuCode);
        Assert.Contains("int[] indices", cpuCode);
        Assert.Contains("float scale", cpuCode);
        Assert.Contains("int count", cpuCode);
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidMethodSignatures()
    {
        // Arrange
        var source = TestHelper.CreateUnsafeKernelSource(
            "UnsafeKernels",
            "PointerKernel",
            "float* input, float* output, int length",
            TestHelper.KernelBodies.MemoryCopy);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();
        Assert.NotNull(cpuCode);
        
        // Should handle pointer parameters correctly
        Assert.Contains("float* input", cpuCode);
        Assert.Contains("float* output", cpuCode);
        Assert.Contains("public static unsafe class", cpuCode);
    }

    [Theory]
    [InlineData("Add", "result[i] = a[i] + b[i];")]
    [InlineData("Multiply", "result[i] = a[i] * b[i];")]
    [InlineData("Scale", "result[i] = input[i] * scale;")]
    public void GeneratedCode_ShouldPreserveKernelLogic(string methodName, string operation)
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            methodName,
            "float[] a, float[] b, float[] result, int length",
            $@"for (int i = 0; i < length; i++) {{ {operation} }}");

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var compilation = TestHelper.CreateUnsafeCompilation(
            new[] { source }.Concat(result.GeneratedSources.Select(s => s.SourceText.ToString().ToArray());

        // Assert
        var errors = compilation.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();
        
        errors.Should().BeEmpty($"Generated code for {methodName} should compile without errors");
    }

    [Fact]
    public void GeneratedCode_ShouldHandleMultipleBackends()
    {
        // Arrange
        var source = TestHelper.CreateKernelWithAttributes(
            "MultiBackendKernels",
            "ProcessData",
            "Backends = KernelBackends.CPU | KernelBackends.CUDA | KernelBackends.Metal",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.ScalarOperation);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Contain(s => s.HintName.Contains("CPU.g.cs"));
        result.GeneratedSources.Contain(s => s.HintName.Contains("CUDA.g.cs"));
        result.GeneratedSources.Contain(s => s.HintName.Contains("Metal.g.cs"));
        
        // Each backend implementation should be valid
        foreach (var generated in result.GeneratedSources.Where(s => s.HintName.Contains(".g.cs")
        {
            var code = generated.SourceText.ToString();
            code.NotBeNullOrWhiteSpace();
            Assert.StartsWith("// <auto-generated/>", code);
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveConsistentFormatting()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "FormattingTest",
            "TestFormatting",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            
            // Should have consistent indentation
            var lines = code.Split('\n');
            foreach (var line in lines.Where(l => !string.IsNullOrWhiteSpace(l)
            {
                if (line.TrimStart() != line)
                {
                    // Indented lines should use spaces, not tabs
                    var indent = line.TakeWhile(char.IsWhiteSpace).ToArray();
                    indent.OnlyContain(' ', "Generated code should use spaces for indentation");
                }
            }
            
            // Should have proper brace formatting
            code.Should().NotContain("{\n\n\n", "Should not have excessive blank lines after opening braces");
            code.Should().NotContain("}\n\n\n\n", "Should not have excessive blank lines after closing braces");
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidDocumentationComments()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "DocumentedKernels",
            "WellDocumented",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();
        Assert.NotNull(cpuCode);
        
        // Should have XML documentation comments
        Assert.Contains("/// <summary>", cpuCode);
        Assert.Contains("/// </summary>", cpuCode);
        
        // Documentation should be properly formatted
        var docLines = cpuCode.Split('\n').Where(line => line.TrimStart().StartsWith("///")).ToList();
        foreach (var line in docLines)
        {
            line.Should().MatchRegex(@"^\s*///", "Documentation comments should be properly formatted");
        }
    }
}
