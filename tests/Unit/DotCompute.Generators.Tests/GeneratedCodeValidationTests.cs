// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Text.RegularExpressions;
using DotCompute.Generators.Kernel;
using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace DotCompute.Tests.Unit;

public class GeneratedCodeValidationTests
{
    private readonly KernelSourceGenerator _generator = new();

    [Fact]
    public void GeneratedCode_ShouldCompileWithoutErrors()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "AddArrays",
            TestHelper.Parameters.TwoArrays,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var generatedSources = result.GeneratedSources.Select(s => s.SourceText.ToString()).ToArray();
        var allSources = new[] { source }.Concat(generatedSources).ToArray();
        var compilation = TestHelper.CreateUnsafeCompilation(allSources);

        // Assert
        var diagnostics = compilation.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();

        diagnostics.Should().BeEmpty($"Generated code should compile without errors. Errors: {string.Join(", ", diagnostics.Select(d => d.GetMessage()))}");
    }

    [Fact]
    public void GeneratedKernelRegistry_ShouldHaveValidStructure()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "AddArrays",
            TestHelper.Parameters.TwoArrays,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var registryCode = TestHelper.GetGeneratedSource(result, "KernelRegistry.g.cs");

        // Assert
        registryCode.Should().NotBeNull();
        registryCode.Should().Contain("namespace DotCompute.Generated");
        registryCode.Should().Contain("public static class KernelRegistry");
        registryCode.Should().Contain("public static KernelRegistration GetKernel(string name)");
        registryCode.Should().Contain("public static bool TryGetKernel(string name, out KernelRegistration kernel)");
        registryCode.Should().Contain("public static IEnumerable<KernelRegistration> GetAllKernels()");
        registryCode.Should().Contain("TestKernels.AddArrays");
    }

    [Fact]
    public void GeneratedCpuImplementation_ShouldHaveAllRequiredMethods()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "ProcessData",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.ScalarOperation);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();

        // Assert
        cpuCode.Should().NotBeNull();
        cpuCode.Should().Contain("ExecuteScalar");
        cpuCode.Should().Contain("ExecuteSIMD");
        cpuCode.Should().Contain("ExecuteParallel");
        cpuCode.Should().Contain("public static unsafe class ProcessDataCpuKernel");
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidNamespaces()
    {
        // Arrange
        var source = @"
using DotCompute.Generators.Kernel;

namespace MyProject.Kernels
{
    public class MathKernels
    {
        [Kernel]
        public static void Add(float[] a, float[] b, float[] result, int length)
        {
            for (int i = 0; i < length; i++)
            {
                result[i] = a[i] + b[i];
            }
        }
    }
}";

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            if (code.Contains("namespace"))
            {
                // Should contain valid namespace declarations
                code.Should().MatchRegex(@"namespace\s+[\w\.]+\s*\{");
                
                // Should not contain invalid characters in namespace
                code.Should().NotContain("namespace  {");
                code.Should().NotContain("namespace {");
            }
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveProperAutoGeneratedHeaders()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "TestMethod",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.MemoryCopy);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            code.Should().StartWith("// <auto-generated/>");
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidUsings()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "TestMethod",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            
            // Should have required using statements for CPU implementations
            if (code.Contains("ExecuteScalar") || code.Contains("ExecuteSIMD"))
            {
                code.Should().Contain("using System;");
                code.Should().Contain("using System.Runtime.CompilerServices;");
                code.Should().Contain("using System.Runtime.Intrinsics;");
            }
        }
    }

    [Fact]
    public void GeneratedInvoker_ShouldHaveValidSwitchStatement()
    {
        // Arrange
        var source = @"
using DotCompute.Generators.Kernel;

public class MultiKernels
{
    [Kernel]
    public static void Add(float[] a, float[] b, float[] result, int length) { }
    
    [Kernel]
    public static void Multiply(float[] a, float[] b, float[] result, int length) { }
}";

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var invokerCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("Invoker.g.cs"))?.SourceText.ToString();

        // Assert
        invokerCode.Should().NotBeNull();
        invokerCode.Should().Contain("switch (methodName)");
        invokerCode.Should().Contain("case \"Add\":");
        invokerCode.Should().Contain("case \"Multiply\":");
        invokerCode.Should().Contain("InvokeAdd");
        invokerCode.Should().Contain("InvokeMultiply");
        invokerCode.Should().Contain("default:");
    }

    [Fact]
    public void GeneratedCode_ShouldHandleSpecialCharactersInNames()
    {
        // Arrange
        var source = @"
using DotCompute.Generators.Kernel;

public class Special_Class_123
{
    [Kernel]
    public static void Method_With_Underscores(float[] input_data, float[] output_data, int data_length)
    {
        for (int i = 0; i < data_length; i++)
        {
            output_data[i] = input_data[i];
        }
    }
}";

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        var compilation = TestHelper.CreateUnsafeCompilation(
            new[] { source }.Concat(result.GeneratedSources.Select(s => s.SourceText.ToString())).ToArray());
        
        var errors = compilation.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();
        
        errors.Should().BeEmpty();
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidParameterHandling()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            "ComplexParameters",
            "float[] input, double[] weights, int[] indices, float scale, int count",
            "// Complex parameter handling");

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();
        cpuCode.Should().NotBeNull();
        
        // Should handle all parameter types
        cpuCode.Should().Contain("float[] input");
        cpuCode.Should().Contain("double[] weights");
        cpuCode.Should().Contain("int[] indices");
        cpuCode.Should().Contain("float scale");
        cpuCode.Should().Contain("int count");
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidMethodSignatures()
    {
        // Arrange
        var source = TestHelper.CreateUnsafeKernelSource(
            "UnsafeKernels",
            "PointerKernel",
            "float* input, float* output, int length",
            TestHelper.KernelBodies.MemoryCopy);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().NotBeEmpty();
        
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();
        cpuCode.Should().NotBeNull();
        
        // Should handle pointer parameters correctly
        cpuCode.Should().Contain("float* input");
        cpuCode.Should().Contain("float* output");
        cpuCode.Should().Contain("public static unsafe class");
    }

    [Theory]
    [InlineData("Add", "result[i] = a[i] + b[i];")]
    [InlineData("Multiply", "result[i] = a[i] * b[i];")]
    [InlineData("Scale", "result[i] = input[i] * scale;")]
    public void GeneratedCode_ShouldPreserveKernelLogic(string methodName, string operation)
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "TestKernels",
            methodName,
            "float[] a, float[] b, float[] result, int length",
            $@"for (int i = 0; i < length; i++) {{ {operation} }}");

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);
        var compilation = TestHelper.CreateUnsafeCompilation(
            new[] { source }.Concat(result.GeneratedSources.Select(s => s.SourceText.ToString())).ToArray());

        // Assert
        var errors = compilation.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();
        
        errors.Should().BeEmpty($"Generated code for {methodName} should compile without errors");
    }

    [Fact]
    public void GeneratedCode_ShouldHandleMultipleBackends()
    {
        // Arrange
        var source = TestHelper.CreateKernelWithAttributes(
            "MultiBackendKernels",
            "ProcessData",
            "Backends = KernelBackends.CPU | KernelBackends.CUDA | KernelBackends.Metal",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.ScalarOperation);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        result.GeneratedSources.Should().Contain(s => s.HintName.Contains("CPU.g.cs"));
        result.GeneratedSources.Should().Contain(s => s.HintName.Contains("CUDA.g.cs"));
        result.GeneratedSources.Should().Contain(s => s.HintName.Contains("Metal.g.cs"));
        
        // Each backend implementation should be valid
        foreach (var generated in result.GeneratedSources.Where(s => s.HintName.Contains(".g.cs")))
        {
            var code = generated.SourceText.ToString();
            code.Should().NotBeNullOrWhiteSpace();
            code.Should().StartWith("// <auto-generated/>");
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveConsistentFormatting()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "FormattingTest",
            "TestFormatting",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        foreach (var generated in result.GeneratedSources)
        {
            var code = generated.SourceText.ToString();
            
            // Should have consistent indentation
            var lines = code.Split('\n');
            foreach (var line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
            {
                if (line.TrimStart() != line)
                {
                    // Indented lines should use spaces, not tabs
                    var indent = line.TakeWhile(char.IsWhiteSpace).ToArray();
                    indent.Should().OnlyContain(' ', "Generated code should use spaces for indentation");
                }
            }
            
            // Should have proper brace formatting
            code.Should().NotContain("{\n\n\n", "Should not have excessive blank lines after opening braces");
            code.Should().NotContain("}\n\n\n\n", "Should not have excessive blank lines after closing braces");
        }
    }

    [Fact]
    public void GeneratedCode_ShouldHaveValidDocumentationComments()
    {
        // Arrange
        var source = TestHelper.CreateKernelSource(
            "DocumentedKernels",
            "WellDocumented",
            TestHelper.Parameters.SingleArray,
            TestHelper.KernelBodies.SimpleAdd);

        // Act
        var result = TestHelper.RunIncrementalGenerator(_generator, source);

        // Assert
        var cpuCode = result.GeneratedSources.FirstOrDefault(s => s.HintName.Contains("CPU.g.cs"))?.SourceText.ToString();
        cpuCode.Should().NotBeNull();
        
        // Should have XML documentation comments
        cpuCode.Should().Contain("/// <summary>");
        cpuCode.Should().Contain("/// </summary>");
        
        // Documentation should be properly formatted
        var docLines = cpuCode.Split('\n').Where(line => line.TrimStart().StartsWith("///")).ToList();
        foreach (var line in docLines)
        {
            line.Should().MatchRegex(@"^\s*///", "Documentation comments should be properly formatted");
        }
    }
}