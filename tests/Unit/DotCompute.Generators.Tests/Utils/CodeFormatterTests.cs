// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Collections.Generic;
using System.Linq;
using DotCompute.Generators.Utils;
using Xunit;

namespace DotCompute.Generators.Tests.Utils;

/// <summary>
/// Unit tests for the CodeFormatter utility class.
/// </summary>
public class CodeFormatterTests
{
    [Fact]
    public void GenerateHeader_WithSingleUsing_GeneratesCorrectHeader()
    {
        // Arrange
        var expectedUsing = "System";
        
        // Act
        var result = CodeFormatter.GenerateHeader(expectedUsing);
        
        // Assert
        Assert.Contains("// <auto-generated/>", result);
        Assert.Contains("using System;", result);
        Assert.Contains("#nullable enable", result);
        Assert.Contains("#pragma warning disable", result);
    }
    
    [Fact]
    public void GenerateHeader_WithMultipleUsings_GeneratesAllUsings()
    {
        // Arrange
        var usings = new[] { "System", "System.Linq", "System.Collections.Generic" };
        
        // Act
        var result = CodeFormatter.GenerateHeader(usings);
        
        // Assert
        Assert.Contains("using System;", result);
        Assert.Contains("using System.Linq;", result);
        Assert.Contains("using System.Collections.Generic;", result);
    }
    
    [Fact]
    public void GenerateHeader_WithNoUsings_GeneratesBasicHeader()
    {
        // Act
        var result = CodeFormatter.GenerateHeader();
        
        // Assert
        Assert.Contains("// <auto-generated/>", result);
        Assert.Contains("#nullable enable", result);
        Assert.DoesNotContain("using", result);
    }
    
    [Fact]
    public void BeginNamespace_GeneratesCorrectNamespaceDeclaration()
    {
        // Arrange
        var namespaceName = "DotCompute.Generated";
        
        // Act
        var result = CodeFormatter.BeginNamespace(namespaceName);
        
        // Assert
        Assert.Equal($"namespace {namespaceName}\n{{\n", result);
    }
    
    [Fact]
    public void EndNamespace_GeneratesClosingBrace()
    {
        // Act
        var result = CodeFormatter.EndNamespace();
        
        // Assert
        Assert.Equal("}\n", result);
    }
    
    [Fact]
    public void Indent_WithSingleLine_IndentsCorrectly()
    {
        // Arrange
        var code = "var x = 10;";
        var level = 2;
        
        // Act
        var result = CodeFormatter.Indent(code, level);
        
        // Assert
        Assert.Equal("        var x = 10;", result);
    }
    
    [Fact]
    public void Indent_WithMultipleLines_IndentsEachLine()
    {
        // Arrange
        var code = "var x = 10;\nvar y = 20;";
        var level = 1;
        
        // Act
        var result = CodeFormatter.Indent(code, level);
        
        // Assert
        var lines = result.Split('\n');
        Assert.Equal("    var x = 10;", lines[0]);
        Assert.Equal("    var y = 20;", lines[1]);
    }
    
    [Fact]
    public void Indent_WithEmptyString_ReturnsEmptyString()
    {
        // Act
        var result = CodeFormatter.Indent("", 3);
        
        // Assert
        Assert.Equal("", result);
    }
    
    [Fact]
    public void Indent_WithNullString_ReturnsEmptyString()
    {
        // Act
        var result = CodeFormatter.Indent(null!, 2);
        
        // Assert
        Assert.Equal("", result);
    }
    
    [Theory]
    [InlineData(0, "")]
    [InlineData(1, "    ")]
    [InlineData(2, "        ")]
    [InlineData(3, "            ")]
    public void Indent_WithDifferentLevels_GeneratesCorrectIndentation(int level, string expectedIndent)
    {
        // Arrange
        var code = "test";
        
        // Act
        var result = CodeFormatter.Indent(code, level);
        
        // Assert
        Assert.Equal($"{expectedIndent}test", result);
    }
    
    [Fact]
    public void Indent_PreservesEmptyLines()
    {
        // Arrange
        var code = "line1\n\nline2";
        var level = 1;
        
        // Act
        var result = CodeFormatter.Indent(code, level);
        
        // Assert
        var lines = result.Split('\n');
        Assert.Equal("    line1", lines[0]);
        Assert.Equal("", lines[1]);
        Assert.Equal("    line2", lines[2]);
    }

    #region Additional Format Method Tests

    [Fact]
    public void FormatClassDeclaration_WithAttributes_FormatsCorrectly()
    {
        // Arrange
        var className = "TestClass";
        var attributes = "[Serializable]\n[DataContract]";
        var modifiers = "public sealed";
        
        // Act
        var result = CodeFormatter.FormatClassDeclaration(className, modifiers, attributes);
        
        // Assert
        Assert.Contains("[Serializable]", result);
        Assert.Contains("[DataContract]", result);
        Assert.Contains("public sealed class TestClass", result);
    }

    [Fact]
    public void FormatMethodSignature_WithParameters_FormatsCorrectly()
    {
        // Arrange
        var returnType = "Task<int>";
        var methodName = "ProcessAsync";
        var parameters = new[] { "string input", "CancellationToken token" };
        
        // Act
        var result = CodeFormatter.FormatMethodSignature(returnType, methodName, parameters);
        
        // Assert
        Assert.Contains("Task<int> ProcessAsync", result);
        Assert.Contains("string input", result);
        Assert.Contains("CancellationToken token", result);
    }

    [Fact]
    public void FormatComment_SingleLine_FormatsCorrectly()
    {
        // Arrange
        var comment = "This is a test comment";
        
        // Act
        var result = CodeFormatter.FormatComment(comment, CommentStyle.SingleLine);
        
        // Assert
        Assert.Equal("// This is a test comment", result);
    }

    [Fact]
    public void FormatComment_XmlDoc_FormatsCorrectly()
    {
        // Arrange
        var summary = "Processes the input data";
        
        // Act
        var result = CodeFormatter.FormatXmlDocComment(summary);
        
        // Assert
        Assert.Contains("/// <summary>", result);
        Assert.Contains("/// Processes the input data", result);
        Assert.Contains("/// </summary>", result);
    }

    [Theory]
    [InlineData("", "")]
    [InlineData("  test  ", "test")]
    [InlineData("\n\ncode\n\n", "code")]
    [InlineData("  \t mixed \t  ", "mixed")]
    public void TrimWhitespace_VariousInputs_TrimsCorrectly(string input, string expected)
    {
        // Act
        var result = CodeFormatter.TrimWhitespace(input);
        
        // Assert
        Assert.Equal(expected, result);
    }

    [Fact]
    public void FormatBraces_DifferentStyles_FormatsCorrectly()
    {
        // Arrange
        var codeK_R = "if (condition) {";
        var codeAllman = "if (condition)\n{";
        
        // Act
        var resultK_R = CodeFormatter.FormatBraces(codeK_R, BraceStyle.K_R);
        var resultAllman = CodeFormatter.FormatBraces(codeAllman, BraceStyle.Allman);
        
        // Assert
        Assert.Contains("{", resultK_R);
        Assert.Contains("\n{", resultAllman);
    }

    #endregion

    #region Edge Cases and Error Handling

    [Fact]
    public void GenerateHeader_WithDuplicateUsings_RemovesDuplicates()
    {
        // Arrange
        var usings = new[] { "System", "System", "System.Linq", "System.Linq" };
        
        // Act
        var result = CodeFormatter.GenerateHeader(usings);
        
        // Assert
        var usingCount = result.Split('\n').Count(line => line.Contains("using System;"));
        var linqCount = result.Split('\n').Count(line => line.Contains("using System.Linq;"));
        Assert.Equal(1, usingCount);
        Assert.Equal(1, linqCount);
    }

    [Fact]
    public void Indent_WithNegativeLevel_UsesZeroIndentation()
    {
        // Arrange
        var code = "test";
        
        // Act
        var result = CodeFormatter.Indent(code, -5);
        
        // Assert
        Assert.Equal("test", result);
    }

    [Fact]
    public void FormatCode_WithMixedLineEndings_NormalizesToUnix()
    {
        // Arrange
        var code = "line1\r\nline2\rline3\nline4";
        
        // Act
        var result = CodeFormatter.NormalizeLineEndings(code);
        
        // Assert
        Assert.DoesNotContain("\r", result);
        Assert.Contains("\n", result);
    }

    [Fact]
    public void FormatGenericType_HandlesNestedGenerics()
    {
        // Arrange
        var genericType = "Dictionary<string, List<int>>";
        
        // Act
        var result = CodeFormatter.FormatGenericType(genericType);
        
        // Assert
        Assert.Contains("Dictionary", result);
        Assert.Contains("string", result);
        Assert.Contains("List", result);
        Assert.Contains("int", result);
    }

    [Theory]
    [InlineData("camelCase", "CamelCase")]
    [InlineData("PascalCase", "PascalCase")]
    [InlineData("snake_case", "SnakeCase")]
    [InlineData("kebab-case", "KebabCase")]
    public void ConvertToPascalCase_VariousFormats_ConvertsCorrectly(string input, string expected)
    {
        // Act
        var result = CodeFormatter.ConvertToPascalCase(input);
        
        // Assert
        Assert.Equal(expected, result);
    }

    #endregion

    #region Integration Tests

    [Fact]
    public void FormatFullClass_WithCompleteStructure_FormatsCorrectly()
    {
        // Arrange
        var usings = new[] { "System", "System.Collections.Generic" };
        var namespaceName = "TestNamespace";
        var className = "TestClass";
        var methods = new[] { "void Method1()", "int Method2(string param)" };
        
        // Act
        var result = CodeFormatter.FormatFullClass(usings, namespaceName, className, methods);
        
        // Assert
        Assert.Contains("// <auto-generated/>", result);
        Assert.Contains("using System;", result);
        Assert.Contains($"namespace {namespaceName}", result);
        Assert.Contains($"class {className}", result);
        Assert.Contains("void Method1()", result);
        Assert.Contains("int Method2(string param)", result);
    }

    [Fact]
    public void FormatRegion_WithContent_FormatsCorrectly()
    {
        // Arrange
        var regionName = "Private Methods";
        var content = "private void Helper() { }";
        
        // Act
        var result = CodeFormatter.FormatRegion(regionName, content);
        
        // Assert
        Assert.Contains($"#region {regionName}", result);
        Assert.Contains(content, result);
        Assert.Contains("#endregion", result);
    }

    [Fact]
    public void FormatAttribute_WithParameters_FormatsCorrectly()
    {
        // Arrange
        var attributeName = "TestAttribute";
        var parameters = new Dictionary<string, string>
        {
            { "Name", "\"Test\"" },
            { "Value", "42" }
        };
        
        // Act
        var result = CodeFormatter.FormatAttribute(attributeName, parameters);
        
        // Assert
        Assert.Contains("[TestAttribute", result);
        Assert.Contains("Name = \"Test\"", result);
        Assert.Contains("Value = 42", result);
    }

    [Fact]
    public void RemoveComments_FromCode_RemovesAllComments()
    {
        // Arrange
        var code = @"
            // Single line comment
            var x = 10; // Inline comment
            /* Multi-line
               comment */
            var y = 20;
            /// <summary>XML doc</summary>
            void Method() { }";
        
        // Act
        var result = CodeFormatter.RemoveComments(code);
        
        // Assert
        Assert.DoesNotContain("//", result);
        Assert.DoesNotContain("/*", result);
        Assert.DoesNotContain("*/", result);
        Assert.Contains("var x = 10;", result);
        Assert.Contains("var y = 20;", result);
    }

    #endregion

    #region Performance and Large Input Tests

    [Fact]
    public void Indent_WithLargeFile_HandlesEfficiently()
    {
        // Arrange
        var lines = Enumerable.Range(1, 1000).Select(i => $"Line {i}");
        var code = string.Join("\n", lines);
        
        // Act
        var result = CodeFormatter.Indent(code, 2);
        
        // Assert
        var resultLines = result.Split('\n');
        Assert.Equal(1000, resultLines.Length);
        Assert.All(resultLines, line => Assert.StartsWith("        ", line));
    }

    [Fact]
    public void GenerateHeader_WithManyUsings_HandlesCorrectly()
    {
        // Arrange
        var usings = Enumerable.Range(1, 50).Select(i => $"Namespace{i}").ToArray();
        
        // Act
        var result = CodeFormatter.GenerateHeader(usings);
        
        // Assert
        foreach (var usingNamespace in usings)
        {
            Assert.Contains($"using {usingNamespace};", result);
        }
    }

    #endregion
}