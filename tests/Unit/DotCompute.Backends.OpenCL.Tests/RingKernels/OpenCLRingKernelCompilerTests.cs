// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using DotCompute.Abstractions.Kernels;
using DotCompute.Abstractions.RingKernels;
using DotCompute.Backends.OpenCL.RingKernels;
using FluentAssertions;
using Microsoft.Extensions.Logging;
using NSubstitute;
using Xunit;

namespace DotCompute.Backends.OpenCL.Tests.RingKernels;

/// <summary>
/// Unit tests for OpenCLRingKernelCompiler.
/// Tests OpenCL C code generation for persistent ring kernels.
/// </summary>
public class OpenCLRingKernelCompilerTests
{
    private readonly ILogger<OpenCLRingKernelCompiler> _mockLogger;
    private readonly OpenCLRingKernelCompiler _compiler;

    public OpenCLRingKernelCompilerTests()
    {
        _mockLogger = Substitute.For<ILogger<OpenCLRingKernelCompiler>>();
        _compiler = new OpenCLRingKernelCompiler(_mockLogger);
    }

    #region Constructor Tests

    [Fact(DisplayName = "Constructor should initialize with valid logger")]
    public void Constructor_WithValidLogger_ShouldInitialize()
    {
        // Arrange & Act
        var compiler = new OpenCLRingKernelCompiler(_mockLogger);

        // Assert
        compiler.Should().NotBeNull();
    }

    [Fact(DisplayName = "Constructor should throw on null logger")]
    public void Constructor_WithNullLogger_ShouldThrow()
    {
        // Arrange & Act
        Action act = () => _ = new OpenCLRingKernelCompiler(null!);

        // Assert
        act.Should().Throw<ArgumentNullException>()
            .WithParameterName("logger");
    }

    #endregion

    #region CompileToOpenCLC Tests

    [Fact(DisplayName = "CompileToOpenCLC should generate valid OpenCL pragmas")]
    public void CompileToOpenCLC_ShouldGenerateValidPragmas()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable");
        result.Should().Contain("#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable");
        result.Should().Contain("#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate auto-generated header comment")]
    public void CompileToOpenCLC_ShouldGenerateHeaderComment()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("// Auto-generated OpenCL C persistent ring kernel");
        result.Should().Contain("// DO NOT EDIT - Generated by OpenCLRingKernelCompiler");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate message queue structure")]
    public void CompileToOpenCLC_ShouldGenerateMessageQueue()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("typedef struct {");
        result.Should().Contain("__global char* buffer");
        result.Should().Contain("int capacity");
        result.Should().Contain("__global volatile atomic_int* head");
        result.Should().Contain("__global volatile atomic_int* tail");
        result.Should().Contain("} MessageQueue;");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate try_enqueue function")]
    public void CompileToOpenCLC_ShouldGenerateTryEnqueue()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("inline int try_enqueue(MessageQueue* queue, __local char* message, int msg_size)");
        result.Should().Contain("atomic_load_explicit");
        result.Should().Contain("atomic_compare_exchange_strong_explicit");
        result.Should().Contain("memory_order_release");
        result.Should().Contain("memory_scope_device");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate try_dequeue function")]
    public void CompileToOpenCLC_ShouldGenerateTryDequeue()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("inline int try_dequeue(MessageQueue* queue, __local char* message, int msg_size)");
        result.Should().Contain("atomic_load_explicit");
        result.Should().Contain("atomic_compare_exchange_strong_explicit");
        result.Should().Contain("memory_order_acquire");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate control structure")]
    public void CompileToOpenCLC_ShouldGenerateControlStructure()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("typedef struct {");
        result.Should().Contain("__global volatile atomic_int* active");
        result.Should().Contain("__global volatile atomic_int* terminate");
        result.Should().Contain("__global volatile atomic_long* msg_count");
        result.Should().Contain("} KernelControl;");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate persistent kernel function")]
    public void CompileToOpenCLC_ShouldGeneratePersistentKernel()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel_id", RingKernelMode.Persistent);

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("__kernel void test_kernel_id_kernel(");
        result.Should().Contain("__global MessageQueue* input_queue");
        result.Should().Contain("__global MessageQueue* output_queue");
        result.Should().Contain("__global KernelControl* control");
        result.Should().Contain("__local char* scratch");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate persistent loop for persistent mode")]
    public void CompileToOpenCLC_PersistentMode_ShouldGeneratePersistentLoop()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel", RingKernelMode.Persistent);

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("// Persistent kernel loop");
        result.Should().Contain("while (true) {");
        result.Should().Contain("// Check for termination");
        result.Should().Contain("// Wait for activation");
        result.Should().Contain("barrier(CLK_LOCAL_MEM_FENCE)");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate event-driven loop for event-driven mode")]
    public void CompileToOpenCLC_EventDrivenMode_ShouldGenerateEventLoop()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel", RingKernelMode.EventDriven);

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("// Event-driven mode: process available messages and exit");
        result.Should().Contain("while (try_dequeue(input_queue, msg_buffer, 256))");
        result.Should().Contain("// Limit burst processing");
    }

    [Fact(DisplayName = "CompileToOpenCLC should use global memory fence for graph analytics domain")]
    public void CompileToOpenCLC_GraphDomain_ShouldUseGlobalFence()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel", domain: RingKernelDomain.GraphAnalytics);

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("// Graph analytics: Synchronize work-group after message processing");
        result.Should().Contain("barrier(CLK_GLOBAL_MEM_FENCE)");
    }

    [Fact(DisplayName = "CompileToOpenCLC should use local memory fence for general domain")]
    public void CompileToOpenCLC_GeneralDomain_ShouldUseLocalFence()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel", domain: RingKernelDomain.General);

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("// Synchronize work-group");
        result.Should().Contain("barrier(CLK_LOCAL_MEM_FENCE)");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate thread ID queries")]
    public void CompileToOpenCLC_ShouldGenerateThreadIds()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("int gid = get_global_id(0)");
        result.Should().Contain("int lid = get_local_id(0)");
        result.Should().Contain("int group_id = get_group_id(0)");
        result.Should().Contain("int local_size = get_local_size(0)");
    }

    [Fact(DisplayName = "CompileToOpenCLC should throw on null kernel definition")]
    public void CompileToOpenCLC_WithNullKernelDefinition_ShouldThrow()
    {
        // Arrange
        var config = CreateTestConfig("test_kernel");

        // Act
        Action act = () => _compiler.CompileToOpenCLC(null!, "void kernel() {}", config);

        // Assert
        act.Should().Throw<ArgumentNullException>()
            .WithParameterName("kernelDefinition");
    }

    [Fact(DisplayName = "CompileToOpenCLC should throw on null config")]
    public void CompileToOpenCLC_WithNullConfig_ShouldThrow()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");

        // Act
        Action act = () => _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", null!);

        // Assert
        act.Should().Throw<ArgumentNullException>()
            .WithParameterName("config");
    }

    [Theory(DisplayName = "CompileToOpenCLC should throw on null or empty source code")]
    [InlineData(null)]
    [InlineData("")]
    [InlineData("   ")]
    public void CompileToOpenCLC_WithInvalidSourceCode_ShouldThrow(string? sourceCode)
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        Action act = () => _compiler.CompileToOpenCLC(kernelDef, sourceCode!, config);

        // Assert
        act.Should().Throw<ArgumentException>();
    }

    [Fact(DisplayName = "CompileToOpenCLC should sanitize kernel names with non-alphanumeric characters")]
    public void CompileToOpenCLC_WithSpecialCharacters_ShouldSanitize()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test-kernel.v2!");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("__kernel void test_kernel_v2__kernel(");
    }

    [Fact(DisplayName = "CompileToOpenCLC should respect capacity setting")]
    public void CompileToOpenCLC_WithCustomCapacity_ShouldReflect()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel", capacity: 512);

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().Contain("if (processed >= 512)");
    }

    [Fact(DisplayName = "CompileToOpenCLC should generate valid OpenCL C code")]
    public void CompileToOpenCLC_ShouldGenerateValidCode()
    {
        // Arrange
        var kernelDef = CreateTestKernelDefinition("TestKernel");
        var config = CreateTestConfig("test_kernel");

        // Act
        var result = _compiler.CompileToOpenCLC(kernelDef, "void kernel() {}", config);

        // Assert
        result.Should().NotBeNullOrWhiteSpace();
        result.Length.Should().BeGreaterThan(1000); // Significant code generated

        // Verify no common syntax errors
        result.Should().NotContain("}}}}"); // No excessive braces
        result.Should().NotContain(";;"); // No double semicolons
    }

    #endregion

    #region Dispose Tests

    [Fact(DisplayName = "Dispose should complete successfully")]
    public void Dispose_ShouldComplete()
    {
        // Arrange
        var compiler = new OpenCLRingKernelCompiler(_mockLogger);

        // Act
        Action act = () => compiler.Dispose();

        // Assert
        act.Should().NotThrow();
    }

    [Fact(DisplayName = "Dispose should be idempotent")]
    public void Dispose_CalledMultipleTimes_ShouldBeIdempotent()
    {
        // Arrange
        var compiler = new OpenCLRingKernelCompiler(_mockLogger);

        // Act
        compiler.Dispose();
        Action act = () => compiler.Dispose();

        // Assert
        act.Should().NotThrow();
    }

    #endregion

    #region Helper Methods

    private static KernelDefinition CreateTestKernelDefinition(string name)
    {
        return new KernelDefinition
        {
            Name = name,
            Source = "void kernel() { }",
            EntryPoint = "kernel"
        };
    }

    private static RingKernelConfig CreateTestConfig(
        string kernelId,
        RingKernelMode mode = RingKernelMode.Persistent,
        int capacity = 1024,
        RingKernelDomain domain = RingKernelDomain.General)
    {
        return new RingKernelConfig
        {
            KernelId = kernelId,
            Mode = mode,
            Capacity = capacity,
            Domain = domain,
            InputQueueSize = 256,
            OutputQueueSize = 256,
            MessagingStrategy = MessagePassingStrategy.SharedMemory
        };
    }

    #endregion
}
