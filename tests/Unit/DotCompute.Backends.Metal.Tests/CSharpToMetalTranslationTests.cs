// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System;
using DotCompute.Generators.Kernel.Attributes;
using DotCompute.Abstractions.Types;
using DotCompute.Generators.Kernel.Enums;
using FluentAssertions;
using Xunit;

namespace DotCompute.Backends.Metal.Tests;

/// <summary>
/// Tests for C# kernel to Metal Shading Language translation.
/// Focuses on testing the translation logic without requiring actual Metal execution.
/// </summary>
public class CSharpToMetalTranslationTests
{
    /// <summary>
    /// Sample C# kernel that should be translated to Metal.
    /// </summary>
    [Kernel(Backends = KernelBackends.Metal)]
    private static void VectorAdd(ReadOnlySpan<float> a, ReadOnlySpan<float> b, Span<float> result)
    {
        int idx = KernelThreadId.X;
        if (idx < result.Length)
        {
            result[idx] = a[idx] + b[idx];
        }
    }

    /// <summary>
    /// 2D kernel for matrix operations.
    /// </summary>
    [Kernel(Backends = KernelBackends.Metal)]
    private static void MatrixMultiply(
        ReadOnlySpan<float> a, 
        ReadOnlySpan<float> b, 
        Span<float> c, 
        int width,
        int height)
    {
        int row = KernelThreadId.Y;
        int col = KernelThreadId.X;
        
        if (row >= height || col >= width)
        {
            return;
        }
        
        float sum = 0.0f;
        for (int k = 0; k < width; k++)
        {
            sum += a[row * width + k] * b[k * width + col];
        }
        c[row * width + col] = sum;
    }

    [Fact]
    public void CSharpToMetal_VectorAdd_GeneratesValidMSL()
    {
        // This test validates that the translation produces valid MSL code
        var vectorAddMSL = GetGeneratedMetalCode_VectorAdd();
        
        vectorAddMSL.Should().Contain("#include <metal_stdlib>");
        vectorAddMSL.Should().Contain("kernel void VectorAdd");
        vectorAddMSL.Should().Contain("device const float*");
        vectorAddMSL.Should().Contain("device float*");
        vectorAddMSL.Should().Contain("thread_position_in_grid");
        vectorAddMSL.Should().Contain("[[buffer(0)]]");
        vectorAddMSL.Should().Contain("[[buffer(1)]]");
        vectorAddMSL.Should().Contain("[[buffer(2)]]");
    }

    [Fact]
    public void CSharpToMetal_MatrixMultiply_GeneratesValidMSL()
    {
        var matrixMSL = GetGeneratedMetalCode_MatrixMultiply();
        
        matrixMSL.Should().Contain("#include <metal_stdlib>");
        matrixMSL.Should().Contain("kernel void MatrixMultiply");
        matrixMSL.Should().Contain("uint2 gid [[thread_position_in_grid]]");
        matrixMSL.Should().Contain("int row = gid.y");
        matrixMSL.Should().Contain("int col = gid.x");
        matrixMSL.Should().Contain("for (int k = 0; k < width; k++)");
    }

    [Fact]
    public void CSharpToMetal_HandlesAtomicOperations()
    {
        var atomicMSL = GetGeneratedMetalCode_AtomicSum();
        
        atomicMSL.Should().Contain("#include <metal_atomic>");
        atomicMSL.Should().Contain("atomic_fetch_add_explicit");
        atomicMSL.Should().Contain("memory_order_relaxed");
    }

    /// <summary>
    /// Simulates the generated Metal code for VectorAdd kernel.
    /// In production, this would be generated by the source generator.
    /// </summary>
    private static string GetGeneratedMetalCode_VectorAdd()
    {
        return @"
#include <metal_stdlib>
#include <metal_atomic>
using namespace metal;

kernel void VectorAdd(
    device const float* a [[buffer(0)]],
    device const float* b [[buffer(1)]],
    device float* result [[buffer(2)]],
    constant int& length [[buffer(3)]],
    uint gid [[thread_position_in_grid]])
{
    int idx = gid;
    if (idx < length)
    {
        result[idx] = a[idx] + b[idx];
    }
}";
    }

    /// <summary>
    /// Simulates the generated Metal code for MatrixMultiply kernel.
    /// </summary>
    private static string GetGeneratedMetalCode_MatrixMultiply()
    {
        return @"
#include <metal_stdlib>
#include <metal_atomic>
using namespace metal;

kernel void MatrixMultiply(
    device const float* a [[buffer(0)]],
    device const float* b [[buffer(1)]],
    device float* c [[buffer(2)]],
    constant int& width [[buffer(3)]],
    constant int& height [[buffer(4)]],
    uint2 gid [[thread_position_in_grid]])
{
    int row = gid.y;
    int col = gid.x;
    
    if (row >= height || col >= width)
    {
        return;
    }
    
    float sum = 0.0f;
    for (int k = 0; k < width; k++)
    {
        sum += a[row * width + k] * b[k * width + col];
    }
    c[row * width + col] = sum;
}";
    }

    /// <summary>
    /// Simulates the generated Metal code for atomic operations.
    /// </summary>
    private static string GetGeneratedMetalCode_AtomicSum()
    {
        return @"
#include <metal_stdlib>
#include <metal_atomic>
using namespace metal;

kernel void AtomicSum(
    device const float* data [[buffer(0)]],
    device atomic_float* result [[buffer(1)]],
    constant int& length [[buffer(2)]],
    uint gid [[thread_position_in_grid]])
{
    int idx = gid;
    if (idx < length)
    {
        atomic_fetch_add_explicit(&result[0], data[idx], memory_order_relaxed);
    }
}";
    }
}

/// <summary>
/// Mock KernelThreadId class for demonstration (would be provided by runtime).
/// </summary>
public static class KernelThreadId
{
    public static int X => 0;
    public static int Y => 0;
    public static int Z => 0;
}