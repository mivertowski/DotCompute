using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.SourceGenerators.Testing;
using Xunit;
using System.Threading.Tasks;
using DotCompute.Generators.Kernel;
using FluentAssertions;

namespace DotCompute.Generators.Tests
{
    public class KernelSourceGeneratorTests
    {
        [Fact]
        public async Task GeneratesKernelRegistryForSimpleKernel()
        {
            var source = @"
using DotCompute.Generators.Kernel;
using System;

namespace TestNamespace
{
    public unsafe class TestKernels
    {
        [Kernel(Backends = KernelBackends.CPU | KernelBackends.CUDA, VectorSize = 8)]
        public static void AddVectors(float* a, float* b, float* result, int length)
        {
            for (int i = 0; i < length; i++)
            {
                result[i] = a[i] + b[i];
            }
        }
    }
}";

            var expectedGeneratedCode = @"// <auto-generated/>
using System;
using System.Collections.Generic;
using DotCompute.Abstractions;

namespace DotCompute.Generated
{
    public static class KernelRegistry
    {
        private static readonly Dictionary<string, KernelRegistration> _kernels = new()
        {
            [""TestNamespace.TestKernels.AddVectors""] = new KernelRegistration
            {
                Name = ""AddVectors"",
                FullName = ""TestNamespace.TestKernels.AddVectors"",
                ContainingType = typeof(TestNamespace.TestKernels),
                SupportedBackends = new[] { AcceleratorType.CPU, AcceleratorType.CUDA },
                VectorSize = 8,
                IsParallel = true
            },
        };

        public static KernelRegistration GetKernel(string name) => _kernels[name];
        public static bool TryGetKernel(string name, out KernelRegistration kernel) => _kernels.TryGetValue(name, out kernel);
        public static IEnumerable<KernelRegistration> GetAllKernels() => _kernels.Values;
    }

    public class KernelRegistration
    {
        public string Name { get; set; } = string.Empty;
        public string FullName { get; set; } = string.Empty;
        public Type ContainingType { get; set; } = null!;
        public AcceleratorType[] SupportedBackends { get; set; } = Array.Empty<AcceleratorType>();
        public int VectorSize { get; set; }
        public bool IsParallel { get; set; }
    }
}";

            // Create test harness
            var test = new CSharpSourceGeneratorTest<KernelSourceGenerator, XUnitVerifier>
            {
                TestState =
                {
                    Sources = { source },
                    GeneratedSources =
                    {
                        (typeof(KernelSourceGenerator), "KernelRegistry.g.cs", expectedGeneratedCode)
                    },
                },
            };

            // Add required references
            test.TestState.AdditionalReferences.Add(typeof(KernelAttribute).Assembly);

            await test.RunAsync();
        }

        [Fact]
        public async Task GeneratesCpuImplementationForVectorizedKernel()
        {
            var source = @"
using DotCompute.Generators.Kernel;
using System;

namespace TestNamespace
{
    public unsafe class MathKernels
    {
        [Kernel(Backends = KernelBackends.CPU, VectorSize = 8, IsParallel = true)]
        public static void MultiplyAdd(float* a, float* b, float* c, float* result, int length)
        {
            for (int i = 0; i < length; i++)
            {
                result[i] = a[i] * b[i] + c[i];
            }
        }
    }
}";

            // Create test harness
            var test = new CSharpSourceGeneratorTest<KernelSourceGenerator, XUnitVerifier>
            {
                TestState =
                {
                    Sources = { source },
                },
            };

            // Add required references
            test.TestState.AdditionalReferences.Add(typeof(KernelAttribute).Assembly);

            await test.RunAsync();

            // Verify that CPU implementation file was generated
            test.TestState.GeneratedSources.Should().Contain(
                source => source.HintName.Contains("MultiplyAdd_CPU.g.cs"));
        }

        [Fact]
        public void AnalyzerDetectsInvalidVectorSize()
        {
            var source = @"
using DotCompute.Generators.Kernel;
using System;

namespace TestNamespace
{
    public class InvalidKernels
    {
        [Kernel(VectorSize = 7)] // Invalid vector size
        public static unsafe void InvalidVectorSize(float* data, int length)
        {
            // Implementation
        }
    }
}";

            var compilation = CreateCompilation(source);
            var diagnostics = compilation.GetDiagnostics();

            diagnostics.Should().Contain(d => 
                d.Id == KernelCompilationAnalyzer.InvalidVectorSizeId &&
                d.Severity == DiagnosticSeverity.Error);
        }

        [Fact]
        public void AnalyzerDetectsMissingBufferParameter()
        {
            var source = @"
using DotCompute.Generators.Kernel;
using System;

namespace TestNamespace
{
    public class InvalidKernels
    {
        [Kernel] // No buffer parameters
        public static void NoBufferKernel(int a, int b)
        {
            // Implementation
        }
    }
}";

            var compilation = CreateCompilation(source);
            var diagnostics = compilation.GetDiagnostics();

            diagnostics.Should().Contain(d => 
                d.Id == KernelCompilationAnalyzer.MissingBufferParameterId &&
                d.Severity == DiagnosticSeverity.Error);
        }

        private static Compilation CreateCompilation(string source)
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(source);
            var references = new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(KernelAttribute).Assembly.Location)
            };

            return CSharpCompilation.Create(
                assemblyName: "TestAssembly",
                syntaxTrees: new[] { syntaxTree },
                references: references,
                options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
        }
    }
}