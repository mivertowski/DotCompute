// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Testing.Verifiers;
using Xunit;

namespace DotCompute.Generators.Tests;

public class VectorOperationsGeneratorTests
{
    [Fact]
    public async Task GenerateVectorOps_ForVectorClass_GeneratesCorrectly()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class Vector3
    {
        public float X { get; set; }
        public float Y { get; set; }
        public float Z { get; set; }
    }
}";

        var expected = @"// <auto-generated/>
namespace TestNamespace
{
    partial class Vector3
    {
        public static Vector3 operator +(Vector3 left, Vector3 right)
        {
            return new Vector3
            {
                X = left.X + right.X,
                Y = left.Y + right.Y,
                Z = left.Z + right.Z
            };
        }

        public static Vector3 operator -(Vector3 left, Vector3 right)
        {
            return new Vector3
            {
                X = left.X - right.X,
                Y = left.Y - right.Y,
                Z = left.Z - right.Z
            };
        }

        public static Vector3 operator *(Vector3 left, float scalar)
        {
            return new Vector3
            {
                X = left.X * scalar,
                Y = left.Y * scalar,
                Z = left.Z * scalar
            };
        }

        public static Vector3 operator /(Vector3 left, float scalar)
        {
            return new Vector3
            {
                X = left.X / scalar,
                Y = left.Y / scalar,
                Z = left.Z / scalar
            };
        }

        public float Dot(Vector3 other)
        {
            return X * other.X + Y * other.Y + Z * other.Z;
        }

        public float Magnitude()
        {
            return System.MathF.Sqrt(X * X + Y * Y + Z * Z);
        }

        public Vector3 Normalize()
        {
            var mag = Magnitude();
            return mag > 0 ? this / mag : this;
        }
    }
}";

        await VerifyGeneratorAsync(source, expected);
    }

    [Fact]
    public async Task GenerateVectorOps_NonPartialClass_ProducesDiagnostic()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public class Vector2
    {
        public float X { get; set; }
        public float Y { get; set; }
    }
}";

        var diagnostic = DiagnosticResult.CompilerError("DCGEN001")
            .WithSpan(7, 18, 7, 25)
            .WithMessage("Class 'Vector2' must be declared as partial to use GenerateVectorOps");

        await VerifyGeneratorWithDiagnosticsAsync(source, diagnostic);
    }

    [Fact]
    public async Task GenerateVectorOps_NoNumericProperties_ProducesDiagnostic()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class InvalidVector
    {
        public string Name { get; set; }
    }
}";

        var diagnostic = DiagnosticResult.CompilerError("DCGEN002")
            .WithSpan(7, 26, 7, 39)
            .WithMessage("Class 'InvalidVector' must have at least one numeric property to use GenerateVectorOps");

        await VerifyGeneratorWithDiagnosticsAsync(source, diagnostic);
    }

    [Fact]
    public async Task GenerateVectorOps_DifferentNumericTypes_GeneratesCorrectly()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class MixedVector
    {
        public double X { get; set; }
        public double Y { get; set; }
        public int Index { get; set; }
    }
}";

        // Should generate operations only for double properties
        await VerifyGeneratorAsync(source);
    }

    [Fact]
    public async Task GenerateVectorOps_NestedNamespace_GeneratesCorrectly()
    {
        var source = @"
using DotCompute.Abstractions;

namespace Outer.Inner.Nested
{
    [GenerateVectorOps]
    public partial class Vector4
    {
        public float X { get; set; }
        public float Y { get; set; }
        public float Z { get; set; }
        public float W { get; set; }
    }
}";

        await VerifyGeneratorAsync(source);
    }

    [Fact]
    public async Task GenerateVectorOps_GenericClass_ProducesDiagnostic()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class GenericVector<T>
    {
        public T X { get; set; }
        public T Y { get; set; }
    }
}";

        var diagnostic = DiagnosticResult.CompilerError("DCGEN003")
            .WithSpan(7, 26, 7, 41)
            .WithMessage("Generic classes are not supported by GenerateVectorOps");

        await VerifyGeneratorWithDiagnosticsAsync(source, diagnostic);
    }

    [Fact]
    public async Task GenerateVectorOps_PrivateProperties_IgnoresPrivate()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class VectorWithPrivate
    {
        public float X { get; set; }
        public float Y { get; set; }
        private float Z { get; set; }
    }
}";

        // Should only generate operations for public properties
        await VerifyGeneratorAsync(source);
    }

    [Fact]
    public async Task GenerateVectorOps_ReadOnlyProperties_HandlesCorrectly()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class ReadOnlyVector
    {
        public float X { get; }
        public float Y { get; }
        
        public ReadOnlyVector(float x, float y)
        {
            X = x;
            Y = y;
        }
    }
}";

        await VerifyGeneratorAsync(source);
    }

    [Fact]
    public async Task GenerateVectorOps_WithExistingOperators_DoesNotDuplicate()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class VectorWithExisting
    {
        public float X { get; set; }
        public float Y { get; set; }
        
        // Existing operator should not be regenerated
        public static VectorWithExisting operator +(VectorWithExisting left, VectorWithExisting right)
        {
            return new VectorWithExisting { X = left.X + right.X, Y = left.Y + right.Y };
        }
    }
}";

        await VerifyGeneratorAsync(source);
    }

    [Fact]
    public async Task GenerateVectorOps_MultipleClasses_GeneratesForAll()
    {
        var source = @"
using DotCompute.Abstractions;

namespace TestNamespace
{
    [GenerateVectorOps]
    public partial class Vector2D
    {
        public float X { get; set; }
        public float Y { get; set; }
    }

    [GenerateVectorOps]
    public partial class Point3D
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Z { get; set; }
    }
}";

        await VerifyGeneratorAsync(source);
    }

    private async Task VerifyGeneratorAsync(string source, string? expectedGenerated = null)
    {
        var test = new CSharpSourceGeneratorTest<VectorOperationsGenerator, XUnitVerifier>
        {
            TestState =
            {
                Sources = { source },
                ReferenceAssemblies = ReferenceAssemblies.Net.Net80,
                AdditionalReferences =
                {
                    MetadataReference.CreateFromFile(typeof(GenerateVectorOpsAttribute).Assembly.Location)
                }
            }
        };

        if (expectedGenerated != null)
        {
            test.TestState.GeneratedSources.Add(
                (typeof(VectorOperationsGenerator), "Vector3.g.cs", expectedGenerated));
        }

        await test.RunAsync();
    }

    private async Task VerifyGeneratorWithDiagnosticsAsync(string source, params DiagnosticResult[] diagnostics)
    {
        var test = new CSharpSourceGeneratorTest<VectorOperationsGenerator, XUnitVerifier>
        {
            TestState =
            {
                Sources = { source },
                ReferenceAssemblies = ReferenceAssemblies.Net.Net80,
                AdditionalReferences =
                {
                    MetadataReference.CreateFromFile(typeof(GenerateVectorOpsAttribute).Assembly.Location)
                },
                ExpectedDiagnostics = { diagnostics }
            }
        };

        await test.RunAsync();
    }
}