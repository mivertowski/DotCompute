using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Order;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading.Channels;
using DotCompute.Abstractions;
using DotCompute.Memory;

namespace DotCompute.Performance.Benchmarks.Benchmarks;

/// <summary>
/// Memory transfer benchmarks comparing different data movement strategies
/// Tests host-to-device, device-to-host, and device-to-device transfers
/// Performance targets: Memory bandwidth >80% of theoretical, latency <100ns for small transfers
/// </summary>
[MemoryDiagnoser]
[SimpleJob(RunStrategy.Throughput, launchCount: 1, warmupCount: 3, iterationCount: 10)]
[MinColumn, MaxColumn, MeanColumn, MedianColumn, StdDevColumn]
[RankColumn]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
[GroupBenchmarksBy(BenchmarkDotNet.Configs.BenchmarkLogicalGroupRule.ByCategory)]
public class MemoryTransferBenchmarks
{
    private byte[] _sourceArray = Array.Empty<byte>();
    private byte[] _destinationArray = Array.Empty<byte>();
    private Memory<byte> _sourceMemory;
    private Memory<byte> _destinationMemory;
    private IntPtr _nativeSource;
    private IntPtr _nativeDestination;
    private Channel<byte[]>? _transferChannel;
    private UnifiedMemoryManager? _unifiedMemoryManager;
    
    [Params(1024, 8192, 65536, 262144, 1048576, 4194304)] // 1KB to 4MB
    public int TransferSize { get; set; }

    [GlobalSetup]
    public void Setup()
    {
        _sourceArray = new byte[TransferSize];
        _destinationArray = new byte[TransferSize];
        
        // Fill source with test data
        new Random(42).NextBytes(_sourceArray);
        
        _sourceMemory = _sourceArray.AsMemory();
        _destinationMemory = _destinationArray.AsMemory();
        
        // Allocate native memory
        _nativeSource = Marshal.AllocHGlobal(TransferSize);
        _nativeDestination = Marshal.AllocHGlobal(TransferSize);
        
        // Copy test data to native memory
        Marshal.Copy(_sourceArray, 0, _nativeSource, TransferSize);
        
        // Setup channel for async transfers
        _transferChannel = Channel.CreateUnbounded<byte[]>();
        
        // Initialize unified memory manager
        try
        {
            _unifiedMemoryManager = new UnifiedMemoryManager();\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Failed to initialize UnifiedMemoryManager: {ex.Message}\");\n        }\n    }\n\n    [GlobalCleanup]\n    public void Cleanup()\n    {\n        Marshal.FreeHGlobal(_nativeSource);\n        Marshal.FreeHGlobal(_nativeDestination);\n        _unifiedMemoryManager?.Dispose();\n    }\n\n    // ==================== ARRAY COPY BENCHMARKS ====================\n    \n    [Benchmark(Baseline = true)]\n    [BenchmarkCategory(\"ArrayCopy\")]\n    public void ArrayCopy_Standard()\n    {\n        Array.Copy(_sourceArray, _destinationArray, TransferSize);\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"ArrayCopy\")]\n    public void BufferBlockCopy()\n    {\n        Buffer.BlockCopy(_sourceArray, 0, _destinationArray, 0, TransferSize);\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"ArrayCopy\")]\n    public unsafe void UnsafeBufferCopy()\n    {\n        fixed (byte* pSource = _sourceArray, pDest = _destinationArray)\n        {\n            Buffer.MemoryCopy(pSource, pDest, TransferSize, TransferSize);\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"ArrayCopy\")]\n    public unsafe void NativeMemoryCopy()\n    {\n        NativeMemory.Copy(_nativeSource.ToPointer(), _nativeDestination.ToPointer(), (nuint)TransferSize);\n    }\n\n    // ==================== SPAN/MEMORY COPY BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"SpanCopy\")]\n    public void SpanCopyTo()\n    {\n        _sourceArray.AsSpan().CopyTo(_destinationArray.AsSpan());\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"SpanCopy\")]\n    public void MemoryCopyTo()\n    {\n        _sourceMemory.CopyTo(_destinationMemory);\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"SpanCopy\")]\n    public void ReadOnlySpanCopyTo()\n    {\n        ReadOnlySpan<byte> source = _sourceArray.AsSpan();\n        source.CopyTo(_destinationArray.AsSpan());\n    }\n\n    // ==================== VECTORIZED COPY BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Vectorized\")]\n    public unsafe void VectorizedCopy_Generic()\n    {\n        if (TransferSize < System.Numerics.Vector<byte>.Count)\n        {\n            SpanCopyTo();\n            return;\n        }\n        \n        fixed (byte* pSource = _sourceArray, pDest = _destinationArray)\n        {\n            var vectors = TransferSize / System.Numerics.Vector<byte>.Count;\n            var remainder = TransferSize % System.Numerics.Vector<byte>.Count;\n            \n            for (int i = 0; i < vectors; i++)\n            {\n                var offset = i * System.Numerics.Vector<byte>.Count;\n                var vector = Unsafe.ReadUnaligned<System.Numerics.Vector<byte>>(pSource + offset);\n                Unsafe.WriteUnaligned(pDest + offset, vector);\n            }\n            \n            // Handle remainder\n            if (remainder > 0)\n            {\n                var remainderSource = new ReadOnlySpan<byte>(pSource + vectors * System.Numerics.Vector<byte>.Count, remainder);\n                var remainderDest = new Span<byte>(pDest + vectors * System.Numerics.Vector<byte>.Count, remainder);\n                remainderSource.CopyTo(remainderDest);\n            }\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Vectorized\")]\n    public unsafe void VectorizedCopy_AVX2()\n    {\n        if (!System.Runtime.Intrinsics.X86.Avx2.IsSupported || TransferSize < 32)\n        {\n            VectorizedCopy_Generic();\n            return;\n        }\n        \n        fixed (byte* pSource = _sourceArray, pDest = _destinationArray)\n        {\n            var vectors = TransferSize / 32; // AVX2 processes 32 bytes at once\n            var remainder = TransferSize % 32;\n            \n            for (int i = 0; i < vectors; i++)\n            {\n                var offset = i * 32;\n                var vector = System.Runtime.Intrinsics.X86.Avx.LoadVector256(pSource + offset);\n                System.Runtime.Intrinsics.X86.Avx.Store(pDest + offset, vector);\n            }\n            \n            // Handle remainder\n            if (remainder > 0)\n            {\n                var remainderSource = new ReadOnlySpan<byte>(pSource + vectors * 32, remainder);\n                var remainderDest = new Span<byte>(pDest + vectors * 32, remainder);\n                remainderSource.CopyTo(remainderDest);\n            }\n        }\n    }\n\n    // ==================== PARALLEL TRANSFER BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Parallel\")]\n    public void ParallelCopy_Chunks()\n    {\n        const int chunkSize = 4096; // 4KB chunks\n        var chunks = (TransferSize + chunkSize - 1) / chunkSize;\n        \n        Parallel.For(0, chunks, i =>\n        {\n            var startIndex = i * chunkSize;\n            var length = Math.Min(chunkSize, TransferSize - startIndex);\n            \n            Array.Copy(_sourceArray, startIndex, _destinationArray, startIndex, length);\n        });\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Parallel\")]\n    public void ParallelCopy_Spans()\n    {\n        const int chunkSize = 8192; // 8KB chunks\n        var chunks = (TransferSize + chunkSize - 1) / chunkSize;\n        \n        Parallel.For(0, chunks, i =>\n        {\n            var startIndex = i * chunkSize;\n            var length = Math.Min(chunkSize, TransferSize - startIndex);\n            \n            var sourceSpan = _sourceArray.AsSpan(startIndex, length);\n            var destSpan = _destinationArray.AsSpan(startIndex, length);\n            sourceSpan.CopyTo(destSpan);\n        });\n    }\n\n    // ==================== CHANNEL-BASED TRANSFER BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Channel\")]\n    public async Task ChannelTransfer_SingleBuffer()\n    {\n        if (_transferChannel == null) return;\n        \n        var writer = _transferChannel.Writer;\n        var reader = _transferChannel.Reader;\n        \n        // Producer\n        var producerTask = Task.Run(async () =>\n        {\n            var buffer = new byte[TransferSize];\n            Array.Copy(_sourceArray, buffer, TransferSize);\n            await writer.WriteAsync(buffer);\n            writer.Complete();\n        });\n        \n        // Consumer\n        var consumerTask = Task.Run(async () =>\n        {\n            await foreach (var buffer in reader.ReadAllAsync())\n            {\n                Array.Copy(buffer, _destinationArray, TransferSize);\n            }\n        });\n        \n        await Task.WhenAll(producerTask, consumerTask);\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Channel\")]\n    public async Task ChannelTransfer_Chunked()\n    {\n        if (_transferChannel == null) return;\n        \n        var writer = _transferChannel.Writer;\n        var reader = _transferChannel.Reader;\n        const int chunkSize = 4096;\n        \n        // Producer\n        var producerTask = Task.Run(async () =>\n        {\n            for (int i = 0; i < TransferSize; i += chunkSize)\n            {\n                var length = Math.Min(chunkSize, TransferSize - i);\n                var chunk = new byte[length];\n                Array.Copy(_sourceArray, i, chunk, 0, length);\n                await writer.WriteAsync(chunk);\n            }\n            writer.Complete();\n        });\n        \n        // Consumer\n        var consumerTask = Task.Run(async () =>\n        {\n            int offset = 0;\n            await foreach (var chunk in reader.ReadAllAsync())\n            {\n                Array.Copy(chunk, 0, _destinationArray, offset, chunk.Length);\n                offset += chunk.Length;\n            }\n        });\n        \n        await Task.WhenAll(producerTask, consumerTask);\n    }\n\n    // ==================== MEMORY STREAM BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Stream\")]\n    public void MemoryStreamTransfer()\n    {\n        using var sourceStream = new MemoryStream(_sourceArray);\n        using var destStream = new MemoryStream(_destinationArray.Length);\n        \n        sourceStream.CopyTo(destStream);\n        var result = destStream.ToArray();\n        Array.Copy(result, _destinationArray, Math.Min(result.Length, _destinationArray.Length));\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Stream\")]\n    public async Task MemoryStreamTransferAsync()\n    {\n        using var sourceStream = new MemoryStream(_sourceArray);\n        using var destStream = new MemoryStream(_destinationArray.Length);\n        \n        await sourceStream.CopyToAsync(destStream);\n        var result = destStream.ToArray();\n        Array.Copy(result, _destinationArray, Math.Min(result.Length, _destinationArray.Length));\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Stream\")]\n    public void BufferedStreamTransfer()\n    {\n        using var sourceStream = new MemoryStream(_sourceArray);\n        using var destStream = new MemoryStream(_destinationArray.Length);\n        using var bufferedSource = new BufferedStream(sourceStream, 8192);\n        using var bufferedDest = new BufferedStream(destStream, 8192);\n        \n        bufferedSource.CopyTo(bufferedDest);\n        var result = destStream.ToArray();\n        Array.Copy(result, _destinationArray, Math.Min(result.Length, _destinationArray.Length));\n    }\n\n    // ==================== UNIFIED MEMORY BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Unified\")]\n    public void UnifiedMemoryTransfer()\n    {\n        if (_unifiedMemoryManager == null)\n        {\n            SpanCopyTo();\n            return;\n        }\n        \n        try\n        {\n            using var sourceBuffer = _unifiedMemoryManager.Allocate<byte>(TransferSize);\n            using var destBuffer = _unifiedMemoryManager.Allocate<byte>(TransferSize);\n            \n            // Copy data to unified buffer\n            _sourceArray.CopyTo(sourceBuffer.Span);\n            \n            // Transfer within unified memory\n            sourceBuffer.Span.CopyTo(destBuffer.Span);\n            \n            // Copy back to destination\n            destBuffer.Span.CopyTo(_destinationArray);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"UnifiedMemoryTransfer failed: {ex.Message}\");\n            SpanCopyTo(); // Fallback\n        }\n    }\n\n    // ==================== PINNED MEMORY BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Pinned\")]\n    public unsafe void PinnedMemoryTransfer()\n    {\n        // Allocate pinned arrays for better performance with unmanaged code\n        var pinnedSource = GC.AllocateUninitializedArray<byte>(TransferSize, pinned: true);\n        var pinnedDest = GC.AllocateUninitializedArray<byte>(TransferSize, pinned: true);\n        \n        try\n        {\n            // Copy to pinned memory\n            _sourceArray.CopyTo(pinnedSource, 0);\n            \n            // Transfer between pinned arrays\n            fixed (byte* pSource = pinnedSource, pDest = pinnedDest)\n            {\n                Buffer.MemoryCopy(pSource, pDest, TransferSize, TransferSize);\n            }\n            \n            // Copy back\n            pinnedDest.CopyTo(_destinationArray, 0);\n        }\n        finally\n        {\n            // Pinned arrays are automatically unpinned when they go out of scope\n        }\n    }\n\n    // ==================== LATENCY BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Latency\")]\n    public void SmallTransfer_1KB()\n    {\n        if (TransferSize < 1024) return;\n        \n        const int size = 1024;\n        var source = _sourceArray.AsSpan(0, size);\n        var dest = _destinationArray.AsSpan(0, size);\n        source.CopyTo(dest);\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Latency\")]\n    public void SmallTransfer_4KB()\n    {\n        if (TransferSize < 4096) return;\n        \n        const int size = 4096;\n        var source = _sourceArray.AsSpan(0, size);\n        var dest = _destinationArray.AsSpan(0, size);\n        source.CopyTo(dest);\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Latency\")]\n    public unsafe void SmallTransfer_Unsafe_1KB()\n    {\n        if (TransferSize < 1024) return;\n        \n        const int size = 1024;\n        fixed (byte* pSource = _sourceArray, pDest = _destinationArray)\n        {\n            Buffer.MemoryCopy(pSource, pDest, size, size);\n        }\n    }\n\n    // ==================== BANDWIDTH BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Bandwidth\")]\n    public void LargeTransfer_Sequential()\n    {\n        if (TransferSize < 1048576) return; // Only for transfers >= 1MB\n        \n        _sourceArray.AsSpan().CopyTo(_destinationArray.AsSpan());\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Bandwidth\")]\n    public void LargeTransfer_Parallel()\n    {\n        if (TransferSize < 1048576) return; // Only for transfers >= 1MB\n        \n        const int chunkSize = 64 * 1024; // 64KB chunks\n        var chunks = (TransferSize + chunkSize - 1) / chunkSize;\n        \n        Parallel.For(0, chunks, i =>\n        {\n            var startIndex = i * chunkSize;\n            var length = Math.Min(chunkSize, TransferSize - startIndex);\n            \n            var sourceSpan = _sourceArray.AsSpan(startIndex, length);\n            var destSpan = _destinationArray.AsSpan(startIndex, length);\n            sourceSpan.CopyTo(destSpan);\n        });\n    }\n\n    // ==================== PERFORMANCE VALIDATION ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Validation\")]\n    public bool ValidateTransfer()\n    {\n        // Clear destination\n        Array.Clear(_destinationArray);\n        \n        // Perform transfer\n        _sourceArray.AsSpan().CopyTo(_destinationArray.AsSpan());\n        \n        // Validate transfer\n        return _sourceArray.AsSpan().SequenceEqual(_destinationArray.AsSpan());\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Validation\")]\n    public double CalculateBandwidth()\n    {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        _sourceArray.AsSpan().CopyTo(_destinationArray.AsSpan());\n        sw.Stop();\n        \n        // Calculate bandwidth in GB/s\n        var bytesTransferred = TransferSize;\n        var timeInSeconds = sw.Elapsed.TotalSeconds;\n        var bandwidthGBps = (bytesTransferred / (1024.0 * 1024.0 * 1024.0)) / timeInSeconds;\n        \n        return bandwidthGBps;\n    }\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void DoNotOptimize<T>(T value) => GC.KeepAlive(value);\n}"