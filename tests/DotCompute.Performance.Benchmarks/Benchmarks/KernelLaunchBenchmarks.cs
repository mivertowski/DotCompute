// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Order;
using System.Runtime.CompilerServices;
using DotCompute.Abstractions;
using DotCompute.Core;
using DotCompute.Backends.CPU;

namespace DotCompute.Performance.Benchmarks.Benchmarks;

/// <summary>
/// Kernel launch and compilation benchmarks testing overhead and performance
/// Compares different kernel compilation strategies and launch patterns
/// Performance targets: Compilation <100ms, Launch overhead <5% of execution time
/// </summary>
[MemoryDiagnoser]
[SimpleJob(RunStrategy.Throughput, launchCount: 1, warmupCount: 3, iterationCount: 10)]
[MinColumn, MaxColumn, MeanColumn, MedianColumn, StdDevColumn]
[RankColumn]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
[GroupBenchmarksBy(BenchmarkDotNet.Configs.BenchmarkLogicalGroupRule.ByCategory)]
public class KernelLaunchBenchmarks
{
    private IAccelerator? _cpuAccelerator;
    private IKernelCompiler? _kernelCompiler;
    private IKernel? _compiledKernel;
    private IKernel? _cachedKernel;
    private float[] _inputData = Array.Empty<float>();
    private float[] _outputData = Array.Empty<float>();
    private IBuffer? _inputBuffer;
    private IBuffer? _outputBuffer;
    
    [Params(1024, 8192, 65536, 262144)] // Different data sizes to test overhead scaling
    public int DataSize { get; set; }

    [GlobalSetup]
    public void Setup()
    {
        try\n        {\n            _cpuAccelerator = new CpuAccelerator();\n            _kernelCompiler = _cpuAccelerator.CreateKernelCompiler();\n            \n            // Prepare test data\n            _inputData = new float[DataSize];\n            _outputData = new float[DataSize];\n            \n            var random = new Random(42);\n            for (int i = 0; i < DataSize; i++)\n            {\n                _inputData[i] = (float)random.NextDouble() * 100.0f;\n            }\n            \n            // Create buffers\n            _inputBuffer = _cpuAccelerator.CreateBuffer<float>(DataSize);\n            _outputBuffer = _cpuAccelerator.CreateBuffer<float>(DataSize);\n            \n            // Copy input data to buffer\n            _inputBuffer.CopyFrom(_inputData);\n            \n            // Pre-compile kernels for cached tests\n            SetupPrecompiledKernels();\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Setup failed: {ex.Message}\");\n        }\n    }\n\n    [GlobalCleanup]\n    public void Cleanup()\n    {\n        _inputBuffer?.Dispose();\n        _outputBuffer?.Dispose();\n        _compiledKernel?.Dispose();\n        _cachedKernel?.Dispose();\n        _cpuAccelerator?.Dispose();\n    }\n\n    private void SetupPrecompiledKernels()\n    {\n        if (_kernelCompiler == null) return;\n        \n        try\n        {\n            // Simple vector addition kernel\n            var kernelSource = @\"\n                kernel void vector_add(global float* input, global float* output, int size) {\n                    int idx = get_global_id(0);\n                    if (idx < size) {\n                        output[idx] = input[idx] + 1.0f;\n                    }\n                }\";\n            \n            var kernelDef = new KernelDefinition\n            {\n                Name = \"vector_add\",\n                Source = kernelSource,\n                EntryPoint = \"vector_add\"\n            };\n            \n            _compiledKernel = _kernelCompiler.CompileKernel(kernelDef);\n            _cachedKernel = _kernelCompiler.CompileKernel(kernelDef); // Simulate cached compilation\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Kernel compilation failed: {ex.Message}\");\n        }\n    }\n\n    // ==================== KERNEL COMPILATION BENCHMARKS ====================\n    \n    [Benchmark(Baseline = true)]\n    [BenchmarkCategory(\"Compilation\")]\n    public IKernel? CompileSimpleKernel()\n    {\n        if (_kernelCompiler == null) return null;\n        \n        var kernelSource = @\"\n            kernel void simple_add(global float* input, global float* output, int size) {\n                int idx = get_global_id(0);\n                if (idx < size) {\n                    output[idx] = input[idx] + 1.0f;\n                }\n            }\";\n        \n        var kernelDef = new KernelDefinition\n        {\n            Name = \"simple_add\",\n            Source = kernelSource,\n            EntryPoint = \"simple_add\"\n        };\n        \n        try\n        {\n            var kernel = _kernelCompiler.CompileKernel(kernelDef);\n            kernel?.Dispose(); // Clean up immediately for benchmark\n            return kernel;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Kernel compilation failed: {ex.Message}\");\n            return null;\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Compilation\")]\n    public IKernel? CompileComplexKernel()\n    {\n        if (_kernelCompiler == null) return null;\n        \n        var kernelSource = @\"\n            kernel void complex_operation(global float* input, global float* output, int size) {\n                int idx = get_global_id(0);\n                if (idx < size) {\n                    float value = input[idx];\n                    float result = 0.0f;\n                    \n                    // Simulate complex computation\n                    for (int i = 0; i < 10; i++) {\n                        result += sin(value * i) * cos(value / (i + 1));\n                    }\n                    \n                    output[idx] = result;\n                }\n            }\";\n        \n        var kernelDef = new KernelDefinition\n        {\n            Name = \"complex_operation\",\n            Source = kernelSource,\n            EntryPoint = \"complex_operation\"\n        };\n        \n        try\n        {\n            var kernel = _kernelCompiler.CompileKernel(kernelDef);\n            kernel?.Dispose();\n            return kernel;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Complex kernel compilation failed: {ex.Message}\");\n            return null;\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Compilation\")]\n    public IKernel? CompileOptimizedKernel()\n    {\n        if (_kernelCompiler == null) return null;\n        \n        var kernelSource = @\"\n            kernel void optimized_vector_add(global float* input, global float* output, int size) {\n                int idx = get_global_id(0);\n                int local_size = get_local_size(0);\n                \n                // Vectorized processing - handle multiple elements per work item\n                for (int i = idx; i < size; i += local_size * get_num_groups(0)) {\n                    if (i < size) {\n                        output[i] = input[i] + 1.0f;\n                    }\n                }\n            }\";\n        \n        var kernelDef = new KernelDefinition\n        {\n            Name = \"optimized_vector_add\",\n            Source = kernelSource,\n            EntryPoint = \"optimized_vector_add\"\n        };\n        \n        try\n        {\n            var kernel = _kernelCompiler.CompileKernel(kernelDef);\n            kernel?.Dispose();\n            return kernel;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Optimized kernel compilation failed: {ex.Message}\");\n            return null;\n        }\n    }\n\n    // ==================== KERNEL LAUNCH BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Launch\")]\n    public void LaunchPrecompiledKernel()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, new[] { 64 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Kernel launch failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Launch\")]\n    public void LaunchCachedKernel()\n    {\n        if (_cachedKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _cachedKernel.SetArgument(0, _inputBuffer);\n            _cachedKernel.SetArgument(1, _outputBuffer);\n            _cachedKernel.SetArgument(2, DataSize);\n            \n            _cachedKernel.Execute(new[] { DataSize }, new[] { 64 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Cached kernel launch failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Launch\")]\n    public void CompileAndLaunchKernel()\n    {\n        if (_kernelCompiler == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        var kernelSource = @\"\n            kernel void inline_add(global float* input, global float* output, int size) {\n                int idx = get_global_id(0);\n                if (idx < size) {\n                    output[idx] = input[idx] + 1.0f;\n                }\n            }\";\n        \n        var kernelDef = new KernelDefinition\n        {\n            Name = \"inline_add\",\n            Source = kernelSource,\n            EntryPoint = \"inline_add\"\n        };\n        \n        try\n        {\n            using var kernel = _kernelCompiler.CompileKernel(kernelDef);\n            if (kernel != null)\n            {\n                kernel.SetArgument(0, _inputBuffer);\n                kernel.SetArgument(1, _outputBuffer);\n                kernel.SetArgument(2, DataSize);\n                \n                kernel.Execute(new[] { DataSize }, new[] { 64 });\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Compile and launch failed: {ex.Message}\");\n        }\n    }\n\n    // ==================== WORK GROUP SIZE BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"WorkGroup\")]\n    public void LaunchKernel_WorkGroup32()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, new[] { 32 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"WorkGroup32 launch failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"WorkGroup\")]\n    public void LaunchKernel_WorkGroup64()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, new[] { 64 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"WorkGroup64 launch failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"WorkGroup\")]\n    public void LaunchKernel_WorkGroup128()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, new[] { 128 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"WorkGroup128 launch failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"WorkGroup\")]\n    public void LaunchKernel_WorkGroup256()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, new[] { 256 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"WorkGroup256 launch failed: {ex.Message}\");\n        }\n    }\n\n    // ==================== BATCH LAUNCH BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Batch\")]\n    public void BatchLaunch_Sequential()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        const int batchCount = 10;\n        \n        try\n        {\n            for (int i = 0; i < batchCount; i++)\n            {\n                _compiledKernel.SetArgument(0, _inputBuffer);\n                _compiledKernel.SetArgument(1, _outputBuffer);\n                _compiledKernel.SetArgument(2, DataSize);\n                \n                _compiledKernel.Execute(new[] { DataSize }, new[] { 64 });\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Batch sequential launch failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Batch\")]\n    public void BatchLaunch_Prepared()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        const int batchCount = 10;\n        \n        try\n        {\n            // Pre-set arguments once\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            // Execute multiple times\n            for (int i = 0; i < batchCount; i++)\n            {\n                _compiledKernel.Execute(new[] { DataSize }, new[] { 64 });\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Batch prepared launch failed: {ex.Message}\");\n        }\n    }\n\n    // ==================== ARGUMENT SETTING BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Arguments\")]\n    public void SetArguments_Buffer()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Buffer argument setting failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Arguments\")]\n    public void SetArguments_Scalar()\n    {\n        if (_compiledKernel == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(2, DataSize);\n            _compiledKernel.SetArgument(3, 1.0f);\n            _compiledKernel.SetArgument(4, 42);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Scalar argument setting failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Arguments\")]\n    public void SetArguments_All()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            _compiledKernel.SetArgument(3, 1.0f);\n            _compiledKernel.SetArgument(4, 42);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"All arguments setting failed: {ex.Message}\");\n        }\n    }\n\n    // ==================== EXECUTION PATTERN BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Execution\")]\n    public void Execute_1D_Global()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, null); // No local work size\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"1D global execution failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Execution\")]\n    public void Execute_1D_Local()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, new[] { 64 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"1D local execution failed: {ex.Message}\");\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Execution\")]\n    public void Execute_2D_Local()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return;\n        \n        try\n        {\n            var dim = (int)Math.Sqrt(DataSize);\n            if (dim * dim != DataSize) return; // Only for perfect squares\n            \n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { dim, dim }, new[] { 8, 8 });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"2D execution failed: {ex.Message}\");\n        }\n    }\n\n    // ==================== OVERHEAD MEASUREMENT BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Overhead\")]\n    public double MeasureLaunchOverhead()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return 0.0;\n        \n        try\n        {\n            var sw = System.Diagnostics.Stopwatch.StartNew();\n            \n            // Launch overhead measurement\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            var launchTime = sw.Elapsed;\n            \n            // Execution time\n            sw.Restart();\n            _compiledKernel.Execute(new[] { DataSize }, new[] { 64 });\n            var executionTime = sw.Elapsed;\n            \n            // Calculate overhead percentage\n            var overheadPercentage = (launchTime.TotalMicroseconds / executionTime.TotalMicroseconds) * 100.0;\n            return overheadPercentage;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Overhead measurement failed: {ex.Message}\");\n            return 0.0;\n        }\n    }\n\n    [Benchmark]\n    [BenchmarkCategory(\"Overhead\")]\n    public double MeasureCompilationTime()\n    {\n        if (_kernelCompiler == null) return 0.0;\n        \n        var kernelSource = @\"\n            kernel void overhead_test(global float* input, global float* output, int size) {\n                int idx = get_global_id(0);\n                if (idx < size) {\n                    output[idx] = input[idx] * 2.0f;\n                }\n            }\";\n        \n        var kernelDef = new KernelDefinition\n        {\n            Name = \"overhead_test\",\n            Source = kernelSource,\n            EntryPoint = \"overhead_test\"\n        };\n        \n        try\n        {\n            var sw = System.Diagnostics.Stopwatch.StartNew();\n            using var kernel = _kernelCompiler.CompileKernel(kernelDef);\n            sw.Stop();\n            \n            return sw.Elapsed.TotalMilliseconds;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Compilation time measurement failed: {ex.Message}\");\n            return 0.0;\n        }\n    }\n\n    // ==================== VALIDATION BENCHMARKS ====================\n    \n    [Benchmark]\n    [BenchmarkCategory(\"Validation\")]\n    public bool ValidateKernelExecution()\n    {\n        if (_compiledKernel == null || _inputBuffer == null || _outputBuffer == null) return false;\n        \n        try\n        {\n            // Execute kernel\n            _compiledKernel.SetArgument(0, _inputBuffer);\n            _compiledKernel.SetArgument(1, _outputBuffer);\n            _compiledKernel.SetArgument(2, DataSize);\n            \n            _compiledKernel.Execute(new[] { DataSize }, new[] { 64 });\n            \n            // Copy result back\n            _outputBuffer.CopyTo(_outputData);\n            \n            // Validate results (expecting input + 1.0f)\n            const float tolerance = 1e-6f;\n            for (int i = 0; i < DataSize; i++)\n            {\n                var expected = _inputData[i] + 1.0f;\n                if (MathF.Abs(_outputData[i] - expected) > tolerance)\n                {\n                    return false;\n                }\n            }\n            \n            return true;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Kernel validation failed: {ex.Message}\");\n            return false;\n        }\n    }\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void DoNotOptimize<T>(T value) => GC.KeepAlive(value);\n}"