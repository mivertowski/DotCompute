# DotCompute API Reference

Complete API reference for DotCompute v0.2.0-alpha, organized by functional area.

## Table of Contents

- [Core Interfaces](#core-interfaces)
- [Orchestration](#orchestration)
- [Accelerator Management](#accelerator-management)
- [Memory Management](#memory-management)
- [Kernel Definition and Compilation](#kernel-definition-and-compilation)
- [Service Registration](#service-registration)
- [Source Generation](#source-generation)
- [Debugging and Profiling](#debugging-and-profiling)
- [Configuration and Options](#configuration-and-options)
- [Exception Types](#exception-types)

## Core Interfaces

### IComputeOrchestrator

The primary interface for executing kernels across compute backends.

```csharp
namespace DotCompute.Abstractions.Interfaces;

public interface IComputeOrchestrator
{
    // Primary execution method with automatic backend selection
    Task<T> ExecuteAsync<T>(string kernelName, params object[] args);
    
    // Execute with backend preference
    Task<T> ExecuteAsync<T>(string kernelName, string preferredBackend, params object[] args);
    
    // Execute on specific accelerator
    Task<T> ExecuteAsync<T>(string kernelName, IAccelerator accelerator, params object[] args);
    
    // Execute with unified buffers for zero-copy optimization
    Task<T> ExecuteWithBuffersAsync<T>(string kernelName, 
        IEnumerable<IUnifiedMemoryBuffer> buffers, 
        params object[] scalarArgs);
    
    // Backend selection and optimization
    Task<IAccelerator?> GetOptimalAcceleratorAsync(string kernelName);
    Task<IReadOnlyList<IAccelerator>> GetSupportedAcceleratorsAsync(string kernelName);
    Task PrecompileKernelAsync(string kernelName, IAccelerator? accelerator = null);
    
    // Validation
    Task<bool> ValidateKernelArgsAsync(string kernelName, params object[] args);
}
```

**Usage Examples:**

```csharp
// Basic execution
var result = await orchestrator.ExecuteAsync<float[]>("MyKernels.VectorAdd", inputA, inputB);

// Force CPU execution
var cpuResult = await orchestrator.ExecuteAsync<float[]>("MyKernels.VectorAdd", "CPU", inputA, inputB);

// Zero-copy execution with unified buffers
await orchestrator.ExecuteWithBuffersAsync<object>("MyKernels.VectorAdd", 
    new[] { bufferA, bufferB, resultBuffer });
```

### IAccelerator

Interface representing a compute device (CPU, GPU, etc.).

```csharp
namespace DotCompute.Abstractions;

public interface IAccelerator : IAsyncDisposable
{
    AcceleratorInfo Info { get; }
    AcceleratorType Type { get; }
    IUnifiedMemoryManager Memory { get; }
    AcceleratorContext Context { get; }
    
    ValueTask<ICompiledKernel> CompileKernelAsync(
        KernelDefinition definition,
        CompilationOptions? options = null,
        CancellationToken cancellationToken = default);
        
    ValueTask SynchronizeAsync(CancellationToken cancellationToken = default);
}

public class AcceleratorInfo
{
    public required string Id { get; init; }
    public required string Name { get; init; }
    public required string DeviceType { get; init; }
    public required string Vendor { get; init; }
    public string? DriverVersion { get; init; }
    public Version? ComputeCapability { get; init; }
    public long TotalMemory { get; init; }
    public long AvailableMemory { get; init; }
    public int MaxThreadsPerBlock { get; init; }
    public bool SupportsFloat64 { get; init; }
    public bool SupportsInt64 { get; init; }
}

public enum AcceleratorType
{
    CPU,
    GPU,
    TPU,
    FPGA,
    Custom
}
```

### ICompiledKernel

Interface for compiled kernels ready for execution.

```csharp
namespace DotCompute.Abstractions;

public interface ICompiledKernel : IAsyncDisposable, IDisposable
{
    Guid Id { get; }
    string Name { get; }
    
    ValueTask ExecuteAsync(
        KernelArguments arguments,
        CancellationToken cancellationToken = default);
}
```

## Orchestration

### KernelExecutionService

Production-grade implementation of `IComputeOrchestrator`.

```csharp
namespace DotCompute.Runtime.Services;

public class KernelExecutionService : IComputeOrchestrator, IDisposable
{
    public KernelExecutionService(
        AcceleratorRuntime runtime,
        ILogger<KernelExecutionService> logger,
        IKernelCompiler compiler,
        IKernelCache cache,
        IKernelProfiler profiler);
        
    // Register kernels for execution
    public void RegisterKernel(string name, KernelDefinition definition);
    public void RegisterKernels(IEnumerable<(string Name, KernelDefinition Definition)> kernels);
    
    // Performance monitoring
    public Task<KernelExecutionMetrics> GetMetricsAsync(string kernelName);
    public Task ClearCacheAsync();
}
```

### GeneratedKernelDiscoveryService

Automatically discovers kernels generated by the source generator.

```csharp
namespace DotCompute.Runtime.Services;

public class GeneratedKernelDiscoveryService
{
    public GeneratedKernelDiscoveryService(ILogger<GeneratedKernelDiscoveryService> logger);
    
    // Discover all generated kernels in loaded assemblies
    public Task<IReadOnlyList<(string Name, KernelDefinition Definition)>> DiscoverKernelsAsync();
    
    // Discover kernels in specific assembly
    public Task<IReadOnlyList<(string Name, KernelDefinition Definition)>> DiscoverKernelsAsync(Assembly assembly);
    
    // Register discovered kernels with execution service
    public Task RegisterWithExecutionServiceAsync(KernelExecutionService executionService);
}
```

## Accelerator Management

### AcceleratorRuntime

Manages available compute accelerators.

```csharp
namespace DotCompute.Core;

public class AcceleratorRuntime : IAsyncDisposable
{
    public AcceleratorRuntime(ILogger<AcceleratorRuntime> logger);
    
    // Initialization
    public async Task InitializeAsync();
    public async Task InitializeAsync(AcceleratorConfig config);
    
    // Accelerator access
    public IReadOnlyList<IAccelerator> AvailableAccelerators { get; }
    public IAccelerator? GetAccelerator(AcceleratorType type);
    public IAccelerator? GetAccelerator(string id);
    public IEnumerable<IAccelerator> GetAccelerators(AcceleratorType type);
    
    // Backend selection
    public IAccelerator? SelectOptimal(KernelDefinition kernel, WorkloadCharacteristics workload);
}

public class WorkloadCharacteristics
{
    public int DataSize { get; init; }
    public double ComputeIntensity { get; init; }
    public bool RequiresFloat64 { get; init; }
    public bool RequiresSharedMemory { get; init; }
    public int PreferredThreadsPerBlock { get; init; }
}
```

### Backend-Specific Accelerators

#### CpuAccelerator

```csharp
namespace DotCompute.Backends.CPU;

public class CpuAccelerator : IAccelerator
{
    public CpuAccelerator(CpuAcceleratorConfig config, ILogger<CpuAccelerator> logger);
    
    // CPU-specific properties
    public int CoreCount { get; }
    public bool SupportsAvx512 { get; }
    public bool SupportsAvx2 { get; }
    public CpuCacheInfo CacheInfo { get; }
}

public class CpuAcceleratorConfig
{
    public int MaxThreads { get; set; } = Environment.ProcessorCount;
    public bool EnableSimd { get; set; } = true;
    public bool EnableVectorization { get; set; } = true;
    public ThreadingModel ThreadingModel { get; set; } = ThreadingModel.TaskParallel;
}
```

#### CudaAccelerator

```csharp
namespace DotCompute.Backends.CUDA;

public class CudaAccelerator : IAccelerator
{
    public CudaAccelerator(int deviceId, ILogger<CudaAccelerator> logger);
    
    // CUDA-specific properties
    public int DeviceId { get; }
    public Version ComputeCapability { get; }
    public int MultiprocessorCount { get; }
    public long GlobalMemorySize { get; }
    public bool SupportsUnifiedMemory { get; }
    
    // CUDA-specific operations
    public Task<bool> CanAccessPeerAsync(CudaAccelerator peer);
    public Task EnablePeerAccessAsync(CudaAccelerator peer);
}
```

## Memory Management

### IUnifiedMemoryBuffer<T>

Generic interface for unified memory buffers.

```csharp
namespace DotCompute.Abstractions.Memory;

public interface IUnifiedMemoryBuffer<T> : IUnifiedMemoryBuffer, IAsyncDisposable 
    where T : unmanaged
{
    // Properties
    int Length { get; }
    long SizeInBytes { get; }
    bool IsOnHost { get; }
    bool IsOnDevice { get; }
    bool IsDirty { get; }
    BufferState State { get; }
    
    // Host access
    Span<T> AsSpan();
    ReadOnlySpan<T> AsReadOnlySpan();
    Memory<T> AsMemory();
    ReadOnlyMemory<T> AsReadOnlyMemory();
    
    // Device access
    DeviceMemory GetDeviceMemory();
    
    // Transfer management
    void EnsureOnHost();
    void EnsureOnDevice();
    ValueTask EnsureOnHostAsync(AcceleratorContext context = default, CancellationToken cancellationToken = default);
    ValueTask EnsureOnDeviceAsync(AcceleratorContext context = default, CancellationToken cancellationToken = default);
    
    // State management
    void MarkHostDirty();
    void MarkDeviceDirty();
    void Synchronize();
    ValueTask SynchronizeAsync(AcceleratorContext context = default, CancellationToken cancellationToken = default);
    
    // Data operations
    ValueTask<T[]> ReadAsync(int offset = 0, int? count = null, CancellationToken cancellationToken = default);
    ValueTask WriteAsync(ReadOnlyMemory<T> data, int offset = 0, CancellationToken cancellationToken = default);
    ValueTask CopyFromAsync(ReadOnlyMemory<T> source, CancellationToken cancellationToken = default);
    ValueTask CopyToAsync(Memory<T> destination, CancellationToken cancellationToken = default);
    ValueTask FillAsync(T value, CancellationToken cancellationToken = default);
    
    // Advanced operations
    IUnifiedMemoryBuffer<T> Slice(int offset, int length);
    IUnifiedMemoryBuffer<TNew> AsType<TNew>() where TNew : unmanaged;
    MappedMemory<T> Map(MapMode mode = MapMode.ReadWrite);
    ValueTask<MappedMemory<T>> MapAsync(MapMode mode = MapMode.ReadWrite, CancellationToken cancellationToken = default);
}

public enum BufferState
{
    Uninitialized,
    HostOnly,
    DeviceOnly,
    Synchronized,
    HostDirty,
    DeviceDirty
}

public enum MapMode
{
    Read,
    Write,
    ReadWrite
}
```

### UnifiedBuffer<T>

Concrete implementation of unified memory buffer.

```csharp
namespace DotCompute.Memory;

public sealed class UnifiedBuffer<T> : IUnifiedMemoryBuffer<T> where T : unmanaged
{
    // Constructors
    public UnifiedBuffer(IUnifiedMemoryManager memoryManager, int length);
    public UnifiedBuffer(IUnifiedMemoryManager memoryManager, ReadOnlySpan<T> data);
    
    // All interface methods implemented...
}
```

### IUnifiedMemoryManager

Interface for memory allocation and management.

```csharp
namespace DotCompute.Abstractions.Memory;

public interface IUnifiedMemoryManager : IAsyncDisposable
{
    // Properties
    long TotalMemory { get; }
    long AvailableMemory { get; }
    long MaxAllocationSize { get; }
    bool SupportsUnifiedAddressing { get; }
    
    // Allocation
    ValueTask<IUnifiedMemoryBuffer<T>> AllocateAsync<T>(int length, MemoryOptions options = MemoryOptions.None, CancellationToken cancellationToken = default) where T : unmanaged;
    ValueTask<IUnifiedMemoryBuffer<T>> AllocateAsync<T>(ReadOnlyMemory<T> initialData, MemoryOptions options = MemoryOptions.None, CancellationToken cancellationToken = default) where T : unmanaged;
    
    // Statistics
    MemoryStatistics GetStatistics();
    ValueTask<MemoryStatistics> GetStatisticsAsync();
}

public enum MemoryOptions
{
    None = 0,
    Pinned = 1,
    WriteOnly = 2,
    ReadOnly = 4,
    DeviceLocal = 8
}

public class MemoryStatistics
{
    public long TotalAllocated { get; init; }
    public long CurrentUsage { get; init; }
    public long PeakUsage { get; init; }
    public int ActiveBuffers { get; init; }
    public int PooledBuffers { get; init; }
    public double PoolHitRate { get; init; }
}
```

## Kernel Definition and Compilation

### KernelDefinition

Defines a compute kernel for compilation.

```csharp
namespace DotCompute.Abstractions.Kernels;

public class KernelDefinition
{
    public required string Name { get; init; }
    public required string SourceCode { get; init; }
    public required IReadOnlyList<KernelParameter> Parameters { get; init; }
    public ThreadingModel ThreadingModel { get; init; } = ThreadingModel.SingleThread;
    public WorkGroupSize? PreferredWorkGroupSize { get; init; }
    public Dictionary<string, object>? Metadata { get; init; }
}

public class KernelParameter
{
    public required string Name { get; init; }
    public required Type Type { get; init; }
    public ParameterDirection Direction { get; init; } = ParameterDirection.In;
    public bool IsBuffer { get; init; }
    public int? BufferSize { get; init; }
}

public enum ParameterDirection
{
    In,
    Out,
    InOut
}

public enum ThreadingModel
{
    SingleThread,
    MultiThread,
    Vectorized,
    MassivelyParallel
}

public record WorkGroupSize(int X, int Y = 1, int Z = 1);
```

### CompilationOptions

Options for kernel compilation.

```csharp
namespace DotCompute.Abstractions.Kernels;

public class CompilationOptions
{
    public OptimizationLevel OptimizationLevel { get; set; } = OptimizationLevel.Default;
    public bool GenerateDebugInfo { get; set; } = false;
    public Version? TargetArchitecture { get; set; }
    public IReadOnlyList<string>? AdditionalFlags { get; set; }
    public Dictionary<string, string>? Defines { get; set; }
    public TimeSpan CompilationTimeout { get; set; } = TimeSpan.FromMinutes(5);
}

public enum OptimizationLevel
{
    None,
    Default,
    Size,
    Speed,
    Maximum
}
```

### IKernelCompiler

Interface for kernel compilation.

```csharp
namespace DotCompute.Abstractions.Kernels;

public interface IKernelCompiler
{
    ValueTask<ICompiledKernel> CompileAsync(
        KernelDefinition definition,
        CompilationOptions? options = null,
        CancellationToken cancellationToken = default);
        
    ValueTask<bool> CanCompileAsync(KernelDefinition definition);
    Task<string> GetCompilerVersionAsync();
}
```

## Service Registration

### DotCompute Service Extensions

```csharp
namespace DotCompute.Runtime.Extensions;

public static class ServiceCollectionExtensions
{
    // Core services
    public static IServiceCollection AddDotComputeRuntime(this IServiceCollection services);
    public static IServiceCollection AddDotComputeRuntime(this IServiceCollection services, Action<DotComputeOptions> configure);
    
    // Production optimizations
    public static IServiceCollection AddProductionOptimization(this IServiceCollection services);
    public static IServiceCollection AddProductionDebugging(this IServiceCollection services);
    
    // Backend-specific services
    public static IServiceCollection AddCpuBackend(this IServiceCollection services);
    public static IServiceCollection AddCpuBackend(this IServiceCollection services, Action<CpuBackendOptions> configure);
    public static IServiceCollection AddCudaBackend(this IServiceCollection services);
    public static IServiceCollection AddCudaBackend(this IServiceCollection services, Action<CudaBackendOptions> configure);
    
    // Memory management
    public static IServiceCollection AddMemoryPool(this IServiceCollection services);
    public static IServiceCollection AddMemoryPool(this IServiceCollection services, Action<MemoryPoolOptions> configure);
}

public class DotComputeOptions
{
    public bool EnableAutoDiscovery { get; set; } = true;
    public bool EnableCaching { get; set; } = true;
    public bool EnableProfiling { get; set; } = false;
    public LogLevel MinimumLogLevel { get; set; } = LogLevel.Information;
    public TimeSpan InitializationTimeout { get; set; } = TimeSpan.FromMinutes(2);
}
```

## Source Generation

### Kernel Attribute

Marks methods for kernel generation.

```csharp
namespace DotCompute.Generators.Kernel.Attributes;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class KernelAttribute : Attribute
{
    public string? Name { get; set; }
    public ThreadingModel ThreadingModel { get; set; } = ThreadingModel.MassivelyParallel;
    public int WorkGroupSizeX { get; set; } = 0;
    public int WorkGroupSizeY { get; set; } = 0;
    public int WorkGroupSizeZ { get; set; } = 0;
}

// Usage example
[Kernel(Name = "VectorAdd", WorkGroupSizeX = 256)]
public static void VectorAdd(ReadOnlySpan<float> a, ReadOnlySpan<float> b, Span<float> result)
{
    int idx = Kernel.ThreadId.X;
    if (idx < result.Length)
    {
        result[idx] = a[idx] + b[idx];
    }
}
```

### Kernel Context

Provides thread and block information within kernels.

```csharp
namespace DotCompute.Core.Kernels;

public static class Kernel
{
    public static KernelThreadId ThreadId { get; }
    public static KernelBlockId BlockId { get; }
    public static KernelBlockDim BlockDim { get; }
    public static KernelGridDim GridDim { get; }
}

public readonly struct KernelThreadId
{
    public int X { get; }
    public int Y { get; }
    public int Z { get; }
}

public readonly struct KernelBlockId
{
    public int X { get; }
    public int Y { get; }
    public int Z { get; }
}
```

## Debugging and Profiling

### IKernelDebugService

Service for kernel debugging and validation.

```csharp
namespace DotCompute.Abstractions.Debugging;

public interface IKernelDebugService
{
    // Cross-backend validation
    Task<ValidationResult> ValidateAcrossBackendsAsync(string kernelName, object[] args);
    Task<ValidationResult> ValidateDeterminismAsync(string kernelName, object[] args, int iterations = 5);
    
    // Performance analysis
    Task<PerformanceProfile> ProfileKernelAsync(string kernelName, IAccelerator accelerator, object[] args);
    Task<ComparisonResult> CompareBackendPerformanceAsync(string kernelName, object[] args);
    
    // Memory analysis
    Task<MemoryAccessPattern> AnalyzeMemoryAccessAsync(string kernelName, object[] args);
    Task<ResourceUsageReport> AnalyzeResourceUsageAsync(string kernelName, IAccelerator accelerator);
    
    // Debugging utilities
    Task<ExecutionTrace> TraceExecutionAsync(string kernelName, IAccelerator accelerator, object[] args);
    Task<DiagnosticReport> RunDiagnosticsAsync(string kernelName);
}
```

### IKernelProfiler

Service for performance profiling.

```csharp
namespace DotCompute.Abstractions.Profiling;

public interface IKernelProfiler
{
    // Execution profiling
    Task<ExecutionMetrics> ProfileExecutionAsync(string kernelName, IAccelerator accelerator, object[] args);
    Task<ThroughputMetrics> MeasureThroughputAsync(string kernelName, IAccelerator accelerator, object[] args, TimeSpan duration);
    
    // Historical data
    Task<IReadOnlyList<ExecutionMetrics>> GetHistoricalMetricsAsync(string kernelName, TimeSpan period);
    Task<PerformanceTrends> AnalyzeTrendsAsync(string kernelName, TimeSpan period);
    
    // Resource monitoring
    Task<ResourceMetrics> GetResourceMetricsAsync(IAccelerator accelerator);
}

public class ExecutionMetrics
{
    public TimeSpan ExecutionTime { get; init; }
    public TimeSpan CompilationTime { get; init; }
    public TimeSpan TransferTime { get; init; }
    public long MemoryUsed { get; init; }
    public double Throughput { get; init; }
    public int ElementsProcessed { get; init; }
}
```

## Configuration and Options

### Backend Configuration

```csharp
namespace DotCompute.Configuration;

public class CpuBackendOptions
{
    public int MaxThreads { get; set; } = Environment.ProcessorCount;
    public bool EnableSimdOptimizations { get; set; } = true;
    public bool EnableVectorization { get; set; } = true;
    public CpuSchedulingStrategy SchedulingStrategy { get; set; } = CpuSchedulingStrategy.WorkStealing;
}

public class CudaBackendOptions
{
    public int[] DeviceIds { get; set; } = Array.Empty<int>();
    public bool EnablePeerToPeer { get; set; } = true;
    public bool EnableUnifiedMemory { get; set; } = true;
    public CudaMemoryStrategy MemoryStrategy { get; set; } = CudaMemoryStrategy.Pooled;
    public int MaxConcurrentKernels { get; set; } = 4;
}
```

## Exception Types

### DotCompute-Specific Exceptions

```csharp
namespace DotCompute.Exceptions;

// Base exception
public class DotComputeException : Exception
{
    public DotComputeException(string message) : base(message) { }
    public DotComputeException(string message, Exception innerException) : base(message, innerException) { }
}

// Kernel compilation errors
public class KernelCompilationException : DotComputeException
{
    public string KernelName { get; }
    public string CompilerOutput { get; }
    
    public KernelCompilationException(string kernelName, string compilerOutput, string message) 
        : base(message)
    {
        KernelName = kernelName;
        CompilerOutput = compilerOutput;
    }
}

// Execution errors
public class KernelExecutionException : DotComputeException
{
    public string KernelName { get; }
    public IAccelerator Accelerator { get; }
    
    public KernelExecutionException(string kernelName, IAccelerator accelerator, string message) 
        : base(message)
    {
        KernelName = kernelName;
        Accelerator = accelerator;
    }
}

// Memory errors
public class MemoryAllocationException : DotComputeException
{
    public long RequestedSize { get; }
    public long AvailableSize { get; }
    
    public MemoryAllocationException(long requestedSize, long availableSize, string message) 
        : base(message)
    {
        RequestedSize = requestedSize;
        AvailableSize = availableSize;
    }
}

// Backend errors
public class AcceleratorNotAvailableException : DotComputeException
{
    public AcceleratorType RequestedType { get; }
    
    public AcceleratorNotAvailableException(AcceleratorType requestedType, string message) 
        : base(message)
    {
        RequestedType = requestedType;
    }
}
```

---

This API reference provides comprehensive documentation for all public interfaces and classes in DotCompute v0.2.0-alpha. For usage examples and patterns, see the [Examples documentation](Examples.md).