// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using DotCompute.Abstractions;
using CompilationOptions = DotCompute.Abstractions.CompilationOptions;
using ICompiledKernel = DotCompute.Abstractions.ICompiledKernel;
using KernelDefinition = DotCompute.Abstractions.KernelDefinition;

namespace DotCompute.Core;

/// <summary>
/// Adapter that bridges IAccelerator to IComputeDevice interface.
/// </summary>
internal sealed class ComputeDeviceAdapter : IComputeDevice
{
    private readonly IAccelerator _accelerator;
    private readonly DeviceCapabilitiesAdapter _capabilities;
    private readonly DeviceMemoryInfoAdapter _memoryInfo;
    private readonly DeviceMetricsAdapter _metrics;
    private bool _isDisposed;

    public ComputeDeviceAdapter(IAccelerator accelerator)
    {
        _accelerator = accelerator ?? throw new ArgumentNullException(nameof(accelerator));
        _capabilities = new DeviceCapabilitiesAdapter(accelerator);
        _memoryInfo = new DeviceMemoryInfoAdapter(accelerator);
        _metrics = new DeviceMetricsAdapter();
    }

    /// <inheritdoc/>
    public string Id => _accelerator.Name; // Use accelerator name as ID

    /// <inheritdoc/>
    public string Name => _accelerator.Name;

    /// <inheritdoc/>
    public ComputeDeviceType Type => _accelerator.AcceleratorType switch
    {
        AcceleratorType.CPU => ComputeDeviceType.CPU,
        AcceleratorType.Cuda => ComputeDeviceType.GPU,
        AcceleratorType.OpenCL => ComputeDeviceType.GPU,
        AcceleratorType.Vulkan => ComputeDeviceType.GPU,
        _ => ComputeDeviceType.Accelerator
    };

    /// <inheritdoc/>
    public IDeviceCapabilities Capabilities => _capabilities;

    /// <inheritdoc/>
    public DeviceStatus Status => _accelerator.IsAvailable ? DeviceStatus.Available : DeviceStatus.Offline;

    /// <inheritdoc/>
    public IDeviceMemoryInfo MemoryInfo => _memoryInfo;

    /// <inheritdoc/>
    public async ValueTask<ICompiledKernel> CompileKernelAsync(
        KernelDefinition kernel,
        CompilationOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        // For now, assume kernels are pre-compiled for integration testing
        // Real implementation would compile the kernel using the accelerator
        throw new NotSupportedException("Kernel compilation not yet implemented in adapter");
    }

    /// <inheritdoc/>
    public async ValueTask<IDeviceMemory> AllocateMemoryAsync(
        long sizeInBytes,
        Memory.MemoryAccess access,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        // Create device memory adapter
        var buffer = _accelerator.Allocate1D<byte>((int)sizeInBytes);
        return new DeviceMemoryAdapter(buffer, this, access);
    }

    /// <inheritdoc/>
    public ICommandQueue CreateCommandQueue(CommandQueueOptions? options = null)
    {
        ThrowIfDisposed();
        
        return new CommandQueueAdapter(_accelerator, this, options ?? CommandQueueOptions.Default);
    }

    /// <inheritdoc/>
    public async ValueTask SynchronizeAsync(CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        _accelerator.Synchronize();
    }

    /// <inheritdoc/>
    public IDeviceMetrics GetMetrics() => _metrics;

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        if (_isDisposed)
        {
            return;
        }

        // Don't dispose the underlying accelerator as it might be shared
        _isDisposed = true;
    }

    private void ThrowIfDisposed() => ObjectDisposedException.ThrowIf(_isDisposed, nameof(ComputeDeviceAdapter));
}

/// <summary>
/// Adapter for device capabilities.
/// </summary>
internal sealed class DeviceCapabilitiesAdapter : IDeviceCapabilities
{
    private readonly IAccelerator _accelerator;

    public DeviceCapabilitiesAdapter(IAccelerator accelerator)
    {
        _accelerator = accelerator;
    }

    /// <inheritdoc/>
    public Version ComputeCapability => new(1, 0); // Default version

    /// <inheritdoc/>
    public int MaxWorkGroupSize => _accelerator.MaxNumThreadsPerGroup;

    /// <inheritdoc/>
    public int MaxWorkItemDimensions => 3; // Standard 3D work items

    /// <inheritdoc/>
    public long[] MaxWorkItemSizes => new[] { (long)_accelerator.MaxGridSize.X, (long)_accelerator.MaxGridSize.Y, (long)_accelerator.MaxGridSize.Z };

    /// <inheritdoc/>
    public int ComputeUnits => _accelerator.MaxNumThreadsPerMultiprocessor / _accelerator.MaxNumThreadsPerGroup;

    /// <inheritdoc/>
    public int ClockFrequency => 1000; // Default 1GHz

    /// <inheritdoc/>
    public DeviceFeatures SupportedFeatures => DeviceFeatures.None; // Conservative default

    /// <inheritdoc/>
    public DataTypeSupport SupportedDataTypes => DataTypeSupport.Int32 | DataTypeSupport.Float32; // Basic types

    /// <inheritdoc/>
    public bool IsFeatureSupported(DeviceFeature feature) => false; // Conservative default
}

/// <summary>
/// Adapter for device memory info.
/// </summary>
internal sealed class DeviceMemoryInfoAdapter : IDeviceMemoryInfo
{
    private readonly IAccelerator _accelerator;

    public DeviceMemoryInfoAdapter(IAccelerator accelerator)
    {
        _accelerator = accelerator;
    }

    /// <inheritdoc/>
    public long TotalGlobalMemory => (long)_accelerator.MemorySize;

    /// <inheritdoc/>
    public long AvailableGlobalMemory => (long)_accelerator.MemorySize; // Simplified

    /// <inheritdoc/>
    public long LocalMemoryPerWorkGroup => _accelerator.MaxSharedMemoryPerGroup;

    /// <inheritdoc/>
    public double MemoryBandwidth => 100.0; // Default 100 GB/s

    /// <inheritdoc/>
    public ICacheSizes CacheSizes => new CacheSizesAdapter();

    /// <inheritdoc/>
    public long AllocationGranularity => 256; // 256 byte alignment
}

/// <summary>
/// Adapter for cache sizes.
/// </summary>
internal sealed class CacheSizesAdapter : ICacheSizes
{
    /// <inheritdoc/>
    public long L1Size => 32 * 1024; // 32KB

    /// <inheritdoc/>
    public long L2Size => 256 * 1024; // 256KB

    /// <inheritdoc/>
    public long L3Size => 2 * 1024 * 1024; // 2MB

    /// <inheritdoc/>
    public long TextureCacheSize => 48 * 1024; // 48KB

    /// <inheritdoc/>
    public long ConstantCacheSize => 64 * 1024; // 64KB
}

/// <summary>
/// Adapter for device memory.
/// </summary>
internal sealed class DeviceMemoryAdapter : IDeviceMemory
{
    private readonly IMemoryBuffer _buffer;
    private readonly IComputeDevice _device;
    private readonly Memory.MemoryAccess _accessMode;
    private bool _isDisposed;

    public DeviceMemoryAdapter(IMemoryBuffer buffer, IComputeDevice device, Memory.MemoryAccess accessMode)
    {
        _buffer = buffer;
        _device = device;
        _accessMode = accessMode;
    }

    /// <inheritdoc/>
    public long SizeInBytes => _buffer.Length;

    /// <inheritdoc/>
    public IComputeDevice Device => _device;

    /// <inheritdoc/>
    public Memory.MemoryAccess AccessMode => _accessMode;

    /// <inheritdoc/>
    public async ValueTask WriteAsync<T>(ReadOnlyMemory<T> source, long offset = 0, CancellationToken cancellationToken = default) where T : unmanaged
    {
        ThrowIfDisposed();
        
        var sourceSpan = source.Span;
        var byteSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<T, byte>(sourceSpan);
        
        // Copy data to device buffer
        _buffer.CopyFromCPU(byteSpan.ToArray(), (int)offset);
    }

    /// <inheritdoc/>
    public async ValueTask ReadAsync<T>(Memory<T> destination, long offset = 0, CancellationToken cancellationToken = default) where T : unmanaged
    {
        ThrowIfDisposed();
        
        var data = _buffer.GetAsArray1D();
        var byteMemory = destination.Cast<T, byte>();
        
        if (byteMemory.Length > data.Length - offset)
        {
            throw new ArgumentException("Destination buffer is too large");
        }
        
        data.AsSpan((int)offset, byteMemory.Length).CopyTo(byteMemory.Span);
    }

    /// <inheritdoc/>
    public async ValueTask FillAsync<T>(T pattern, long offset = 0, long? count = null, CancellationToken cancellationToken = default) where T : unmanaged
    {
        ThrowIfDisposed();
        
        var patternBytes = System.Runtime.InteropServices.MemoryMarshal.AsBytes(new ReadOnlySpan<T>([pattern]));
        var fillCount = (int)(count ?? (SizeInBytes - offset) / patternBytes.Length);
        
        var fillData = new byte[fillCount * patternBytes.Length];
        for (int i = 0; i < fillCount; i++)
        {
            patternBytes.CopyTo(fillData.AsSpan(i * patternBytes.Length));
        }
        
        _buffer.CopyFromCPU(fillData, (int)offset);
    }

    /// <inheritdoc/>
    public async ValueTask CopyToAsync(IDeviceMemory destination, long sourceOffset = 0, long destinationOffset = 0, long? sizeInBytes = null, CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        var copySize = (int)(sizeInBytes ?? (SizeInBytes - sourceOffset));
        var sourceData = _buffer.GetAsArray1D();
        var sourceSpan = sourceData.AsSpan((int)sourceOffset, copySize);
        
        // Copy to destination
        await destination.WriteAsync<byte>(sourceSpan.ToArray(), destinationOffset, cancellationToken);
    }

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        if (_isDisposed)
        {
            return;
        }

        _buffer?.Dispose();
        _isDisposed = true;
    }

    private void ThrowIfDisposed() => ObjectDisposedException.ThrowIf(_isDisposed, nameof(DeviceMemoryAdapter));
}

/// <summary>
/// Adapter for command queue.
/// </summary>
internal sealed class CommandQueueAdapter : ICommandQueue
{
    private readonly IAccelerator _accelerator;
    private readonly IComputeDevice _device;
    private readonly CommandQueueOptions _options;
    private bool _isDisposed;

    public CommandQueueAdapter(IAccelerator accelerator, IComputeDevice device, CommandQueueOptions options)
    {
        _accelerator = accelerator;
        _device = device;
        _options = options;
    }

    /// <inheritdoc/>
    public string Id { get; } = Guid.NewGuid().ToString();

    /// <inheritdoc/>
    public IComputeDevice Device => _device;

    /// <inheritdoc/>
    public async ValueTask EnqueueKernelAsync(ICompiledKernel kernel, KernelExecutionContext context, CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        // For integration testing, we'll simulate kernel execution
        // Real implementation would enqueue actual kernel
        await Task.Delay(10, cancellationToken); // Simulate work
    }

    /// <inheritdoc/>
    public async ValueTask EnqueueCopyAsync(IDeviceMemory source, IDeviceMemory destination, long sourceOffset = 0, long destinationOffset = 0, long? sizeInBytes = null, CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        await source.CopyToAsync(destination, sourceOffset, destinationOffset, sizeInBytes, cancellationToken);
    }

    /// <inheritdoc/>
    public async ValueTask EnqueueBarrierAsync(CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        _accelerator.Synchronize();
    }

    /// <inheritdoc/>
    public async ValueTask FinishAsync(CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        _accelerator.Synchronize();
    }

    /// <inheritdoc/>
    public async ValueTask FlushAsync(CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        // Flush is typically a no-op for immediate execution
    }

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        if (_isDisposed)
        {
            return;
        }

        _isDisposed = true;
    }

    private void ThrowIfDisposed() => ObjectDisposedException.ThrowIf(_isDisposed, nameof(CommandQueueAdapter));
}

/// <summary>
/// Adapter for device metrics.
/// </summary>
internal sealed class DeviceMetricsAdapter : IDeviceMetrics
{
    private long _kernelExecutionCount;
    private TimeSpan _totalComputeTime;
    private readonly MemoryTransferStatsAdapter _transferStats = new();

    /// <inheritdoc/>
    public double Utilization => 0.5; // 50% default

    /// <inheritdoc/>
    public double MemoryUsage => 0.3; // 30% default

    /// <inheritdoc/>
    public double? Temperature => 45.0; // 45Â°C default

    /// <inheritdoc/>
    public double? PowerConsumption => 75.0; // 75W default

    /// <inheritdoc/>
    public long KernelExecutionCount => _kernelExecutionCount;

    /// <inheritdoc/>
    public TimeSpan TotalComputeTime => _totalComputeTime;

    /// <inheritdoc/>
    public TimeSpan AverageKernelTime => _kernelExecutionCount > 0 
        ? TimeSpan.FromTicks(_totalComputeTime.Ticks / _kernelExecutionCount)
        : TimeSpan.Zero;

    /// <inheritdoc/>
    public IMemoryTransferStats TransferStats => _transferStats;

    public void RecordKernelExecution(TimeSpan duration)
    {
        _kernelExecutionCount++;
        _totalComputeTime = _totalComputeTime.Add(duration);
    }
}

/// <summary>
/// Adapter for memory transfer stats.
/// </summary>
internal sealed class MemoryTransferStatsAdapter : IMemoryTransferStats
{
    private long _bytesToDevice;
    private long _bytesFromDevice;
    private TimeSpan _totalTransferTime;

    /// <inheritdoc/>
    public long BytesToDevice => _bytesToDevice;

    /// <inheritdoc/>
    public long BytesFromDevice => _bytesFromDevice;

    /// <inheritdoc/>
    public double AverageRateToDevice => _totalTransferTime.TotalSeconds > 0
        ? (_bytesToDevice / (1024.0 * 1024.0 * 1024.0)) / _totalTransferTime.TotalSeconds
        : 0;

    /// <inheritdoc/>
    public double AverageRateFromDevice => _totalTransferTime.TotalSeconds > 0
        ? (_bytesFromDevice / (1024.0 * 1024.0 * 1024.0)) / _totalTransferTime.TotalSeconds
        : 0;

    /// <inheritdoc/>
    public TimeSpan TotalTransferTime => _totalTransferTime;

    public void RecordTransfer(long bytes, bool toDevice, TimeSpan duration)
    {
        if (toDevice)
        {
            _bytesToDevice += bytes;
        }
        else
        {
            _bytesFromDevice += bytes;
        }
        _totalTransferTime = _totalTransferTime.Add(duration);
    }
}