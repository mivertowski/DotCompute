// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Text;
using DotCompute.Generators.Models.Kernel;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DotCompute.Generators.Kernel.Generation;

/// <summary>
/// Coordinates the generation of Ring Kernel source code across different backends.
/// Ring Kernels are persistent kernels with message-passing capabilities designed for:
/// - Real-time data processing pipelines
/// - Distributed computing with inter-kernel communication
/// - Stream processing with backpressure handling
/// - Event-driven compute workflows
/// </summary>
/// <remarks>
/// This builder generates:
/// - Lifecycle wrapper methods (Launch, Activate, Deactivate, Terminate)
/// - Message queue creation and management
/// - Backend-specific implementations (CPU fallback, CUDA, OpenCL, Metal)
/// - Integration with IRingKernelRuntime interface
/// - Wrapper classes for easy usage from C# code
/// </remarks>
public sealed class RingKernelCodeBuilder
{
    /// <summary>
    /// Builds all Ring Kernel source code files for the given Ring Kernel methods.
    /// </summary>
    /// <param name="ringKernelMethods">The Ring Kernel methods to generate code for.</param>
    /// <param name="compilation">The compilation context.</param>
    /// <param name="context">The source production context.</param>
    /// <remarks>
    /// This method coordinates the entire Ring Kernel code generation process:
    /// 1. Validates all Ring Kernel methods
    /// 2. Generates Ring Kernel registry
    /// 3. Generates backend-specific runtime implementations
    /// 4. Generates lifecycle wrapper classes
    /// 5. Generates message queue management code
    /// </remarks>
    public static void BuildRingKernelSources(
        IEnumerable<RingKernelMethodInfo> ringKernelMethods,
        Compilation compilation,
        SourceProductionContext context)
    {
        var methodList = ringKernelMethods.ToList();

        if (methodList.Count == 0)
        {
            return;
        }

        // Generate Ring Kernel registry
        GenerateRingKernelRegistry(methodList, context);

        // Generate wrapper classes for each Ring Kernel
        foreach (var method in methodList)
        {
            GenerateRingKernelWrapper(method, compilation, context);
        }

        // Generate backend runtime factories
        GenerateRuntimeFactories(methodList, context);
    }

    /// <summary>
    /// Generates the Ring Kernel registry containing all Ring Kernel metadata.
    /// </summary>
    /// <param name="ringKernelMethods">The Ring Kernel methods to include in the registry.</param>
    /// <param name="context">The source production context.</param>
    private static void GenerateRingKernelRegistry(
        List<RingKernelMethodInfo> ringKernelMethods,
        SourceProductionContext context)
    {
        var source = new StringBuilder();
        _ = source.AppendLine("// <auto-generated/>");
        _ = source.AppendLine("using System;");
        _ = source.AppendLine("using System.Collections.Generic;");
        _ = source.AppendLine("using System.Linq;");
        _ = source.AppendLine();

        _ = source.AppendLine("namespace DotCompute.Generated");
        _ = source.AppendLine("{");
        _ = source.AppendLine("    /// <summary>");
        _ = source.AppendLine("    /// Registry of all generated Ring Kernels for runtime discovery.");
        _ = source.AppendLine("    /// </summary>");
        _ = source.AppendLine("    public static class RingKernelRegistry");
        _ = source.AppendLine("    {");
        _ = source.AppendLine("        private static readonly Dictionary<string, RingKernelMetadata> _ringKernels = new()");
        _ = source.AppendLine("        {");

        // Generate Ring Kernel registrations
        foreach (var method in ringKernelMethods)
        {
            var kernelId = !string.IsNullOrWhiteSpace(method.KernelId)
                ? method.KernelId
                : $"{method.ContainingType}.{method.Name}";

            var displayNamespace = string.IsNullOrWhiteSpace(method.Namespace) ? "<global namespace>" : method.Namespace;

            _ = source.AppendLine($"            {{ \"{kernelId}\", new RingKernelMetadata");
            _ = source.AppendLine("            {");
            _ = source.AppendLine($"                KernelId = \"{kernelId}\",");
            _ = source.AppendLine($"                Name = \"{method.Name}\",");
            _ = source.AppendLine($"                ContainingType = \"{method.ContainingType}\",");
            _ = source.AppendLine($"                Namespace = \"{displayNamespace}\",");
            _ = source.AppendLine($"                Capacity = {method.Capacity},");
            _ = source.AppendLine($"                InputQueueSize = {method.InputQueueSize},");
            _ = source.AppendLine($"                OutputQueueSize = {method.OutputQueueSize},");
            _ = source.AppendLine($"                Mode = \"{method.Mode}\",");
            _ = source.AppendLine($"                MessagingStrategy = \"{method.MessagingStrategy}\",");
            _ = source.AppendLine($"                Domain = \"{method.Domain}\",");
            _ = source.AppendLine($"                Backends = new[] {{ {string.Join(", ", method.Backends.Select(b => $"\"{b}\""))} }},");
            _ = source.AppendLine($"                ParameterCount = {method.Parameters.Count},");
            _ = source.AppendLine($"                UseSharedMemory = {(method.UseSharedMemory ? "true" : "false")},");
            _ = source.AppendLine($"                SharedMemorySize = {method.SharedMemorySize},");

            // Grid dimensions
            if (method.GridDimensions != null && method.GridDimensions.Count > 0)
            {
                var gridDims = string.Join(", ", method.GridDimensions);
                _ = source.AppendLine($"                GridDimensions = new[] {{ {gridDims} }},");
            }
            else
            {
                _ = source.AppendLine("                GridDimensions = null,");
            }

            // Block dimensions
            if (method.BlockDimensions != null && method.BlockDimensions.Count > 0)
            {
                var blockDims = string.Join(", ", method.BlockDimensions);
                _ = source.AppendLine($"                BlockDimensions = new[] {{ {blockDims} }},");
            }
            else
            {
                _ = source.AppendLine("                BlockDimensions = null,");
            }

            _ = source.AppendLine($"                IsParallel = {(method.IsParallel ? "true" : "false")},");
            _ = source.AppendLine($"                VectorSize = {method.VectorSize}");
            _ = source.AppendLine("            }},");
        }

        _ = source.AppendLine("        };");
        _ = source.AppendLine();

        // Generate registry methods
        _ = source.AppendLine("        public static IReadOnlyList<string> GetAvailableRingKernels()");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            return _ringKernels.Keys.ToList();");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        _ = source.AppendLine("        public static RingKernelMetadata? GetRingKernelInfo(string kernelId)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            return _ringKernels.TryGetValue(kernelId, out var metadata) ? metadata : null;");
        _ = source.AppendLine("        }");
        _ = source.AppendLine("    }");
        _ = source.AppendLine();

        // Generate RingKernelMetadata class
        _ = source.AppendLine("    public sealed class RingKernelMetadata");
        _ = source.AppendLine("    {");
        _ = source.AppendLine("        public string KernelId { get; init; } = string.Empty;");
        _ = source.AppendLine("        public string Name { get; init; } = string.Empty;");
        _ = source.AppendLine("        public string ContainingType { get; init; } = string.Empty;");
        _ = source.AppendLine("        public string Namespace { get; init; } = string.Empty;");
        _ = source.AppendLine("        public int Capacity { get; init; }");
        _ = source.AppendLine("        public int InputQueueSize { get; init; }");
        _ = source.AppendLine("        public int OutputQueueSize { get; init; }");
        _ = source.AppendLine("        public string Mode { get; init; } = string.Empty;");
        _ = source.AppendLine("        public string MessagingStrategy { get; init; } = string.Empty;");
        _ = source.AppendLine("        public string Domain { get; init; } = string.Empty;");
        _ = source.AppendLine("        public string[] Backends { get; init; } = Array.Empty<string>();");
        _ = source.AppendLine("        public int ParameterCount { get; init; }");
        _ = source.AppendLine("        public bool UseSharedMemory { get; init; }");
        _ = source.AppendLine("        public int SharedMemorySize { get; init; }");
        _ = source.AppendLine("        public int[]? GridDimensions { get; init; }");
        _ = source.AppendLine("        public int[]? BlockDimensions { get; init; }");
        _ = source.AppendLine("        public bool IsParallel { get; init; }");
        _ = source.AppendLine("        public int VectorSize { get; init; }");
        _ = source.AppendLine("    }");
        _ = source.AppendLine("}");

        context.AddSource("RingKernelRegistry.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// Generates a wrapper class for a Ring Kernel with lifecycle management.
    /// </summary>
    /// <param name="method">The Ring Kernel method to generate a wrapper for.</param>
    /// <param name="compilation">The compilation context.</param>
    /// <param name="context">The source production context.</param>
    private static void GenerateRingKernelWrapper(
        RingKernelMethodInfo method,
        Compilation compilation,
        SourceProductionContext context)
    {
        var source = new StringBuilder();
        _ = source.AppendLine("// <auto-generated/>");
        _ = source.AppendLine("#nullable enable");
        _ = source.AppendLine("using System;");
        _ = source.AppendLine("using System.Threading;");
        _ = source.AppendLine("using System.Threading.Tasks;");
        _ = source.AppendLine("using DotCompute.Abstractions.RingKernels;");
        _ = source.AppendLine();

        // Handle global namespace case
        var namespaceName = string.IsNullOrWhiteSpace(method.Namespace)
            ? "Generated"
            : $"{method.Namespace}.Generated";
        _ = source.AppendLine($"namespace {namespaceName}");
        _ = source.AppendLine("{");
        _ = source.AppendLine($"    /// <summary>");
        _ = source.AppendLine($"    /// Wrapper for Ring Kernel '{method.Name}' with lifecycle management.");
        _ = source.AppendLine($"    /// KernelId: {method.KernelId}");
        _ = source.AppendLine($"    /// Mode: {method.Mode}");
        _ = source.AppendLine($"    /// Messaging: {method.MessagingStrategy}");
        _ = source.AppendLine($"    /// </summary>");
        _ = source.AppendLine($"    public sealed class {method.Name}RingKernelWrapper : IDisposable, IAsyncDisposable");
        _ = source.AppendLine("    {");
        _ = source.AppendLine("        private readonly IRingKernelRuntime _runtime;");
        _ = source.AppendLine($"        private readonly string _kernelId = \"{method.KernelId}\";");
        _ = source.AppendLine("        private bool _isLaunched;");
        _ = source.AppendLine("        private bool _isActive;");
        _ = source.AppendLine("        private bool _disposed;");
        _ = source.AppendLine();

        // Constructor
        _ = source.AppendLine($"        public {method.Name}RingKernelWrapper(IRingKernelRuntime runtime)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            _runtime = runtime ?? throw new ArgumentNullException(nameof(runtime));");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // LaunchAsync method
        _ = source.AppendLine("        /// <summary>");
        _ = source.AppendLine("        /// Launches the Ring Kernel with specified dimensions.");
        _ = source.AppendLine("        /// </summary>");
        _ = source.AppendLine("        public async Task LaunchAsync(int gridSize = 1, int blockSize = 1, CancellationToken cancellationToken = default)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            ObjectDisposedException.ThrowIf(_disposed, this);");
        _ = source.AppendLine("            if (_isLaunched) throw new InvalidOperationException(\"Ring Kernel is already launched.\");");
        _ = source.AppendLine("            await _runtime.LaunchAsync(_kernelId, gridSize, blockSize, cancellationToken).ConfigureAwait(false);");
        _ = source.AppendLine("            _isLaunched = true;");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // ActivateAsync method
        _ = source.AppendLine("        /// <summary>");
        _ = source.AppendLine("        /// Activates the Ring Kernel to start processing messages.");
        _ = source.AppendLine("        /// </summary>");
        _ = source.AppendLine("        public async Task ActivateAsync(CancellationToken cancellationToken = default)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            ObjectDisposedException.ThrowIf(_disposed, this);");
        _ = source.AppendLine("            if (!_isLaunched) throw new InvalidOperationException(\"Ring Kernel must be launched before activation.\");");
        _ = source.AppendLine("            if (_isActive) throw new InvalidOperationException(\"Ring Kernel is already active.\");");
        _ = source.AppendLine("            await _runtime.ActivateAsync(_kernelId, cancellationToken).ConfigureAwait(false);");
        _ = source.AppendLine("            _isActive = true;");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // DeactivateAsync method
        _ = source.AppendLine("        /// <summary>");
        _ = source.AppendLine("        /// Deactivates the Ring Kernel to pause message processing.");
        _ = source.AppendLine("        /// </summary>");
        _ = source.AppendLine("        public async Task DeactivateAsync(CancellationToken cancellationToken = default)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            ObjectDisposedException.ThrowIf(_disposed, this);");
        _ = source.AppendLine("            if (!_isActive) return; // Already deactivated");
        _ = source.AppendLine("            await _runtime.DeactivateAsync(_kernelId, cancellationToken).ConfigureAwait(false);");
        _ = source.AppendLine("            _isActive = false;");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // TerminateAsync method
        _ = source.AppendLine("        /// <summary>");
        _ = source.AppendLine("        /// Terminates the Ring Kernel and releases all resources.");
        _ = source.AppendLine("        /// </summary>");
        _ = source.AppendLine("        public async Task TerminateAsync(CancellationToken cancellationToken = default)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            if (!_isLaunched) return; // Not launched");
        _ = source.AppendLine("            if (_isActive)");
        _ = source.AppendLine("            {");
        _ = source.AppendLine("                await DeactivateAsync(cancellationToken).ConfigureAwait(false);");
        _ = source.AppendLine("            }");
        _ = source.AppendLine("            await _runtime.TerminateAsync(_kernelId, cancellationToken).ConfigureAwait(false);");
        _ = source.AppendLine("            _isLaunched = false;");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // GetStatusAsync method
        _ = source.AppendLine("        /// <summary>");
        _ = source.AppendLine("        /// Gets the current status of the Ring Kernel.");
        _ = source.AppendLine("        /// </summary>");
        _ = source.AppendLine("        public async Task<RingKernelStatus> GetStatusAsync(CancellationToken cancellationToken = default)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            ObjectDisposedException.ThrowIf(_disposed, this);");
        _ = source.AppendLine("            return await _runtime.GetStatusAsync(_kernelId, cancellationToken).ConfigureAwait(false);");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // GetMetricsAsync method
        _ = source.AppendLine("        /// <summary>");
        _ = source.AppendLine("        /// Gets performance metrics for the Ring Kernel.");
        _ = source.AppendLine("        /// </summary>");
        _ = source.AppendLine("        public async Task<RingKernelMetrics> GetMetricsAsync(CancellationToken cancellationToken = default)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            ObjectDisposedException.ThrowIf(_disposed, this);");
        _ = source.AppendLine("            return await _runtime.GetMetricsAsync(_kernelId, cancellationToken).ConfigureAwait(false);");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // Dispose methods
        _ = source.AppendLine("        public void Dispose()");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            if (_disposed) return;");
        _ = source.AppendLine("            TerminateAsync().GetAwaiter().GetResult();");
        _ = source.AppendLine("            _disposed = true;");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        _ = source.AppendLine("        public async ValueTask DisposeAsync()");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            if (_disposed) return;");
        _ = source.AppendLine("            await TerminateAsync().ConfigureAwait(false);");
        _ = source.AppendLine("            _disposed = true;");
        _ = source.AppendLine("        }");
        _ = source.AppendLine("    }");
        _ = source.AppendLine("}");

        var fileName = $"{SanitizeFileName(method.ContainingType)}_{method.Name}_RingKernelWrapper.g.cs";
        context.AddSource(fileName, SourceText.From(source.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// Generates runtime factory methods for creating backend-specific Ring Kernel runtimes.
    /// </summary>
    /// <param name="ringKernelMethods">The Ring Kernel methods to generate factories for.</param>
    /// <param name="context">The source production context.</param>
    private static void GenerateRuntimeFactories(
        List<RingKernelMethodInfo> ringKernelMethods,
        SourceProductionContext context)
    {
        var source = new StringBuilder();
        _ = source.AppendLine("// <auto-generated/>");
        _ = source.AppendLine("#nullable enable");
        _ = source.AppendLine("using System;");
        _ = source.AppendLine("using DotCompute.Abstractions.RingKernels;");
        _ = source.AppendLine("using Microsoft.Extensions.Logging;");
        _ = source.AppendLine();

        _ = source.AppendLine("namespace DotCompute.Generated");
        _ = source.AppendLine("{");
        _ = source.AppendLine("    /// <summary>");
        _ = source.AppendLine("    /// Factory for creating backend-specific Ring Kernel runtimes.");
        _ = source.AppendLine("    /// </summary>");
        _ = source.AppendLine("    public static class RingKernelRuntimeFactory");
        _ = source.AppendLine("    {");
        _ = source.AppendLine("        /// <summary>");
        _ = source.AppendLine("        /// Creates an appropriate Ring Kernel runtime for the specified backend.");
        _ = source.AppendLine("        /// </summary>");
        _ = source.AppendLine("        public static IRingKernelRuntime CreateRuntime(string backend, ILoggerFactory? loggerFactory = null)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            return backend.ToUpperInvariant() switch");
        _ = source.AppendLine("            {");
        _ = source.AppendLine("                \"CPU\" => CreateCpuRuntime(loggerFactory),");
        _ = source.AppendLine("                \"CUDA\" => CreateCudaRuntime(loggerFactory),");
        _ = source.AppendLine("                \"OPENCL\" => CreateOpenCLRuntime(loggerFactory),");
        _ = source.AppendLine("                \"METAL\" => CreateMetalRuntime(loggerFactory),");
        _ = source.AppendLine("                _ => throw new NotSupportedException($\"Backend '{backend}' is not supported for Ring Kernels.\")");
        _ = source.AppendLine("            };");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // CPU runtime factory
        _ = source.AppendLine("        private static IRingKernelRuntime CreateCpuRuntime(ILoggerFactory? loggerFactory)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            var logger = loggerFactory?.CreateLogger(\"DotCompute.CPU.RingKernel\");");
        _ = source.AppendLine("            return new DotCompute.Backends.CPU.RingKernels.CpuRingKernelRuntime(logger!);");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // CUDA runtime factory
        _ = source.AppendLine("        private static IRingKernelRuntime CreateCudaRuntime(ILoggerFactory? loggerFactory)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            var runtimeLogger = loggerFactory?.CreateLogger<DotCompute.Backends.CUDA.RingKernels.CudaRingKernelRuntime>();");
        _ = source.AppendLine("            var compilerLogger = loggerFactory?.CreateLogger<DotCompute.Backends.CUDA.RingKernels.CudaRingKernelCompiler>();");
        _ = source.AppendLine("            var compiler = new DotCompute.Backends.CUDA.RingKernels.CudaRingKernelCompiler(compilerLogger!);");
        _ = source.AppendLine("            return new DotCompute.Backends.CUDA.RingKernels.CudaRingKernelRuntime(runtimeLogger!, compiler);");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // OpenCL runtime factory (full implementation)
        _ = source.AppendLine("        private static IRingKernelRuntime CreateOpenCLRuntime(ILoggerFactory? loggerFactory)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            // Create OpenCL device manager and factory");
        _ = source.AppendLine("            var deviceManagerLogger = loggerFactory?.CreateLogger<DotCompute.Backends.OpenCL.OpenCLDeviceManager>();");
        _ = source.AppendLine("            var deviceManager = new DotCompute.Backends.OpenCL.OpenCLDeviceManager(deviceManagerLogger!);");
        _ = source.AppendLine("            ");
        _ = source.AppendLine("            var factoryLogger = loggerFactory?.CreateLogger<DotCompute.Backends.OpenCL.Factory.OpenCLAcceleratorFactory>();");
        _ = source.AppendLine("            var factory = new DotCompute.Backends.OpenCL.Factory.OpenCLAcceleratorFactory(factoryLogger!, deviceManager);");
        _ = source.AppendLine("            ");
        _ = source.AppendLine("            // Get first available device");
        _ = source.AppendLine("            var devices = factory.GetAvailableDevices();");
        _ = source.AppendLine("            var device = devices.FirstOrDefault() ?? throw new InvalidOperationException(\"No OpenCL devices available\");");
        _ = source.AppendLine("            ");
        _ = source.AppendLine("            // Create OpenCL context");
        _ = source.AppendLine("            var contextLogger = loggerFactory?.CreateLogger<DotCompute.Backends.OpenCL.OpenCLContext>();");
        _ = source.AppendLine("            var context = new DotCompute.Backends.OpenCL.OpenCLContext(device, contextLogger!);");
        _ = source.AppendLine("            ");
        _ = source.AppendLine("            // Create compiler and runtime");
        _ = source.AppendLine("            var compilerLogger = loggerFactory?.CreateLogger<DotCompute.Backends.OpenCL.RingKernels.OpenCLRingKernelCompiler>();");
        _ = source.AppendLine("            var compiler = new DotCompute.Backends.OpenCL.RingKernels.OpenCLRingKernelCompiler(compilerLogger!);");
        _ = source.AppendLine("            ");
        _ = source.AppendLine("            var runtimeLogger = loggerFactory?.CreateLogger<DotCompute.Backends.OpenCL.RingKernels.OpenCLRingKernelRuntime>();");
        _ = source.AppendLine("            return new DotCompute.Backends.OpenCL.RingKernels.OpenCLRingKernelRuntime(context, runtimeLogger!, compiler);");
        _ = source.AppendLine("        }");
        _ = source.AppendLine();

        // Metal runtime factory
        _ = source.AppendLine("        private static IRingKernelRuntime CreateMetalRuntime(ILoggerFactory? loggerFactory)");
        _ = source.AppendLine("        {");
        _ = source.AppendLine("            var runtimeLogger = loggerFactory?.CreateLogger<DotCompute.Backends.Metal.RingKernels.MetalRingKernelRuntime>();");
        _ = source.AppendLine("            var compilerLogger = loggerFactory?.CreateLogger<DotCompute.Backends.Metal.RingKernels.MetalRingKernelCompiler>();");
        _ = source.AppendLine("            var compiler = new DotCompute.Backends.Metal.RingKernels.MetalRingKernelCompiler(compilerLogger!);");
        _ = source.AppendLine("            return new DotCompute.Backends.Metal.RingKernels.MetalRingKernelRuntime(runtimeLogger!, compiler);");
        _ = source.AppendLine("        }");
        _ = source.AppendLine("    }");
        _ = source.AppendLine("}");

        context.AddSource("RingKernelRuntimeFactory.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static string SanitizeFileName(string input) => input.Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace("`", "_");
}
