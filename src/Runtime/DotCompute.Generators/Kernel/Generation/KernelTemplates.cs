// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Collections.Generic;
using System.Text;
using DotCompute.Generators.Models.Kernel;

namespace DotCompute.Generators.Kernel.Generation;

/// <summary>
/// Provides reusable code templates for kernel generation across different backends.
/// Contains standardized templates that ensure consistent code generation and
/// reduce duplication across different generation components.
/// </summary>
/// <remarks>
/// This class centralizes all code templates used in kernel generation:
/// - File headers and copyright notices
/// - Using statements and imports
/// - Class and method declarations
/// - Backend-specific code patterns
/// - Documentation templates
/// </remarks>
public sealed class KernelTemplates
{
    /// <summary>
    /// Gets the standard file header template with copyright and auto-generated notice.
    /// </summary>
    /// <param name="description">A description of what the file contains.</param>
    /// <returns>The formatted file header.</returns>
    public static string GetFileHeader(string description = "Generated kernel code")
    {
        return @"// <auto-generated/>
// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.
// " + description + @"

";
    }

    /// <summary>
    /// Gets the standard using statements for kernel wrapper classes.
    /// </summary>
    /// <returns>The formatted using statements.</returns>
    public static string GetWrapperUsingStatements()
    {
        return @"using System;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using DotCompute.Abstractions;
using DotCompute.Core.Memory;
using DotCompute.Runtime.Services;
using DotCompute.Generated;

";
    }

    /// <summary>
    /// Gets the standard using statements for registry classes.
    /// </summary>
    /// <returns>The formatted using statements.</returns>
    public static string GetRegistryUsingStatements()
    {
        return @"using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

";
    }

    /// <summary>
    /// Gets the standard using statements for CPU implementation classes.
    /// </summary>
    /// <returns>The formatted using statements.</returns>
    public static string GetCpuImplementationUsingStatements()
    {
        return @"using System;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using System.Threading.Tasks;
using System.Collections.Concurrent;

";
    }

    /// <summary>
    /// Gets the class declaration template for kernel executors.
    /// </summary>
    /// <param name="className">The name of the class.</param>
    /// <param name="kernelName">The name of the kernel.</param>
    /// <returns>The formatted class declaration with documentation.</returns>
    public static string GetExecutorClassDeclaration(string className, string kernelName)
    {
        return $@"    /// <summary>
    /// Unified cross-backend kernel executor for {kernelName}.
    /// Automatically selects the best available backend and handles memory marshaling.
    /// </summary>
    /// <remarks>
    /// This class provides high-level APIs for executing kernels across different
    /// compute backends while abstracting the complexities of backend selection,
    /// memory management, and parameter marshaling.
    /// </remarks>
    public static class {className}
    {{";
    }

    /// <summary>
    /// Gets the method declaration template for async execution methods.
    /// </summary>
    /// <param name="methodName">The name of the method.</param>
    /// <param name="parameters">The method parameters.</param>
    /// <returns>The formatted method declaration with documentation.</returns>
    public static string GetAsyncExecutionMethodDeclaration(string methodName, string parameters)
    {
        return $@"        /// <summary>
        /// Executes the {methodName} kernel using the DotCompute runtime orchestrator.
        /// Automatically selects the optimal backend and handles all marshaling.
        /// </summary>
        public static async Task ExecuteAsync({parameters}, IServiceProvider? serviceProvider = null)
        {{";
    }

    /// <summary>
    /// Gets the template for backend availability checking.
    /// </summary>
    /// <returns>The formatted backend availability check method.</returns>
    public static string GetBackendAvailabilityTemplate()
    {
        return @"        private static bool IsBackendAvailable(AcceleratorType type)
        {
            return type switch
            {
                AcceleratorType.CPU => true,
                AcceleratorType.CUDA => DotCompute.Backends.CUDA.Factory.CudaAcceleratorFactory.IsCudaAvailable(),
                AcceleratorType.Metal => System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.OSX),
                _ => false
            };
        }";
    }

    /// <summary>
    /// Gets the template for accelerator factory methods.
    /// </summary>
    /// <returns>The formatted accelerator factory methods.</returns>
    public static string GetAcceleratorFactoryTemplate()
    {
        return @"        private static IAccelerator GetAccelerator(AcceleratorType type)
        {
            return type switch
            {
                AcceleratorType.CPU => new DotCompute.Backends.CPU.CpuAccelerator(),
                AcceleratorType.CUDA => GetOrCreateCudaAccelerator(),
                _ => throw new NotSupportedException($""Backend {type} not supported"")
            };
        }

        private static readonly Lazy<IAccelerator> _cudaAccelerator = new(() =>
        {
            var factory = new DotCompute.Backends.CUDA.Factory.CudaAcceleratorFactory();
            return factory.CreateProductionAccelerator(0);
        });

        private static IAccelerator GetOrCreateCudaAccelerator() => _cudaAccelerator.Value;";
    }

    /// <summary>
    /// Gets the template for CPU SIMD method implementation.
    /// </summary>
    /// <param name="methodName">The name of the method.</param>
    /// <param name="parameters">The method parameters.</param>
    /// <returns>The formatted SIMD method template.</returns>
    public static string GetCpuSimdMethodTemplate(string methodName, string parameters)
    {
        return $@"        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void ExecuteSIMD({parameters})
        {{
            // SIMD vectorized implementation
            // Vector processing with automatic fallback to scalar for remainder elements
            var vectorSize = Vector256<float>.Count;
            var vectorCount = length / vectorSize;

            // Process vectorized elements
            for (int i = 0; i < vectorCount; i++)
            {{
                // Vectorized operation implementation
                var vectorIndex = i * vectorSize;
                // Load, process, and store vector elements
            }}

            // Process remaining scalar elements
            for (int i = vectorCount * vectorSize; i < length; i++)
            {{
                // Scalar fallback implementation
            }}
        }}";
    }

    /// <summary>
    /// Gets the template for CPU parallel method implementation.
    /// </summary>
    /// <param name="methodName">The name of the method.</param>
    /// <param name="parameters">The method parameters.</param>
    /// <returns>The formatted parallel method template.</returns>
    public static string GetCpuParallelMethodTemplate(string methodName, string parameters)
    {
        return $@"        public static unsafe void ExecuteParallel({parameters})
        {{
            // Parallel execution with work-stealing partitioner
            var partitioner = Partitioner.Create(0, length, true);
            Parallel.ForEach(partitioner, range =>
            {{
                // Process range.Item1 to range.Item2
                for (int i = range.Item1; i < range.Item2; i++)
                {{
                    // Parallel processing implementation
                }}
            }});
        }}";
    }

    /// <summary>
    /// Gets the CUDA kernel template.
    /// </summary>
    /// <param name="kernelName">The name of the kernel.</param>
    /// <param name="parameters">The kernel parameters.</param>
    /// <returns>The formatted CUDA kernel template.</returns>
    public static string GetCudaKernelTemplate(string kernelName, string parameters)
    {
        return $@"// CUDA kernel implementation
#include <cuda_runtime.h>
#include <device_launch_parameters.h>
#include <cstdint>

extern ""C"" __global__ void {kernelName}_cuda_kernel(
{parameters}
    , const uint32_t length,
    const uint32_t stride = 1)
{{
    const uint32_t idx = (blockIdx.x * blockDim.x + threadIdx.x) * stride;
    const uint32_t gridSize = blockDim.x * gridDim.x * stride;

    // Grid-stride loop for better GPU utilization
    for (uint32_t i = idx; i < length; i += gridSize) {{
        // Kernel operation implementation
        if (i < length) {{
            // Process element at index i
        }}
    }}
}}

// Host wrapper function
extern ""C"" cudaError_t launch_{kernelName}_cuda(
    void** devicePtrs,
    const uint32_t length,
    const uint32_t blockSize,
    const uint32_t gridSize,
    const uint32_t stride,
    cudaStream_t stream)
{{
    // Parameter validation
    if (!devicePtrs || length == 0 || blockSize == 0 || gridSize == 0) {{
        return cudaErrorInvalidValue;
    }}

    // Launch kernel with configuration
    {kernelName}_cuda_kernel<<<gridSize, blockSize, 0, stream>>>(
        /* parameters from devicePtrs */
        length,
        stride);

    return cudaGetLastError();
}}";
    }

    /// <summary>
    /// Gets the Metal compute shader template.
    /// </summary>
    /// <param name="kernelName">The name of the kernel.</param>
    /// <param name="parameters">The kernel parameters.</param>
    /// <returns>The formatted Metal shader template.</returns>
    public static string GetMetalShaderTemplate(string kernelName, string parameters)
    {
        return $@"// Metal compute shader implementation
#include <metal_stdlib>
using namespace metal;

kernel void {kernelName}_metal_kernel(
{parameters}
    uint2 gid [[thread_position_in_grid]],
    uint2 grid_size [[threads_per_grid]])
{{
    uint index = gid.x + gid.y * grid_size.x;

    // Metal kernel operation implementation
    // Process element at index
}}";
    }

    /// <summary>
    /// Gets the OpenCL kernel template.
    /// </summary>
    /// <param name="kernelName">The name of the kernel.</param>
    /// <param name="parameters">The kernel parameters.</param>
    /// <returns>The formatted OpenCL kernel template.</returns>
    public static string GetOpenCLKernelTemplate(string kernelName, string parameters)
    {
        return $@"// OpenCL kernel implementation

__kernel void {kernelName}_opencl_kernel(
{parameters}
    int length)
{{
    int idx = get_global_id(0);
    if (idx < length) {{
        // OpenCL kernel operation implementation
        // Process element at index idx
    }}
}}";
    }

    /// <summary>
    /// Gets the template for kernel registry entries.
    /// </summary>
    /// <param name="method">The kernel method information.</param>
    /// <returns>The formatted registry entry template.</returns>
    public static string GetRegistryEntryTemplate(KernelMethodInfo method)
    {
        var key = $"{method.ContainingType}.{method.Name}";
        var backendList = string.Join(", ",
            method.Backends.ConvertAll(b => $"AcceleratorType.{b}"));

        return $@"            [""{key}""] = new KernelRegistration
            {{
                Name = ""{method.Name}"",
                FullName = ""{key}"",
                ContainingType = typeof({method.ContainingType}),
                SupportedBackends = new[] {{ {backendList} }},
                VectorSize = {method.VectorSize},
                IsParallel = {(method.IsParallel ? "true" : "false")},
                ParameterCount = {method.Parameters.Count},
                BufferParameterCount = {method.Parameters.FindAll(p => p.IsBuffer).Count},
                ScalarParameterCount = {method.Parameters.FindAll(p => !p.IsBuffer).Count}
            }},";
    }

    /// <summary>
    /// Gets the template for parameter validation.
    /// </summary>
    /// <param name="parameters">The parameters to validate.</param>
    /// <returns>The formatted validation template.</returns>
    public static string GetParameterValidationTemplate(List<ParameterInfo> parameters)
    {
        var validation = new StringBuilder();
        validation.AppendLine("            // Validate parameters");

        foreach (var param in parameters)
        {
            if (param.IsBuffer)
            {
                validation.AppendLine($"            if ({param.Name} == null)");
                validation.AppendLine($"                throw new ArgumentNullException(nameof({param.Name}));");
            }
        }

        return validation.ToString();
    }

    /// <summary>
    /// Gets the template for error handling in kernel execution.
    /// </summary>
    /// <returns>The formatted error handling template.</returns>
    public static string GetErrorHandlingTemplate()
    {
        return @"            try
            {
                // Kernel execution
            }
            catch (Exception ex)
            {
                throw new KernelExecutionException(
                    $""Failed to execute kernel: {ex.Message}"", ex);
            }";
    }

    /// <summary>
    /// Gets the template for performance profiling hooks.
    /// </summary>
    /// <param name="kernelName">The name of the kernel.</param>
    /// <returns>The formatted profiling template.</returns>
    public static string GetProfilingTemplate(string kernelName)
    {
        return $@"            // Performance profiling
            using var profiler = new KernelProfiler(""{kernelName}"");
            profiler.StartTiming();

            try
            {{
                // Kernel execution
            }}
            finally
            {{
                profiler.StopTiming();
                profiler.RecordMetrics();
            }}";
    }

    /// <summary>
    /// Gets the template for dependency injection service registration.
    /// </summary>
    /// <param name="kernelMethods">The kernel methods to register.</param>
    /// <returns>The formatted service registration template.</returns>
    public static string GetServiceRegistrationTemplate(List<KernelMethodInfo> kernelMethods)
    {
        var registration = new StringBuilder();
        registration.AppendLine("        public static IServiceCollection AddGeneratedKernels(this IServiceCollection services)");
        registration.AppendLine("        {");
        registration.AppendLine("            // Register kernel discovery service");
        registration.AppendLine("            services.AddSingleton<IKernelDiscoveryService, GeneratedKernelDiscoveryService>();");
        registration.AppendLine();

        foreach (var method in kernelMethods)
        {
            var executorName = $"{method.Name}KernelExecutor";
            registration.AppendLine($"            // Register {method.Name} kernel executor");
            registration.AppendLine($"            services.AddTransient<I{executorName}, {executorName}>();");
        }

        registration.AppendLine();
        registration.AppendLine("            return services;");
        registration.AppendLine("        }");

        return registration.ToString();
    }

    /// <summary>
    /// Gets the template for XML documentation comments.
    /// </summary>
    /// <param name="summary">The summary description.</param>
    /// <param name="parameters">The parameter descriptions.</param>
    /// <param name="returns">The return value description.</param>
    /// <param name="remarks">Additional remarks.</param>
    /// <returns>The formatted XML documentation.</returns>
    public static string GetXmlDocumentationTemplate(
        string summary,
        Dictionary<string, string>? parameters = null,
        string? returns = null,
        string? remarks = null)
    {
        var doc = new StringBuilder();
        doc.AppendLine("        /// <summary>");
        doc.AppendLine($"        /// {summary}");
        doc.AppendLine("        /// </summary>");

        if (parameters != null)
        {
            foreach (var parameter in parameters)
            {
                doc.AppendLine($"        /// <param name=\"{parameter.Key}\">{parameter.Value}</param>");
            }
        }

        if (!string.IsNullOrEmpty(returns))
        {
            doc.AppendLine($"        /// <returns>{returns}</returns>");
        }

        if (!string.IsNullOrEmpty(remarks))
        {
            doc.AppendLine("        /// <remarks>");
            doc.AppendLine($"        /// {remarks}");
            doc.AppendLine("        /// </remarks>");
        }

        return doc.ToString();
    }

    /// <summary>
    /// Gets the template for namespace declarations.
    /// </summary>
    /// <param name="namespaceName">The namespace name.</param>
    /// <param name="content">The content within the namespace.</param>
    /// <returns>The formatted namespace declaration.</returns>
    public static string GetNamespaceTemplate(string namespaceName, string content)
    {
        return $@"namespace {namespaceName}
{{
{content}
}}";
    }

    /// <summary>
    /// Gets the template for conditional compilation directives.
    /// </summary>
    /// <param name="condition">The compilation condition.</param>
    /// <param name="content">The content to conditionally compile.</param>
    /// <returns>The formatted conditional compilation block.</returns>
    public static string GetConditionalCompilationTemplate(string condition, string content)
    {
        return $@"#if {condition}
{content}
#endif";
    }

    /// <summary>
    /// Gets the template for generated code attributes.
    /// </summary>
    /// <param name="generatorName">The name of the generator.</param>
    /// <param name="version">The version of the generator.</param>
    /// <returns>The formatted generated code attribute.</returns>
    public static string GetGeneratedCodeAttributeTemplate(string generatorName = "KernelSourceGenerator", string version = "1.0.0")
    {
        return $@"[System.CodeDom.Compiler.GeneratedCode(""{generatorName}"", ""{version}"")]
[System.Diagnostics.DebuggerNonUserCode]
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]";
    }

    /// <summary>
    /// Gets the template for unsafe code blocks.
    /// </summary>
    /// <param name="content">The unsafe code content.</param>
    /// <returns>The formatted unsafe code block.</returns>
    public static string GetUnsafeCodeTemplate(string content)
    {
        return $@"            unsafe
            {{
{content}
            }}";
    }

    /// <summary>
    /// Gets the template for async/await patterns in kernel execution.
    /// </summary>
    /// <param name="operation">The async operation to execute.</param>
    /// <returns>The formatted async execution template.</returns>
    public static string GetAsyncExecutionTemplate(string operation)
    {
        return $@"            // Execute asynchronously
            await Task.Run(() =>
            {{
{operation}
            }});";
    }
}