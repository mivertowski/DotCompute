// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotCompute.Generators.Utils;

/// <summary>
/// Helper methods for source generation.
/// </summary>
public static class SourceGeneratorHelpers
{
    /// <summary>
    /// Creates a standard file header for generated code.
    /// </summary>
    public static string GenerateHeader(params string[] usings)
    {
        var sb = new StringBuilder();
        _ = sb.AppendLine("// <auto-generated/>");
        _ = sb.AppendLine("#nullable enable");
        _ = sb.AppendLine("#pragma warning disable CS8019 // Unnecessary using directive");
        _ = sb.AppendLine();

        foreach (var usingDirective in usings)
        {
            _ = sb.AppendLine($"using {usingDirective};");
        }

        _ = sb.AppendLine();
        return sb.ToString();
    }

    /// <summary>
    /// Generates a namespace declaration.
    /// </summary>
    public static string BeginNamespace(string namespaceName) => $"namespace {namespaceName}\n{{";

    /// <summary>
    /// Closes a namespace declaration.
    /// </summary>
    public static string EndNamespace() => "}";

    /// <summary>
    /// Indents code by the specified level.
    /// </summary>
    public static string Indent(string code, int level)
    {
        var indent = new string(' ', level * 4);
        var lines = code.Split('\n');
        return string.Join("\n", lines.Select(line => string.IsNullOrWhiteSpace(line) ? line : indent + line));
    }

    /// <summary>
    /// Generates parameter validation code.
    /// </summary>
    public static string GenerateParameterValidation(IEnumerable<(string name, string type, bool isBuffer)> parameters)
    {
        var sb = new StringBuilder();

        foreach (var (name, type, isBuffer) in parameters)
        {
            if (isBuffer)
            {
                _ = sb.AppendLine($"ArgumentNullException.ThrowIfNull({name}, nameof({name}));");
            }
            else if (type.Contains("Span") || type.Contains("Memory"))
            {
                _ = sb.AppendLine($"if ({name}.IsEmpty) throw new ArgumentException(\"Buffer cannot be empty\", nameof({name}));");
            }
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generates optimized loop code based on hints.
    /// </summary>
    public static string GenerateOptimizedLoop(string indexVar, string limitVar, string body, bool unroll = false, int unrollFactor = 4)
    {
        var sb = new StringBuilder();

        if (unroll)
        {
            // Generate unrolled loop
            _ = sb.AppendLine($"var remainder = {limitVar} % {unrollFactor};");
            _ = sb.AppendLine($"var limit = {limitVar} - remainder;");
            _ = sb.AppendLine();
            _ = sb.AppendLine($"for (int {indexVar} = 0; {indexVar} < limit; {indexVar} += {unrollFactor})");
            _ = sb.AppendLine("{");

            for (var i = 0; i < unrollFactor; i++)
            {
                var unrolledBody = body.Replace($"{{{indexVar}}}", $"{{{indexVar} + {i}}}");
                _ = sb.AppendLine($"    {unrolledBody}");
            }

            _ = sb.AppendLine("}");
            _ = sb.AppendLine();
            _ = sb.AppendLine("// Handle remainder");
            _ = sb.AppendLine($"for (int {indexVar} = limit; {indexVar} < {limitVar}; {indexVar}++)");
            _ = sb.AppendLine("{");
            _ = sb.AppendLine($"    {body}");
            _ = sb.AppendLine("}");
        }
        else
        {
            // Generate regular loop
            _ = sb.AppendLine($"for (int {indexVar} = 0; {indexVar} < {limitVar}; {indexVar}++)");
            _ = sb.AppendLine("{");
            _ = sb.AppendLine($"    {body}");
            _ = sb.AppendLine("}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Extracts the body of a method as a string.
    /// </summary>
    public static string? ExtractMethodBody(MethodDeclarationSyntax method)
    {
        var body = method.Body;
        if (body == null)
        {
            // Try expression body
            if (method.ExpressionBody != null)
            {
                return method.ExpressionBody.Expression.ToString() + ";";
            }
            return null;
        }

        return string.Join("\n", body.Statements.Select(s => s.ToString()));
    }

    /// <summary>
    /// Analyzes method body for vectorization opportunities.
    /// </summary>
    public static VectorizationInfo AnalyzeVectorization(MethodDeclarationSyntax method)
    {
        var info = new VectorizationInfo();
        var body = method.Body;

        if (body == null)
        {
            return info;
        }

        // Look for loops
        var loops = body.DescendantNodes().OfType<ForStatementSyntax>().ToList();
        info.LoopCount = loops.Count;

        // Look for array/span accesses
        var elementAccesses = body.DescendantNodes().OfType<ElementAccessExpressionSyntax>().ToList();
        info.HasArrayAccess = elementAccesses.Count > 0;

        // Look for arithmetic operations
        var binaryOps = body.DescendantNodes().OfType<BinaryExpressionSyntax>()
            .Where(b => IsArithmeticOperation(b.Kind()))
            .ToList();
        info.ArithmeticOperationCount = binaryOps.Count;

        // Check for vectorizable patterns
        foreach (var loop in loops)
        {
            if (IsVectorizableLoop(loop))
            {
                info.VectorizableLoops++;
            }
        }

        return info;
    }

    private static bool IsArithmeticOperation(SyntaxKind kind)
    {
        return kind is SyntaxKind.AddExpression or
               SyntaxKind.SubtractExpression or
               SyntaxKind.MultiplyExpression or
               SyntaxKind.DivideExpression;
    }

    private static bool IsVectorizableLoop(ForStatementSyntax loop)
    {
        // Simple heuristic: loop has simple increment and array access pattern
        if (loop.Incrementors.Count != 1)
        {
            return false;
        }

        var incrementor = loop.Incrementors[0];
        if (incrementor is not PostfixUnaryExpressionSyntax and not PrefixUnaryExpressionSyntax)
        {
            return false;
        }

        // Check for array access pattern in loop body
        if (loop.Statement is BlockSyntax block)
        {
            var hasArrayAccess = block.DescendantNodes().OfType<ElementAccessExpressionSyntax>().Any();
            var hasSimpleArithmetic = block.DescendantNodes().OfType<BinaryExpressionSyntax>()
                .Any(b => IsArithmeticOperation(b.Kind()));

            return hasArrayAccess && hasSimpleArithmetic;
        }

        return false;
    }

    /// <summary>
    /// Generates SIMD types based on element type.
    /// </summary>
    public static string GetSimdType(string elementType, int vectorSize)
    {
        return elementType switch
        {
            "float" => $"Vector{vectorSize * 8}<float>",
            "double" => $"Vector{vectorSize * 8}<double>",
            "int" => $"Vector{vectorSize * 8}<int>",
            "uint" => $"Vector{vectorSize * 8}<uint>",
            "long" => $"Vector{vectorSize * 8}<long>",
            "ulong" => $"Vector{vectorSize * 8}<ulong>",
            "short" => $"Vector{vectorSize * 8}<short>",
            "ushort" => $"Vector{vectorSize * 8}<ushort>",
            "byte" => $"Vector{vectorSize * 8}<byte>",
            "sbyte" => $"Vector{vectorSize * 8}<sbyte>",
            _ => throw new NotSupportedException($"SIMD type not supported for {elementType}")
        };
    }

    /// <summary>
    /// Generates intrinsic operation based on operation type.
    /// </summary>
    public static string GetIntrinsicOperation(string operation, string vectorType)
    {
        return operation switch
        {
            "+" => $"{vectorType}.Add",
            "-" => $"{vectorType}.Subtract",
            "*" => $"{vectorType}.Multiply",
            "/" => $"{vectorType}.Divide",
            "min" => $"{vectorType}.Min",
            "max" => $"{vectorType}.Max",
            "sqrt" => $"{vectorType}.SquareRoot",
            "abs" => $"{vectorType}.Abs",
            _ => throw new NotSupportedException($"Intrinsic operation not supported for {operation}")
        };
    }
}

/// <summary>
/// Information about vectorization opportunities.
/// </summary>
public class VectorizationInfo
{
    public int LoopCount { get; set; }
    public int VectorizableLoops { get; set; }
    public bool HasArrayAccess { get; set; }
    public int ArithmeticOperationCount { get; set; }
    public bool IsVectorizable => VectorizableLoops > 0 && HasArrayAccess;
    public bool IsArithmetic => ArithmeticOperationCount > 0;
    public bool IsMemoryOperation => HasArrayAccess;
}
