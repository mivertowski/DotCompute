// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Diagnostics;
using global::System.Security.Cryptography;
using System.Text;
using Microsoft.Extensions.Logging;
using DotCompute.Algorithms.Logging;

namespace DotCompute.Algorithms.Security;


/// <summary>
/// Service for scanning assemblies for malware using multiple detection methods.
/// </summary>
public sealed class MalwareScanningService : IDisposable
{
    private readonly ILogger<MalwareScanningService> _logger;
    private readonly MalwareScanningOptions _options;
    private readonly HttpClient _httpClient;
    private readonly HashSet<string> _knownMalwareHashes;
    private readonly SemaphoreSlim _scanSemaphore;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="MalwareScanningService"/> class.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    /// <param name="options">Configuration options for malware scanning.</param>
    public MalwareScanningService(ILogger<MalwareScanningService> logger, MalwareScanningOptions? options = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _options = options ?? new MalwareScanningOptions();
        _httpClient = new HttpClient { Timeout = _options.ScanTimeout };
        _knownMalwareHashes = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        _scanSemaphore = new SemaphoreSlim(_options.MaxConcurrentScans, _options.MaxConcurrentScans);

        LoadKnownMalwareHashes();
    }

    /// <summary>
    /// Scans an assembly for malware using all configured detection methods.
    /// </summary>
    /// <param name="assemblyPath">Path to the assembly to scan.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The malware scan result.</returns>
    public async Task<MalwareScanResult> ScanAssemblyAsync(string assemblyPath, CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(assemblyPath);
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (!File.Exists(assemblyPath))
        {
            return new MalwareScanResult
            {
                IsClean = false,
                ThreatLevel = ThreatLevel.High,
                DetectionMethod = "File System",
                ThreatDescription = "Assembly file not found"
            };
        }

        await _scanSemaphore.WaitAsync(cancellationToken);
        try
        {
            _logger.LogDebugMessage("Starting malware scan for: {assemblyPath}");
            var stopwatch = Stopwatch.StartNew();

            var result = await PerformComprehensiveScanAsync(assemblyPath, cancellationToken);

            stopwatch.Stop();
            result.ScanDuration = stopwatch.Elapsed;

            if (result.IsClean)
            {
                _logger.LogInfoMessage($"Malware scan completed - assembly is clean: {assemblyPath} (took {stopwatch.ElapsedMilliseconds}ms)");
            }
            else
            {
                _logger.LogWarningMessage($"Malware scan detected threat in: {assemblyPath}, Threat: {result.ThreatDescription}, Level: {result.ThreatLevel}");
            }

            return result;
        }
        finally
        {
            _ = _scanSemaphore.Release();
        }
    }

    /// <summary>
    /// Scans multiple assemblies concurrently.
    /// </summary>
    /// <param name="assemblyPaths">Paths to assemblies to scan.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Dictionary of scan results keyed by assembly path.</returns>
    public async Task<Dictionary<string, MalwareScanResult>> ScanMultipleAssembliesAsync(
        IEnumerable<string> assemblyPaths,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(assemblyPaths);
        ObjectDisposedException.ThrowIf(_disposed, this);

        var tasks = assemblyPaths.Select(async path =>
        {
            var result = await ScanAssemblyAsync(path, cancellationToken);
            return new KeyValuePair<string, MalwareScanResult>(path, result);
        });

        var results = await Task.WhenAll(tasks);
        return results.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    private async Task<MalwareScanResult> PerformComprehensiveScanAsync(string assemblyPath, CancellationToken cancellationToken)
    {
        var result = new MalwareScanResult { IsClean = true, ThreatLevel = ThreatLevel.None };

        // 1. Hash-based detection (fastest)
        var hashResult = await ScanByHashAsync(assemblyPath, cancellationToken);
        if (!hashResult.IsClean)
        {
            return hashResult;
        }

        // 2. Pattern-based scanning
        var patternResult = await ScanByPatternsAsync(assemblyPath, cancellationToken);
        if (!patternResult.IsClean)
        {
            return patternResult;
        }

        // 3. Windows Defender integration (if available)
        if (_options.EnableWindowsDefender && OperatingSystem.IsWindows())
        {
            var defenderResult = await ScanWithWindowsDefenderAsync(assemblyPath, cancellationToken);
            if (!defenderResult.IsClean)
            {
                return defenderResult;
            }
        }

        // 4. Behavioral analysis
        var behaviorResult = await AnalyzeBehaviorAsync(assemblyPath, cancellationToken);
        if (!behaviorResult.IsClean)
        {
            return behaviorResult;
        }

        // 5. External antivirus integration (if configured)
        if (!string.IsNullOrEmpty(_options.ExternalScannerPath))
        {
            var externalResult = await ScanWithExternalToolAsync(assemblyPath, cancellationToken);
            if (!externalResult.IsClean)
            {
                return externalResult;
            }
        }

        result.DetectionMethod = "Comprehensive Scan";
        result.ScanMethods.AddRange(new[] { "Hash", "Pattern", "Behavioral" });

        if (_options.EnableWindowsDefender && OperatingSystem.IsWindows())
        {
            result.ScanMethods.Add("Windows Defender");
        }

        return result;
    }

    private async Task<MalwareScanResult> ScanByHashAsync(string assemblyPath, CancellationToken cancellationToken)
    {
        try
        {
            using var sha256 = SHA256.Create();
            using var fileStream = new FileStream(assemblyPath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, useAsync: true);
            var hashBytes = await sha256.ComputeHashAsync(fileStream, cancellationToken);
            var hash = Convert.ToHexString(hashBytes);

            var result = new MalwareScanResult
            {
                DetectionMethod = "Hash-based",
                FileHash = hash
            };

            if (_knownMalwareHashes.Contains(hash))
            {
                result.IsClean = false;
                result.ThreatLevel = ThreatLevel.High;
                result.ThreatDescription = "File matches known malware hash signature";
                _logger.LogWarningMessage("Assembly matches known malware hash: {hash}");
            }
            else
            {
                result.IsClean = true;
                result.ThreatLevel = ThreatLevel.None;
            }

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogErrorMessage(ex, $"Error during hash-based scanning of: {assemblyPath}");
            return new MalwareScanResult
            {
                IsClean = false,
                ThreatLevel = ThreatLevel.Medium,
                DetectionMethod = "Hash-based",
                ThreatDescription = $"Hash scanning failed: {ex.Message}"
            };
        }
    }

    private async Task<MalwareScanResult> ScanByPatternsAsync(string assemblyPath, CancellationToken cancellationToken)
    {
        var result = new MalwareScanResult
        {
            IsClean = true,
            ThreatLevel = ThreatLevel.None,
            DetectionMethod = "Pattern-based"
        };

        try
        {
            using var fileStream = new FileStream(assemblyPath, FileMode.Open, FileAccess.Read, FileShare.Read);
            using var reader = new BinaryReader(fileStream);

            var suspiciousPatterns = 0;
            var buffer = new byte[4096];
            var position = 0L;

            while (position < fileStream.Length)
            {
                var bytesRead = await fileStream.ReadAsync(buffer, cancellationToken);
                if (bytesRead == 0)
                {
                    break;
                }

                var content = Encoding.ASCII.GetString(buffer, 0, bytesRead);

                // Check for suspicious strings
                foreach (var pattern in _options.SuspiciousPatterns)
                {
                    if (content.Contains(pattern, StringComparison.OrdinalIgnoreCase))
                    {
                        suspiciousPatterns++;
                        result.DetectedPatterns.Add(pattern);
                    }
                }

                position += bytesRead;
            }

            if (suspiciousPatterns > _options.SuspiciousPatternThreshold)
            {
                result.IsClean = false;
                result.ThreatLevel = ThreatLevel.Medium;
                result.ThreatDescription = $"Assembly contains {suspiciousPatterns} suspicious patterns";
            }
            else if (suspiciousPatterns > 0)
            {
                result.ThreatLevel = ThreatLevel.Low;
                result.Warnings.Add($"Assembly contains {suspiciousPatterns} potentially suspicious patterns");
            }

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogErrorMessage(ex, $"Error during pattern-based scanning of: {assemblyPath}");
            return new MalwareScanResult
            {
                IsClean = false,
                ThreatLevel = ThreatLevel.Medium,
                DetectionMethod = "Pattern-based",
                ThreatDescription = $"Pattern scanning failed: {ex.Message}"
            };
        }
    }

    private async Task<MalwareScanResult> ScanWithWindowsDefenderAsync(string assemblyPath, CancellationToken cancellationToken)
    {
        if (!OperatingSystem.IsWindows())
        {
            return new MalwareScanResult { IsClean = true, ThreatLevel = ThreatLevel.None, DetectionMethod = "Windows Defender (Not Available)" };
        }

        try
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = "powershell.exe",
                Arguments = $"-Command \"Get-MpThreatDetection | Where-Object {{$_.Resources -contains '{assemblyPath}'}}\"",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            };

            using var process = new Process { StartInfo = startInfo };
            _ = process.Start();

            var output = await process.StandardOutput.ReadToEndAsync(cancellationToken);
            var error = await process.StandardError.ReadToEndAsync(cancellationToken);

            await process.WaitForExitAsync(cancellationToken);

            var result = new MalwareScanResult
            {
                DetectionMethod = "Windows Defender"
            };

            if (process.ExitCode == 0 && string.IsNullOrWhiteSpace(output))
            {
                result.IsClean = true;
                result.ThreatLevel = ThreatLevel.None;
            }
            else if (!string.IsNullOrWhiteSpace(output))
            {
                result.IsClean = false;
                result.ThreatLevel = ThreatLevel.High;
                result.ThreatDescription = "Windows Defender detected threat";
                result.AdditionalInfo = output;
            }
            else
            {
                result.IsClean = true;
                result.ThreatLevel = ThreatLevel.None;
                if (!string.IsNullOrWhiteSpace(error))
                {
                    result.Warnings.Add($"Windows Defender scan warning: {error}");
                }
            }

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogErrorMessage(ex, $"Error during Windows Defender scanning of: {assemblyPath}");
            return new MalwareScanResult
            {
                IsClean = false,
                ThreatLevel = ThreatLevel.Medium,
                DetectionMethod = "Windows Defender",
                ThreatDescription = $"Windows Defender scan failed: {ex.Message}"
            };
        }
    }

    private async Task<MalwareScanResult> ScanWithExternalToolAsync(string assemblyPath, CancellationToken cancellationToken)
    {
        try
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = _options.ExternalScannerPath,
                Arguments = $"{_options.ExternalScannerArgs} \"{assemblyPath}\"",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            };

            using var process = new Process { StartInfo = startInfo };
            _ = process.Start();

            var output = await process.StandardOutput.ReadToEndAsync(cancellationToken);
            var error = await process.StandardError.ReadToEndAsync(cancellationToken);

            await process.WaitForExitAsync(cancellationToken);

            var result = new MalwareScanResult
            {
                DetectionMethod = "External Scanner"
            };

            // Exit code interpretation (common convention: 0 = clean, non-zero = threat found)
            if (process.ExitCode == 0)
            {
                result.IsClean = true;
                result.ThreatLevel = ThreatLevel.None;
            }
            else
            {
                result.IsClean = false;
                result.ThreatLevel = ThreatLevel.High;
                result.ThreatDescription = "External scanner detected threat";
                result.AdditionalInfo = output;
            }

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogErrorMessage(ex, $"Error during external tool scanning of: {assemblyPath}");
            return new MalwareScanResult
            {
                IsClean = false,
                ThreatLevel = ThreatLevel.Medium,
                DetectionMethod = "External Scanner",
                ThreatDescription = $"External scanner failed: {ex.Message}"
            };
        }
    }

    private Task<MalwareScanResult> AnalyzeBehaviorAsync(string assemblyPath, CancellationToken cancellationToken)
    {
        var result = new MalwareScanResult
        {
            IsClean = true,
            ThreatLevel = ThreatLevel.None,
            DetectionMethod = "Behavioral Analysis"
        };

        try
        {
            var fileInfo = new FileInfo(assemblyPath);
            var riskScore = 0;

            // File size anomalies
            if (fileInfo.Length < 1024) // Very small files
            {
                riskScore += 10;
                result.BehavioralFlags.Add("Unusually small file size");
            }
            else if (fileInfo.Length > 100 * 1024 * 1024) // Very large files
            {
                riskScore += 15;
                result.BehavioralFlags.Add("Unusually large file size");
            }

            // File extension vs content analysis
            var extension = Path.GetExtension(assemblyPath).ToLowerInvariant();
            if (extension is not ".dll" and not ".exe")
            {
                riskScore += 20;
                result.BehavioralFlags.Add("Suspicious file extension for .NET assembly");
            }

            // Creation time analysis
            var now = DateTime.Now;
            if (fileInfo.CreationTime > now.AddMinutes(-5))
            {
                riskScore += 5;
                result.BehavioralFlags.Add("Recently created file");
            }

            // Evaluate risk score
            if (riskScore >= _options.BehavioralRiskThreshold)
            {
                result.IsClean = false;
                result.ThreatLevel = riskScore >= 50 ? ThreatLevel.High : ThreatLevel.Medium;
                result.ThreatDescription = $"Behavioral analysis detected suspicious characteristics (risk score: {riskScore})";
            }
            else if (riskScore > 0)
            {
                result.ThreatLevel = ThreatLevel.Low;
                result.Warnings.Add($"Some behavioral flags detected (risk score: {riskScore})");
            }

            return Task.FromResult(result);
        }
        catch (Exception ex)
        {
            _logger.LogErrorMessage(ex, $"Error during behavioral analysis of: {assemblyPath}");
            return Task.FromResult(new MalwareScanResult
            {
                IsClean = false,
                ThreatLevel = ThreatLevel.Medium,
                DetectionMethod = "Behavioral Analysis",
                ThreatDescription = $"Behavioral analysis failed: {ex.Message}"
            });
        }
    }

    private void LoadKnownMalwareHashes()
    {
        try
        {
            if (!string.IsNullOrEmpty(_options.MalwareHashDatabasePath) && File.Exists(_options.MalwareHashDatabasePath))
            {
                var hashes = File.ReadAllLines(_options.MalwareHashDatabasePath)
                    .Where(line => !string.IsNullOrWhiteSpace(line) && !line.StartsWith('#'))
                    .Select(line => line.Trim().ToUpperInvariant());

                foreach (var hash in hashes)
                {
                    _ = _knownMalwareHashes.Add(hash);
                }

                _logger.LogInfoMessage("Loaded {_knownMalwareHashes.Count} malware hashes from database");
            }
            else
            {
                // Add some common test hashes if no database is provided
                _ = _knownMalwareHashes.Add("D41D8CD98F00B204E9800998ECF8427E"); // Empty file MD5 (example)
                _logger.LogDebugMessage("Using default malware hash database");
            }
        }
        catch (Exception ex)
        {
            _logger.LogErrorMessage(ex, $"Failed to load malware hash database from: {_options.MalwareHashDatabasePath}");
        }
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (!_disposed)
        {
            _httpClient?.Dispose();
            _scanSemaphore?.Dispose();
            _disposed = true;
        }
    }
}

/// <summary>
/// Configuration options for malware scanning.
/// </summary>
public sealed class MalwareScanningOptions
{
    /// <summary>
    /// Gets or sets whether Windows Defender integration is enabled.
    /// </summary>
    public bool EnableWindowsDefender { get; set; } = true;

    /// <summary>
    /// Gets or sets the maximum number of concurrent scans.
    /// </summary>
    public int MaxConcurrentScans { get; set; } = 3;

    /// <summary>
    /// Gets or sets the scan timeout.
    /// </summary>
    public TimeSpan ScanTimeout { get; set; } = TimeSpan.FromMinutes(2);

    /// <summary>
    /// Gets or sets the path to an external scanner executable.
    /// </summary>
    public string? ExternalScannerPath { get; set; }

    /// <summary>
    /// Gets or sets the arguments for the external scanner.
    /// </summary>
    public string ExternalScannerArgs { get; set; } = "--scan";

    /// <summary>
    /// Gets or sets the path to the malware hash database file.
    /// </summary>
    public string? MalwareHashDatabasePath { get; set; }

    /// <summary>
    /// Gets or sets the threshold for suspicious pattern detection.
    /// </summary>
    public int SuspiciousPatternThreshold { get; set; } = 5;

    /// <summary>
    /// Gets or sets the behavioral analysis risk threshold.
    /// </summary>
    public int BehavioralRiskThreshold { get; set; } = 30;

    /// <summary>
    /// Gets the list of suspicious patterns to detect.
    /// </summary>
    public List<string> SuspiciousPatterns { get; } =
    [
        "CreateProcess",
    "WriteFile",
    "RegOpenKey",
    "VirtualAlloc",
    "LoadLibrary",
    "GetProcAddress",
    "shellcode",
    "payload",
    "backdoor",
    "trojan",
    "keylogger",
    "rootkit"
    ];
}

/// <summary>
/// Result of a malware scan.
/// </summary>
public sealed class MalwareScanResult
{
    /// <summary>
    /// Gets or sets whether the file is clean (no threats detected).
    /// </summary>
    public bool IsClean { get; set; } = true;

    /// <summary>
    /// Gets or sets the threat level detected.
    /// </summary>
    public ThreatLevel ThreatLevel { get; set; } = ThreatLevel.None;

    /// <summary>
    /// Gets or sets the detection method that found the threat.
    /// </summary>
    public string DetectionMethod { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the description of the threat.
    /// </summary>
    public string? ThreatDescription { get; set; }

    /// <summary>
    /// Gets or sets the file hash.
    /// </summary>
    public string? FileHash { get; set; }

    /// <summary>
    /// Gets or sets the scan duration.
    /// </summary>
    public TimeSpan ScanDuration { get; set; }

    /// <summary>
    /// Gets the list of scan methods used.
    /// </summary>
    public List<string> ScanMethods { get; } = [];

    /// <summary>
    /// Gets the list of detected suspicious patterns.
    /// </summary>
    public List<string> DetectedPatterns { get; } = [];

    /// <summary>
    /// Gets the list of behavioral flags detected.
    /// </summary>
    public List<string> BehavioralFlags { get; } = [];

    /// <summary>
    /// Gets the list of warnings generated during scanning.
    /// </summary>
    public List<string> Warnings { get; } = [];

    /// <summary>
    /// Gets or sets additional information from the scan.
    /// </summary>
    public string? AdditionalInfo { get; set; }

    /// <summary>
    /// Gets additional scan metadata.
    /// </summary>
    public Dictionary<string, object> Metadata { get; } = [];
}

/// <summary>
/// Threat levels for malware detection.
/// </summary>
public enum ThreatLevel
{
    /// <summary>
    /// No threat detected.
    /// </summary>
    None = 0,

    /// <summary>
    /// Low threat level - potentially suspicious.
    /// </summary>
    Low = 1,

    /// <summary>
    /// Medium threat level - suspicious activity.
    /// </summary>
    Medium = 2,

    /// <summary>
    /// High threat level - likely malware.
    /// </summary>
    High = 3,

    /// <summary>
    /// Critical threat level - confirmed malware.
    /// </summary>
    Critical = 4
}
