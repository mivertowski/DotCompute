// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Collections.Concurrent;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using DotCompute.Algorithms.Logging;

namespace DotCompute.Algorithms.Security;


/// <summary>
/// Advanced vulnerability scanner that checks packages against vulnerability databases.
/// </summary>
public sealed class VulnerabilityScanner : IDisposable
{
    private readonly ILogger<VulnerabilityScanner> _logger;
    private readonly VulnerabilityScannerOptions _options;
    private readonly HttpClient _httpClient;
    private readonly ConcurrentDictionary<string, VulnerabilityReport> _cache;
    private readonly SemaphoreSlim _scanSemaphore;
    private readonly Timer _cacheCleanupTimer;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="VulnerabilityScanner"/> class.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    /// <param name="options">Configuration options.</param>
    public VulnerabilityScanner(ILogger<VulnerabilityScanner> logger, VulnerabilityScannerOptions? options = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _options = options ?? new VulnerabilityScannerOptions();
        _httpClient = new HttpClient { Timeout = _options.ScanTimeout };
        _cache = new ConcurrentDictionary<string, VulnerabilityReport>();
        _scanSemaphore = new SemaphoreSlim(_options.MaxConcurrentScans, _options.MaxConcurrentScans);

        // Setup periodic cache cleanup
        _cacheCleanupTimer = new Timer(CleanupCache, null, TimeSpan.FromHours(1), TimeSpan.FromHours(1));

        LoadLocalVulnerabilityDatabase();
    }

    /// <summary>
    /// Scans a package for known vulnerabilities.
    /// </summary>
    /// <param name="packageId">The package ID to scan.</param>
    /// <param name="packageVersion">The package version.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The vulnerability scan result.</returns>
    public async Task<VulnerabilityScanResult> ScanPackageAsync(
        string packageId,
        string packageVersion,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(packageId);
        ArgumentException.ThrowIfNullOrWhiteSpace(packageVersion);
        ObjectDisposedException.ThrowIf(_disposed, this);

        await _scanSemaphore.WaitAsync(cancellationToken);
        try
        {
            _logger.LogDebugMessage("Scanning package for vulnerabilities: {PackageId} {packageId, packageVersion}");

            var cacheKey = GetCacheKey(packageId, packageVersion);
            if (_cache.TryGetValue(cacheKey, out var cachedReport) && IsCacheValid(cachedReport))
            {
                _logger.LogDebugMessage("Using cached vulnerability report for {PackageId} {packageId, packageVersion}");
                return CreateScanResult(cachedReport, true);
            }

            var vulnerabilities = new List<PackageVulnerability>();

            // Scan against multiple vulnerability sources
            await ScanAgainstNvdAsync(packageId, packageVersion, vulnerabilities, cancellationToken);
            await ScanAgainstGitHubAsync(packageId, packageVersion, vulnerabilities, cancellationToken);
            await ScanAgainstOssIndexAsync(packageId, packageVersion, vulnerabilities, cancellationToken);
            await ScanAgainstLocalDatabaseAsync(packageId, packageVersion, vulnerabilities, cancellationToken);

            // Remove duplicates based on CVE ID
            vulnerabilities = [.. vulnerabilities
            .GroupBy(v => v.CveId ?? v.Id)
            .Select(g => g.OrderByDescending(v => v.Severity).First())];

            var report = new VulnerabilityReport
            {
                PackageId = packageId,
                PackageVersion = packageVersion,
                ScanTime = DateTime.UtcNow,
                Vulnerabilities = vulnerabilities,
                Sources = ["NVD", "GitHub", "OSS Index", "Local"]
            };

            // Cache the report
            _ = _cache.TryAdd(cacheKey, report);

            var result = CreateScanResult(report, false);

            _logger.LogInfoMessage($"Vulnerability scan completed for {packageId} {packageVersion}: {vulnerabilities.Count} vulnerabilities found");

            return result;
        }
        finally
        {
            _ = _scanSemaphore.Release();
        }
    }

    /// <summary>
    /// Scans multiple packages concurrently.
    /// </summary>
    /// <param name="packages">The packages to scan.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Dictionary of scan results keyed by package ID.</returns>
    public async Task<Dictionary<string, VulnerabilityScanResult>> ScanMultiplePackagesAsync(
        IEnumerable<(string Id, string Version)> packages,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(packages);
        ObjectDisposedException.ThrowIf(_disposed, this);

        var tasks = packages.Select(async p =>
        {
            var result = await ScanPackageAsync(p.Id, p.Version, cancellationToken);
            return new KeyValuePair<string, VulnerabilityScanResult>($"{p.Id}|{p.Version}", result);
        });

        var results = await Task.WhenAll(tasks);
        return results.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    private async Task ScanAgainstNvdAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        if (!_options.EnableNvdScanning || string.IsNullOrEmpty(_options.NvdApiKey))
        {
            return;
        }

        try
        {
            // Query NVD API for .NET NuGet packages
            var requestUri = $"{_options.NvdBaseUrl}/cves/2.0?keywordSearch={packageId}&keywordExactMatch=true";

            using var request = new HttpRequestMessage(HttpMethod.Get, requestUri);
            if (!string.IsNullOrEmpty(_options.NvdApiKey))
            {
                request.Headers.Add("apikey", _options.NvdApiKey);
            }

            using var response = await _httpClient.SendAsync(request, cancellationToken);
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync(cancellationToken);
                var nvdData = JsonSerializer.Deserialize<NvdResponse>(json);

                if (nvdData?.Vulnerabilities != null)
                {
                    foreach (var vuln in nvdData.Vulnerabilities)
                    {
                        if (IsPackageVersionAffected(packageVersion, vuln))
                        {
                            vulnerabilities.Add(new PackageVulnerability
                            {
                                Id = vuln.Cve?.Id ?? $"NVD-{Guid.NewGuid()}",
                                CveId = vuln.Cve?.Id,
                                Title = vuln.Cve?.Description?.FirstOrDefault()?.Value ?? "Unknown vulnerability",
                                Description = vuln.Cve?.Description?.FirstOrDefault()?.Value ?? string.Empty,
                                Severity = MapCvssToSeverity(vuln.Impact?.BaseMetricV3?.CvssV3?.BaseScore),
                                PublishedDate = vuln.Cve?.Published ?? DateTime.MinValue,
                                ModifiedDate = vuln.Cve?.LastModified ?? DateTime.MinValue,
                                Source = "NVD",
                                References = vuln.Cve?.References?.Select(r => r.Url).ToList() ?? [],
                                AffectedVersions = ExtractAffectedVersions(vuln)
                            });
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to scan against NVD for {PackageId}", packageId);
        }
    }

    private async Task ScanAgainstGitHubAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        if (!_options.EnableGitHubScanning || string.IsNullOrEmpty(_options.GitHubToken))
        {
            return;
        }

        try
        {
            // Query GitHub Security Advisory API
            var requestUri = $"{_options.GitHubApiBaseUrl}/advisories?ecosystem=nuget&affects={packageId}";

            using var request = new HttpRequestMessage(HttpMethod.Get, requestUri);
            request.Headers.Add("Authorization", $"Bearer {_options.GitHubToken}");
            request.Headers.Add("User-Agent", "DotCompute-VulnerabilityScanner");

            using var response = await _httpClient.SendAsync(request, cancellationToken);
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync(cancellationToken);
                var advisories = JsonSerializer.Deserialize<GitHubAdvisory[]>(json);

                if (advisories != null)
                {
                    foreach (var advisory in advisories)
                    {
                        if (IsVersionInRange(packageVersion, advisory.VulnerableVersionRange))
                        {
                            vulnerabilities.Add(new PackageVulnerability
                            {
                                Id = advisory.GhsaId,
                                CveId = advisory.CveId,
                                Title = advisory.Summary,
                                Description = advisory.Description ?? advisory.Summary,
                                Severity = ParseGitHubSeverity(advisory.Severity),
                                PublishedDate = advisory.PublishedAt,
                                ModifiedDate = advisory.UpdatedAt,
                                Source = "GitHub Advisory",
                                References = advisory.References?.Select(r => r.Url).ToList() ?? [],
                                AffectedVersions = [advisory.VulnerableVersionRange]
                            });
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to scan against GitHub Advisory for {PackageId}", packageId);
        }
    }

    private async Task ScanAgainstOssIndexAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        if (!_options.EnableOssIndexScanning)
        {
            return;
        }

        try
        {
            // Query Sonatype OSS Index
            var coordinates = $"pkg:nuget/{packageId}@{packageVersion}";
            var requestUri = $"{_options.OssIndexBaseUrl}/component-report";

            var requestBody = new { coordinates = new[] { coordinates } };
            var json = JsonSerializer.Serialize(requestBody);

            using var request = new HttpRequestMessage(HttpMethod.Post, requestUri)
            {
                Content = new StringContent(json, System.Text.Encoding.UTF8, "application/json")
            };

            if (!string.IsNullOrEmpty(_options.OssIndexUsername) && !string.IsNullOrEmpty(_options.OssIndexToken))
            {
                var credentials = Convert.ToBase64String(
                    System.Text.Encoding.UTF8.GetBytes($"{_options.OssIndexUsername}:{_options.OssIndexToken}"));
                request.Headers.Add("Authorization", $"Basic {credentials}");
            }

            using var response = await _httpClient.SendAsync(request, cancellationToken);
            if (response.IsSuccessStatusCode)
            {
                var responseJson = await response.Content.ReadAsStringAsync(cancellationToken);
                var components = JsonSerializer.Deserialize<OssIndexComponent[]>(responseJson);

                if (components != null)
                {
                    foreach (var component in components)
                    {
                        if (component.Vulnerabilities != null)
                        {
                            foreach (var vuln in component.Vulnerabilities)
                            {
                                vulnerabilities.Add(new PackageVulnerability
                                {
                                    Id = vuln.Id,
                                    CveId = vuln.Cve,
                                    Title = vuln.Title,
                                    Description = vuln.Description ?? vuln.Title,
                                    Severity = MapCvssToSeverity(vuln.CvssScore),
                                    PublishedDate = DateTime.TryParse(vuln.PublishedDate, out var pubDate) ? pubDate : DateTime.MinValue,
                                    ModifiedDate = DateTime.UtcNow,
                                    Source = "OSS Index",
                                    References = [vuln.Reference],
                                    AffectedVersions = [packageVersion]
                                });
                            }
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to scan against OSS Index for {PackageId}", packageId);
        }
    }

    private static async Task ScanAgainstLocalDatabaseAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        await Task.CompletedTask;

        // Scan against local vulnerability database
        // This would typically be loaded from a local file or embedded resource
        // For demonstration, we'll add some example vulnerabilities for common packages

        var localVulns = GetLocalVulnerabilities(packageId, packageVersion);
        vulnerabilities.AddRange(localVulns);
    }

    private void LoadLocalVulnerabilityDatabase()
    {
        try
        {
            if (!string.IsNullOrEmpty(_options.LocalDatabasePath) && File.Exists(_options.LocalDatabasePath))
            {
                var json = File.ReadAllText(_options.LocalDatabasePath);
                var localVulns = JsonSerializer.Deserialize<LocalVulnerabilityDatabase>(json);

                if (localVulns?.Vulnerabilities != null)
                {
                    _logger.LogInfoMessage($"Loaded {localVulns.Vulnerabilities.Count} vulnerabilities from local database");
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to load local vulnerability database from {Path}", _options.LocalDatabasePath);
        }
    }

    private static List<PackageVulnerability> GetLocalVulnerabilities(string packageId, string packageVersion)
    {
        // Example local vulnerabilities for demonstration
        var vulnerabilities = new List<PackageVulnerability>();

        // Example: Newtonsoft.Json known vulnerabilities
        if (packageId.Equals("Newtonsoft.Json", StringComparison.OrdinalIgnoreCase))
        {
            if (Version.TryParse(packageVersion, out var version) && version < new Version(13, 0, 1))
            {
                vulnerabilities.Add(new PackageVulnerability
                {
                    Id = "LOCAL-NEWTONSOFT-001",
                    CveId = "CVE-2024-43484",
                    Title = "Newtonsoft.Json Deserialization Vulnerability",
                    Description = "Newtonsoft.Json prior to version 13.0.1 may be vulnerable to deserialization attacks",
                    Severity = VulnerabilitySeverity.High,
                    PublishedDate = new DateTime(2024, 8, 15),
                    ModifiedDate = new DateTime(2024, 8, 15),
                    Source = "Local Database",
                    References = ["https://github.com/JamesNK/Newtonsoft.Json/security/advisories"],
                    AffectedVersions = ["< 13.0.1"]
                });
            }
        }

        return vulnerabilities;
    }

    private static bool IsPackageVersionAffected(string packageVersion, NvdVulnerability vulnerability)
        // Simplified version checking - in production this would be more sophisticated


        => true; // For demonstration, assume all versions are potentially affected

    private static bool IsVersionInRange(string version, string versionRange)
    {
        // Simplified version range checking - in production this would use proper version parsing
        if (string.IsNullOrEmpty(versionRange))
        {
            return false;
        }

        try
        {
            var packageVersion = Version.Parse(version);

            // Handle simple range patterns like "< 1.2.3", ">= 2.0.0", etc.
            if (versionRange.StartsWith('<'))
            {
                var targetVersion = Version.Parse(versionRange.TrimStart('<', '=', ' '));
                return packageVersion < targetVersion || (versionRange.Contains('=') && packageVersion == targetVersion);
            }
            else if (versionRange.StartsWith('>'))
            {
                var targetVersion = Version.Parse(versionRange.TrimStart('>', '=', ' '));
                return packageVersion > targetVersion || (versionRange.Contains('=') && packageVersion == targetVersion);
            }

            return true;
        }
        catch
        {
            return false;
        }
    }

    private static VulnerabilitySeverity MapCvssToSeverity(double? cvssScore)
    {
        return cvssScore switch
        {
            null => VulnerabilitySeverity.Unknown,
            >= 9.0 => VulnerabilitySeverity.Critical,
            >= 7.0 => VulnerabilitySeverity.High,
            >= 4.0 => VulnerabilitySeverity.Medium,
            >= 0.1 => VulnerabilitySeverity.Low,
            _ => VulnerabilitySeverity.Info
        };
    }

    private static VulnerabilitySeverity ParseGitHubSeverity(string severity)
    {
        return severity?.ToUpperInvariant() switch
        {
            "CRITICAL" => VulnerabilitySeverity.Critical,
            "HIGH" => VulnerabilitySeverity.High,
            "MODERATE" or "MEDIUM" => VulnerabilitySeverity.Medium,
            "LOW" => VulnerabilitySeverity.Low,
            _ => VulnerabilitySeverity.Unknown
        };
    }

    private static List<string> ExtractAffectedVersions(NvdVulnerability vulnerability)
        // Extract version ranges from NVD vulnerability data
        // This is a simplified implementation


        => ["Unknown version range"];

    private static string GetCacheKey(string packageId, string packageVersion) => $"{packageId}|{packageVersion}".ToLowerInvariant();

    private bool IsCacheValid(VulnerabilityReport report) => DateTime.UtcNow - report.ScanTime <= _options.CacheExpiration;

    private static VulnerabilityScanResult CreateScanResult(VulnerabilityReport report, bool fromCache)
    {
        var criticalCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical);
        var highCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High);
        var mediumCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Medium);
        var lowCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Low);

        return new VulnerabilityScanResult
        {
            PackageId = report.PackageId,
            PackageVersion = report.PackageVersion,
            ScanTime = report.ScanTime,
            FromCache = fromCache,
            HasVulnerabilities = report.Vulnerabilities.Count > 0,
            Vulnerabilities = report.Vulnerabilities,
            VulnerabilityCount = report.Vulnerabilities.Count,
            CriticalCount = criticalCount,
            HighCount = highCount,
            MediumCount = mediumCount,
            LowCount = lowCount,
            RiskScore = CalculateRiskScore(criticalCount, highCount, mediumCount, lowCount),
            Sources = report.Sources
        };
    }

    private static int CalculateRiskScore(int critical, int high, int medium, int low) => (critical * 10) + (high * 5) + (medium * 2) + low;

    private void CleanupCache(object? state)
    {
        var expiredKeys = _cache
            .Where(kvp => !IsCacheValid(kvp.Value))
            .Select(kvp => kvp.Key)
            .ToList();

        foreach (var key in expiredKeys)
        {
            _ = _cache.TryRemove(key, out _);
        }

        if (expiredKeys.Count > 0)
        {
            _logger.LogDebugMessage("Cleaned up {expiredKeys.Count} expired vulnerability cache entries");
        }
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (!_disposed)
        {
            _cacheCleanupTimer?.Dispose();
            _httpClient?.Dispose();
            _scanSemaphore?.Dispose();
            _disposed = true;
        }
    }
}

/// <summary>
/// Configuration options for vulnerability scanner.
/// </summary>
public sealed class VulnerabilityScannerOptions
{
    /// <summary>
    /// Gets or sets whether NVD scanning is enabled.
    /// </summary>
    public bool EnableNvdScanning { get; set; } = true;

    /// <summary>
    /// Gets or sets the NVD API key.
    /// </summary>
    public string? NvdApiKey { get; set; }

    /// <summary>
    /// Gets or sets the NVD base URL.
    /// </summary>
    public string NvdBaseUrl { get; set; } = "https://services.nvd.nist.gov/rest/json";

    /// <summary>
    /// Gets or sets whether GitHub Advisory scanning is enabled.
    /// </summary>
    public bool EnableGitHubScanning { get; set; } = true;

    /// <summary>
    /// Gets or sets the GitHub API token.
    /// </summary>
    public string? GitHubToken { get; set; }

    /// <summary>
    /// Gets or sets the GitHub API base URL.
    /// </summary>
    public string GitHubApiBaseUrl { get; set; } = "https://api.github.com";

    /// <summary>
    /// Gets or sets whether OSS Index scanning is enabled.
    /// </summary>
    public bool EnableOssIndexScanning { get; set; } = true;

    /// <summary>
    /// Gets or sets the OSS Index base URL.
    /// </summary>
    public string OssIndexBaseUrl { get; set; } = "https://ossindex.sonatype.org/api/v3";

    /// <summary>
    /// Gets or sets the OSS Index username.
    /// </summary>
    public string? OssIndexUsername { get; set; }

    /// <summary>
    /// Gets or sets the OSS Index token.
    /// </summary>
    public string? OssIndexToken { get; set; }

    /// <summary>
    /// Gets or sets the local vulnerability database path.
    /// </summary>
    public string? LocalDatabasePath { get; set; }

    /// <summary>
    /// Gets or sets the scan timeout.
    /// </summary>
    public TimeSpan ScanTimeout { get; set; } = TimeSpan.FromMinutes(2);

    /// <summary>
    /// Gets or sets the maximum number of concurrent scans.
    /// </summary>
    public int MaxConcurrentScans { get; set; } = 5;

    /// <summary>
    /// Gets or sets the cache expiration time.
    /// </summary>
    public TimeSpan CacheExpiration { get; set; } = TimeSpan.FromHours(6);
}

/// <summary>
/// Result of a vulnerability scan.
/// </summary>
public sealed class VulnerabilityScanResult
{
    /// <summary>
    /// Gets or sets the package ID.
    /// </summary>
    public required string PackageId { get; set; }

    /// <summary>
    /// Gets or sets the package version.
    /// </summary>
    public required string PackageVersion { get; set; }

    /// <summary>
    /// Gets or sets the scan time.
    /// </summary>
    public DateTime ScanTime { get; set; }

    /// <summary>
    /// Gets or sets whether the result was from cache.
    /// </summary>
    public bool FromCache { get; set; }

    /// <summary>
    /// Gets or sets whether the package has known vulnerabilities.
    /// </summary>
    public bool HasVulnerabilities { get; set; }

    /// <summary>
    /// Gets or sets the list of vulnerabilities.
    /// </summary>
    public List<PackageVulnerability> Vulnerabilities { get; set; } = [];

    /// <summary>
    /// Gets or sets the total vulnerability count.
    /// </summary>
    public int VulnerabilityCount { get; set; }

    /// <summary>
    /// Gets or sets the critical vulnerability count.
    /// </summary>
    public int CriticalCount { get; set; }

    /// <summary>
    /// Gets or sets the high vulnerability count.
    /// </summary>
    public int HighCount { get; set; }

    /// <summary>
    /// Gets or sets the medium vulnerability count.
    /// </summary>
    public int MediumCount { get; set; }

    /// <summary>
    /// Gets or sets the low vulnerability count.
    /// </summary>
    public int LowCount { get; set; }

    /// <summary>
    /// Gets or sets the calculated risk score.
    /// </summary>
    public int RiskScore { get; set; }

    /// <summary>
    /// Gets or sets the vulnerability sources.
    /// </summary>
    public List<string> Sources { get; set; } = [];
}

/// <summary>
/// Represents a package vulnerability.
/// </summary>
public sealed class PackageVulnerability
{
    /// <summary>
    /// Gets or sets the vulnerability ID.
    /// </summary>
    public required string Id { get; set; }

    /// <summary>
    /// Gets or sets the CVE ID if applicable.
    /// </summary>
    public string? CveId { get; set; }

    /// <summary>
    /// Gets or sets the vulnerability title.
    /// </summary>
    public required string Title { get; set; }

    /// <summary>
    /// Gets or sets the vulnerability description.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the vulnerability severity.
    /// </summary>
    public VulnerabilitySeverity Severity { get; set; }

    /// <summary>
    /// Gets or sets the published date.
    /// </summary>
    public DateTime PublishedDate { get; set; }

    /// <summary>
    /// Gets or sets the modified date.
    /// </summary>
    public DateTime ModifiedDate { get; set; }

    /// <summary>
    /// Gets or sets the vulnerability source.
    /// </summary>
    public required string Source { get; set; }

    /// <summary>
    /// Gets or sets the reference URLs.
    /// </summary>
    public List<string> References { get; set; } = [];

    /// <summary>
    /// Gets or sets the affected version ranges.
    /// </summary>
    public List<string> AffectedVersions { get; set; } = [];
}

/// <summary>
/// Vulnerability severity levels.
/// </summary>
public enum VulnerabilitySeverity
{
    /// <summary>
    /// Unknown severity.
    /// </summary>
    Unknown = 0,

    /// <summary>
    /// Informational severity.
    /// </summary>
    Info = 1,

    /// <summary>
    /// Low severity.
    /// </summary>
    Low = 2,

    /// <summary>
    /// Medium severity.
    /// </summary>
    Medium = 3,

    /// <summary>
    /// High severity.
    /// </summary>
    High = 4,

    /// <summary>
    /// Critical severity.
    /// </summary>
    Critical = 5
}

// Internal data transfer objects for API responses

internal sealed class VulnerabilityReport
{
    public required string PackageId { get; set; }
    public required string PackageVersion { get; set; }
    public DateTime ScanTime { get; set; }
    public List<PackageVulnerability> Vulnerabilities { get; set; } = [];
    public List<string> Sources { get; set; } = [];
}

internal sealed class NvdResponse
{
    public NvdVulnerability[]? Vulnerabilities { get; set; }
}

internal sealed class NvdVulnerability
{
    public NvdCve? Cve { get; set; }
    public NvdImpact? Impact { get; set; }
}

internal sealed class NvdCve
{
    public string? Id { get; set; }
    public DateTime Published { get; set; }
    public DateTime LastModified { get; set; }
    public NvdDescription[]? Description { get; set; }
    public NvdReference[]? References { get; set; }
}

internal sealed class NvdDescription
{
    public string? Value { get; set; }
}

internal sealed class NvdReference
{
    public required string Url { get; set; }
}

internal sealed class NvdImpact
{
    public NvdBaseMetricV3? BaseMetricV3 { get; set; }
}

internal sealed class NvdBaseMetricV3
{
    public NvdCvssV3? CvssV3 { get; set; }
}

internal sealed class NvdCvssV3
{
    public double BaseScore { get; set; }
}

internal sealed class GitHubAdvisory
{
    public required string GhsaId { get; set; }
    public string? CveId { get; set; }
    public required string Summary { get; set; }
    public string? Description { get; set; }
    public required string Severity { get; set; }
    public DateTime PublishedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public required string VulnerableVersionRange { get; set; }
    public GitHubReference[]? References { get; set; }
}

internal sealed class GitHubReference
{
    public required string Url { get; set; }
}

internal sealed class OssIndexComponent
{
    public OssIndexVulnerability[]? Vulnerabilities { get; set; }
}

internal sealed class OssIndexVulnerability
{
    public required string Id { get; set; }
    public string? Cve { get; set; }
    public required string Title { get; set; }
    public string? Description { get; set; }
    public double CvssScore { get; set; }
    public string? PublishedDate { get; set; }
    public required string Reference { get; set; }
}

internal sealed class LocalVulnerabilityDatabase
{
    public List<PackageVulnerability>? Vulnerabilities { get; set; }
}
