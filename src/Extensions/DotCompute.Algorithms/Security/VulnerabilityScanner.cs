
// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using DotCompute.Algorithms.Logging;
using DotCompute.Algorithms.Security.Options;
using DotCompute.Algorithms.Security.Results;
using DotCompute.Algorithms.Security.Vulnerabilities;
using DotCompute.Algorithms.Security.Enums;
using DotCompute.Algorithms.Security.Reports;
using DotCompute.Algorithms.Security.DataTransfer.Nvd;
using DotCompute.Algorithms.Security.DataTransfer.GitHub;
using DotCompute.Algorithms.Security.DataTransfer.OssIndex;
using DotCompute.Algorithms.Security.Database;

namespace DotCompute.Algorithms.Security;


/// <summary>
/// Advanced vulnerability scanner that checks packages against vulnerability databases.
/// </summary>
public sealed partial class VulnerabilityScanner : IDisposable
{
    private readonly ILogger<VulnerabilityScanner> _logger;
    private readonly VulnerabilityScannerOptions _options;
    private readonly HttpClient _httpClient;
    private readonly ConcurrentDictionary<string, VulnerabilityReport> _cache;
    private readonly SemaphoreSlim _scanSemaphore;
    private readonly Timer _cacheCleanupTimer;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="VulnerabilityScanner"/> class.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    /// <param name="options">Configuration options.</param>
    public VulnerabilityScanner(ILogger<VulnerabilityScanner> logger, VulnerabilityScannerOptions? options = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _options = options ?? new VulnerabilityScannerOptions();
        _httpClient = new HttpClient { Timeout = _options.ScanTimeout };
        _cache = new ConcurrentDictionary<string, VulnerabilityReport>();
        _scanSemaphore = new SemaphoreSlim(_options.MaxConcurrentScans, _options.MaxConcurrentScans);

        // Setup periodic cache cleanup
        _cacheCleanupTimer = new Timer(CleanupCache, null, TimeSpan.FromHours(1), TimeSpan.FromHours(1));

        LoadLocalVulnerabilityDatabase();
    }

    /// <summary>
    /// Scans a package for known vulnerabilities.
    /// </summary>
    /// <param name="packageId">The package ID to scan.</param>
    /// <param name="packageVersion">The package version.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The vulnerability scan result.</returns>
    public async Task<VulnerabilityScanResult> ScanPackageAsync(
        string packageId,
        string packageVersion,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(packageId);
        ArgumentException.ThrowIfNullOrWhiteSpace(packageVersion);
        ObjectDisposedException.ThrowIf(_disposed, this);

        await _scanSemaphore.WaitAsync(cancellationToken);
        try
        {
            _logger.LogDebugMessage("Scanning package for vulnerabilities: {PackageId} {packageId, packageVersion}");

            var cacheKey = GetCacheKey(packageId, packageVersion);
            if (_cache.TryGetValue(cacheKey, out var cachedReport) && IsCacheValid(cachedReport))
            {
                _logger.LogDebugMessage("Using cached vulnerability report for {PackageId} {packageId, packageVersion}");
                return CreateScanResult(cachedReport, true);
            }

            var vulnerabilities = new List<PackageVulnerability>();

            // Scan against multiple vulnerability sources
            await ScanAgainstNvdAsync(packageId, packageVersion, vulnerabilities, cancellationToken);
            await ScanAgainstGitHubAsync(packageId, packageVersion, vulnerabilities, cancellationToken);
            await ScanAgainstOssIndexAsync(packageId, packageVersion, vulnerabilities, cancellationToken);
            await ScanAgainstLocalDatabaseAsync(packageId, packageVersion, vulnerabilities, cancellationToken);

            // Remove duplicates based on CVE ID
            vulnerabilities = [.. vulnerabilities
            .GroupBy(v => v.CveId ?? v.Id)
            .Select(g => g.OrderByDescending(v => v.Severity).First())];

            var report = new VulnerabilityReport
            {
                PackageId = packageId,
                PackageVersion = packageVersion,
                ScanTime = DateTime.UtcNow,
                Vulnerabilities = vulnerabilities,
                Sources = ["NVD", "GitHub", "OSS Index", "Local"]
            };

            // Cache the report
            _ = _cache.TryAdd(cacheKey, report);

            var result = CreateScanResult(report, false);

            _logger.LogInfoMessage($"Vulnerability scan completed for {packageId} {packageVersion}: {vulnerabilities.Count} vulnerabilities found");

            return result;
        }
        finally
        {
            _ = _scanSemaphore.Release();
        }
    }

    /// <summary>
    /// Scans multiple packages concurrently.
    /// </summary>
    /// <param name="packages">The packages to scan.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Dictionary of scan results keyed by package ID.</returns>
    public async Task<Dictionary<string, VulnerabilityScanResult>> ScanMultiplePackagesAsync(
        IEnumerable<(string Id, string Version)> packages,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(packages);
        ObjectDisposedException.ThrowIf(_disposed, this);

        var tasks = packages.Select(async p =>
        {
            var result = await ScanPackageAsync(p.Id, p.Version, cancellationToken);
            return new KeyValuePair<string, VulnerabilityScanResult>($"{p.Id}|{p.Version}", result);
        });

        var results = await Task.WhenAll(tasks);
        return results.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    [UnconditionalSuppressMessage("Trimming", "IL2026:Members annotated with RequiresUnreferencedCodeAttribute",
        Justification = "JSON deserialization for diagnostics only, types are preserved")]
    [UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCodeAttribute",
        Justification = "JSON deserialization for diagnostics only")]
    private async Task ScanAgainstNvdAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        if (!_options.EnableNvdScanning || string.IsNullOrEmpty(_options.NvdApiKey))
        {
            return;
        }

        try
        {
            // Query NVD API for .NET NuGet packages
            var requestUri = $"{_options.NvdBaseUrl}/cves/2.0?keywordSearch={packageId}&keywordExactMatch=true";

            using var request = new HttpRequestMessage(HttpMethod.Get, requestUri);
            if (!string.IsNullOrEmpty(_options.NvdApiKey))
            {
                request.Headers.Add("apikey", _options.NvdApiKey);
            }

            using var response = await _httpClient.SendAsync(request, cancellationToken);
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync(cancellationToken);
                var nvdData = JsonSerializer.Deserialize<NvdResponse>(json);

                if (nvdData?.Vulnerabilities != null)
                {
                    foreach (var vuln in nvdData.Vulnerabilities)
                    {
                        if (IsPackageVersionAffected(packageVersion, vuln))
                        {
                            var vulnerability = new PackageVulnerability
                            {
                                Id = vuln.Cve?.Id ?? $"NVD-{Guid.NewGuid()}",
                                CveId = vuln.Cve?.Id,
                                Title = vuln.Cve?.Description?.FirstOrDefault()?.Value ?? "Unknown vulnerability",
                                Description = vuln.Cve?.Description?.FirstOrDefault()?.Value ?? string.Empty,
                                Severity = MapCvssToSeverity(vuln.Impact?.BaseMetricV3?.CvssV3?.BaseScore),
                                PublishedDate = vuln.Cve?.Published ?? DateTime.MinValue,
                                ModifiedDate = vuln.Cve?.LastModified ?? DateTime.MinValue,
                                Source = "NVD"
                            };

                            // Populate References collection
                            var references = vuln.Cve?.References?.Select(r => r.Url).ToList() ?? [];
                            foreach (var reference in references)
                            {
                                vulnerability.References.Add(reference);
                            }

                            // Populate AffectedVersions collection
                            var affectedVersions = ExtractAffectedVersions(vuln);
                            foreach (var version in affectedVersions)
                            {
                                vulnerability.AffectedVersions.Add(version);
                            }

                            vulnerabilities.Add(vulnerability);
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            LogNvdScanFailed(ex, packageId);
        }
    }

    [UnconditionalSuppressMessage("Trimming", "IL2026:Members annotated with RequiresUnreferencedCodeAttribute",
        Justification = "JSON deserialization for diagnostics only, types are preserved")]
    [UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCodeAttribute",
        Justification = "JSON deserialization for diagnostics only")]
    private async Task ScanAgainstGitHubAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        if (!_options.EnableGitHubScanning || string.IsNullOrEmpty(_options.GitHubToken))
        {
            return;
        }

        try
        {
            // Query GitHub Security Advisory API
            var requestUri = $"{_options.GitHubApiBaseUrl}/advisories?ecosystem=nuget&affects={packageId}";

            using var request = new HttpRequestMessage(HttpMethod.Get, requestUri);
            request.Headers.Add("Authorization", $"Bearer {_options.GitHubToken}");
            request.Headers.Add("User-Agent", "DotCompute-VulnerabilityScanner");

            using var response = await _httpClient.SendAsync(request, cancellationToken);
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync(cancellationToken);
                var advisories = JsonSerializer.Deserialize<GitHubAdvisory[]>(json);

                if (advisories != null)
                {
                    foreach (var advisory in advisories)
                    {
                        if (IsVersionInRange(packageVersion, advisory.VulnerableVersionRange))
                        {
                            var vulnerability = new PackageVulnerability
                            {
                                Id = advisory.GhsaId,
                                CveId = advisory.CveId,
                                Title = advisory.Summary,
                                Description = advisory.Description ?? advisory.Summary,
                                Severity = ParseGitHubSeverity(advisory.Severity),
                                PublishedDate = advisory.PublishedAt,
                                ModifiedDate = advisory.UpdatedAt,
                                Source = "GitHub Advisory"
                            };

                            // Populate References collection
                            var references = advisory.References?.Select(r => r.Url).ToList() ?? [];
                            foreach (var reference in references)
                            {
                                vulnerability.References.Add(reference);
                            }

                            // Populate AffectedVersions collection
                            vulnerability.AffectedVersions.Add(advisory.VulnerableVersionRange);

                            vulnerabilities.Add(vulnerability);
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            LogGitHubScanFailed(ex, packageId);
        }
    }

    [UnconditionalSuppressMessage("Trimming", "IL2026:Members annotated with RequiresUnreferencedCodeAttribute",
        Justification = "JSON serialization/deserialization for diagnostics only, types are preserved")]
    [UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCodeAttribute",
        Justification = "JSON serialization/deserialization for diagnostics only")]
    private async Task ScanAgainstOssIndexAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        if (!_options.EnableOssIndexScanning)
        {
            return;
        }

        try
        {
            // Query Sonatype OSS Index
            var coordinates = $"pkg:nuget/{packageId}@{packageVersion}";
            var requestUri = $"{_options.OssIndexBaseUrl}/component-report";

            var requestBody = new { coordinates = new[] { coordinates } };
            var json = JsonSerializer.Serialize(requestBody);

            using var request = new HttpRequestMessage(HttpMethod.Post, requestUri)
            {
                Content = new StringContent(json, System.Text.Encoding.UTF8, "application/json")
            };

            if (!string.IsNullOrEmpty(_options.OssIndexUsername) && !string.IsNullOrEmpty(_options.OssIndexToken))
            {
                var credentials = Convert.ToBase64String(
                    System.Text.Encoding.UTF8.GetBytes($"{_options.OssIndexUsername}:{_options.OssIndexToken}"));
                request.Headers.Add("Authorization", $"Basic {credentials}");
            }

            using var response = await _httpClient.SendAsync(request, cancellationToken);
            if (response.IsSuccessStatusCode)
            {
                var responseJson = await response.Content.ReadAsStringAsync(cancellationToken);
                var components = JsonSerializer.Deserialize<OssIndexComponent[]>(responseJson);

                if (components != null)
                {
                    foreach (var component in components)
                    {
                        if (component.Vulnerabilities != null)
                        {
                            foreach (var vuln in component.Vulnerabilities)
                            {
                                var vulnerability = new PackageVulnerability
                                {
                                    Id = vuln.Id,
                                    CveId = vuln.Cve,
                                    Title = vuln.Title,
                                    Description = vuln.Description ?? vuln.Title,
                                    Severity = MapCvssToSeverity(vuln.CvssScore),
                                    PublishedDate = DateTime.TryParse(vuln.PublishedDate, out var pubDate) ? pubDate : DateTime.MinValue,
                                    ModifiedDate = DateTime.UtcNow,
                                    Source = "OSS Index"
                                };

                                // Populate References collection
                                vulnerability.References.Add(vuln.Reference);

                                // Populate AffectedVersions collection
                                vulnerability.AffectedVersions.Add(packageVersion);

                                vulnerabilities.Add(vulnerability);
                            }
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            LogOssIndexScanFailed(ex, packageId);
        }
    }

    private static async Task ScanAgainstLocalDatabaseAsync(
        string packageId,
        string packageVersion,
        List<PackageVulnerability> vulnerabilities,
        CancellationToken cancellationToken)
    {
        await Task.CompletedTask;

        // Scan against local vulnerability database
        // This would typically be loaded from a local file or embedded resource
        // For demonstration, we'll add some example vulnerabilities for common packages

        var localVulns = GetLocalVulnerabilities(packageId, packageVersion);
        vulnerabilities.AddRange(localVulns);
    }

    [UnconditionalSuppressMessage("Trimming", "IL2026:Members annotated with RequiresUnreferencedCodeAttribute",
        Justification = "JSON deserialization for diagnostics only, types are preserved")]
    [UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCodeAttribute",
        Justification = "JSON deserialization for diagnostics only")]
    private void LoadLocalVulnerabilityDatabase()
    {
        try
        {
            if (!string.IsNullOrEmpty(_options.LocalDatabasePath) && File.Exists(_options.LocalDatabasePath))
            {
                var json = File.ReadAllText(_options.LocalDatabasePath);
                var localVulns = JsonSerializer.Deserialize<LocalVulnerabilityDatabase>(json);

                if (localVulns?.Vulnerabilities != null)
                {
                    _logger.LogInfoMessage($"Loaded {localVulns.Vulnerabilities.Count} vulnerabilities from local database");
                }
            }
        }
        catch (Exception ex)
        {
            LogLocalDatabaseLoadFailed(ex, _options.LocalDatabasePath);
        }
    }

    private static List<PackageVulnerability> GetLocalVulnerabilities(string packageId, string packageVersion)
    {
        // Example local vulnerabilities for demonstration
        var vulnerabilities = new List<PackageVulnerability>();

        // Example: Newtonsoft.Json known vulnerabilities
        if (packageId.Equals("Newtonsoft.Json", StringComparison.OrdinalIgnoreCase))
        {
            if (Version.TryParse(packageVersion, out var version) && version < new Version(13, 0, 1))
            {
                var vulnerability = new PackageVulnerability
                {
                    Id = "LOCAL-NEWTONSOFT-001",
                    CveId = "CVE-2024-43484",
                    Title = "Newtonsoft.Json Deserialization Vulnerability",
                    Description = "Newtonsoft.Json prior to version 13.0.1 may be vulnerable to deserialization attacks",
                    Severity = VulnerabilitySeverity.High,
                    PublishedDate = new DateTime(2024, 8, 15),
                    ModifiedDate = new DateTime(2024, 8, 15),
                    Source = "Local Database"
                };

                vulnerability.References.Add("https://github.com/JamesNK/Newtonsoft.Json/security/advisories");
                vulnerability.AffectedVersions.Add("< 13.0.1");

                vulnerabilities.Add(vulnerability);
            }
        }

        return vulnerabilities;
    }

    private static bool IsPackageVersionAffected(string packageVersion, NvdVulnerability vulnerability)
        // Simplified version checking - in production this would be more sophisticated





        => true; // For demonstration, assume all versions are potentially affected

    private static bool IsVersionInRange(string version, string versionRange)
    {
        // Simplified version range checking - in production this would use proper version parsing
        if (string.IsNullOrEmpty(versionRange))
        {
            return false;
        }

        try
        {
            var packageVersion = Version.Parse(version);

            // Handle simple range patterns like "< 1.2.3", ">= 2.0.0", etc.
            // Using char overloads for ASCII characters (CA1865) - ordinal comparison is implicit for ASCII chars
#pragma warning disable XFIX002 // String comparison using char overload is ordinal by nature for ASCII
            if (versionRange.StartsWith('<'))
            {
                var targetVersion = Version.Parse(versionRange.TrimStart('<', '=', ' '));
                return packageVersion < targetVersion || (versionRange.Contains('=', StringComparison.Ordinal) && packageVersion == targetVersion);
            }
            else if (versionRange.StartsWith('>'))
            {
                var targetVersion = Version.Parse(versionRange.TrimStart('>', '=', ' '));
                return packageVersion > targetVersion || (versionRange.Contains('=', StringComparison.Ordinal) && packageVersion == targetVersion);
            }
#pragma warning restore XFIX002

            return true;
        }
        catch
        {
            return false;
        }
    }

    private static VulnerabilitySeverity MapCvssToSeverity(double? cvssScore)
    {
        return cvssScore switch
        {
            null => VulnerabilitySeverity.Unknown,
            >= 9.0 => VulnerabilitySeverity.Critical,
            >= 7.0 => VulnerabilitySeverity.High,
            >= 4.0 => VulnerabilitySeverity.Medium,
            >= 0.1 => VulnerabilitySeverity.Low,
            _ => VulnerabilitySeverity.Info
        };
    }

    private static VulnerabilitySeverity ParseGitHubSeverity(string severity)
    {
        return severity?.ToUpperInvariant() switch
        {
            "CRITICAL" => VulnerabilitySeverity.Critical,
            "HIGH" => VulnerabilitySeverity.High,
            "MODERATE" or "MEDIUM" => VulnerabilitySeverity.Medium,
            "LOW" => VulnerabilitySeverity.Low,
            _ => VulnerabilitySeverity.Unknown
        };
    }

    private static List<string> ExtractAffectedVersions(NvdVulnerability vulnerability)
        // Extract version ranges from NVD vulnerability data
        // This is a simplified implementation





        => ["Unknown version range"];

    private static string GetCacheKey(string packageId, string packageVersion) => $"{packageId}|{packageVersion}".ToUpperInvariant();

    private bool IsCacheValid(VulnerabilityReport report) => DateTime.UtcNow - report.ScanTime <= _options.CacheExpiration;

    private static VulnerabilityScanResult CreateScanResult(VulnerabilityReport report, bool fromCache)
    {
        var criticalCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical);
        var highCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High);
        var mediumCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Medium);
        var lowCount = report.Vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Low);

        return new VulnerabilityScanResult
        {
            PackageId = report.PackageId,
            PackageVersion = report.PackageVersion,
            ScanTime = report.ScanTime,
            FromCache = fromCache,
            HasVulnerabilities = report.Vulnerabilities.Count > 0,
            Vulnerabilities = report.Vulnerabilities,
            VulnerabilityCount = report.Vulnerabilities.Count,
            CriticalCount = criticalCount,
            HighCount = highCount,
            MediumCount = mediumCount,
            LowCount = lowCount,
            RiskScore = CalculateRiskScore(criticalCount, highCount, mediumCount, lowCount),
            Sources = report.Sources
        };
    }

    private static int CalculateRiskScore(int critical, int high, int medium, int low) => (critical * 10) + (high * 5) + (medium * 2) + low;

    private void CleanupCache(object? state)
    {
        var expiredKeys = _cache
            .Where(kvp => !IsCacheValid(kvp.Value))
            .Select(kvp => kvp.Key)
            .ToList();

        foreach (var key in expiredKeys)
        {
            _ = _cache.TryRemove(key, out _);
        }

        if (expiredKeys.Count > 0)
        {
            _logger.LogDebugMessage("Cleaned up {expiredKeys.Count} expired vulnerability cache entries");
        }
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (!_disposed)
        {
            _cacheCleanupTimer?.Dispose();
            _httpClient?.Dispose();
            _scanSemaphore?.Dispose();
            _disposed = true;
        }
    }

    #region LoggerMessage Delegates

    [LoggerMessage(Level = LogLevel.Warning, Message = "Failed to scan against NVD for {PackageId}")]
    private partial void LogNvdScanFailed(Exception ex, string packageId);

    [LoggerMessage(Level = LogLevel.Warning, Message = "Failed to scan against GitHub Advisory for {PackageId}")]
    private partial void LogGitHubScanFailed(Exception ex, string packageId);

    [LoggerMessage(Level = LogLevel.Warning, Message = "Failed to scan against OSS Index for {PackageId}")]
    private partial void LogOssIndexScanFailed(Exception ex, string packageId);

    [LoggerMessage(Level = LogLevel.Warning, Message = "Failed to load local vulnerability database from {Path}")]
    private partial void LogLocalDatabaseLoadFailed(Exception ex, string? path);

    #endregion
}




