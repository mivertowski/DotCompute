// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using DotCompute.Algorithms.Management.Configuration;
using Microsoft.Extensions.Logging;

namespace DotCompute.Algorithms.Types.Security;

/// <summary>
/// Provides malware scanning capabilities for algorithm plugins.
/// </summary>
public sealed class MalwareScanner : IDisposable, IAsyncDisposable
{
    private readonly ILogger _logger;
    private readonly AlgorithmPluginManagerOptions _options;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="MalwareScanner"/> class.
    /// </summary>
    /// <param name="logger">Logger for diagnostics.</param>
    /// <param name="options">Configuration options.</param>
    public MalwareScanner(ILogger logger, AlgorithmPluginManagerOptions options)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _options = options ?? throw new ArgumentNullException(nameof(options));
    }

    /// <summary>
    /// Scans an assembly for malware.
    /// </summary>
    /// <param name="assemblyPath">Path to the assembly to scan.</param>
    /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
    /// <returns>The scan result.</returns>
    public async Task<MalwareScanResult> ScanAssemblyAsync(string assemblyPath, CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        ArgumentException.ThrowIfNullOrWhiteSpace(assemblyPath);

        var stopwatch = Stopwatch.StartNew();
        var threats = new List<DetectedThreat>();
        var warnings = new List<string>();
        var errors = new List<string>();

        try
        {
            _logger.LogInformation("Starting malware scan for assembly: {AssemblyPath}", assemblyPath);

            // Verify file exists
            if (!File.Exists(assemblyPath))
            {
                errors.Add($"Assembly file not found: {assemblyPath}");
                return CreateFailureResult(stopwatch.Elapsed, errors, warnings);
            }

            // Basic heuristic checks
            await PerformBasicHeuristicChecksAsync(assemblyPath, threats, warnings, errors, cancellationToken);

            // Assembly metadata analysis
            await PerformAssemblyMetadataAnalysisAsync(assemblyPath, threats, warnings, errors, cancellationToken);

            // File signature analysis
            await PerformFileSignatureAnalysisAsync(assemblyPath, threats, warnings, errors, cancellationToken);

            stopwatch.Stop();

            var isMalwareDetected = threats.Count > 0;
            var confidenceScore = CalculateConfidenceScore(threats);

            _logger.LogInformation(
                "Malware scan completed for {AssemblyPath}. Malware detected: {IsMalwareDetected}, Confidence: {ConfidenceScore:F2}",
                assemblyPath, isMalwareDetected, confidenceScore);

            var fileHash = await ComputeFileHashAsync(assemblyPath, cancellationToken);

            return new MalwareScanResult
            {
                IsSuccess = true,
                IsMalwareDetected = isMalwareDetected,
                ConfidenceScore = confidenceScore,
                DetectedThreats = threats.AsReadOnly(),
                Warnings = warnings.AsReadOnly(),
                Errors = errors.AsReadOnly(),
                ScanDuration = stopwatch.Elapsed,
                DetectedPatterns = threats.Where(t => !string.IsNullOrEmpty(t.Category) && t.Category.Contains("Pattern"))
                    .Select(t => t.Name).ToList().AsReadOnly(),
                BehavioralFlags = threats.Where(t => !string.IsNullOrEmpty(t.Category) && t.Category.Contains("Behavioral"))
                    .Select(t => t.Description).ToList().AsReadOnly(),
                FileHash = fileHash,
                ScanMethods = ["Heuristic", "Metadata", "Signature"],
                Metadata = new Dictionary<string, object>
                {
                    ["assemblySize"] = new FileInfo(assemblyPath).Length,
                    ["scanEngine"] = "DotCompute.Heuristic.v1.0",
                    ["threatCount"] = threats.Count,
                    ["warningCount"] = warnings.Count
                }
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error occurred during malware scan of {AssemblyPath}", assemblyPath);
            errors.Add($"Scan error: {ex.Message}");
            return CreateFailureResult(stopwatch.Elapsed, errors, warnings);
        }
    }

    /// <summary>
    /// Performs basic heuristic checks on the assembly.
    /// </summary>
    private async Task PerformBasicHeuristicChecksAsync(string assemblyPath, List<DetectedThreat> threats, List<string> warnings, List<string> errors, CancellationToken cancellationToken)
    {
        await Task.CompletedTask; // Make async for consistency

        try
        {
            var fileInfo = new FileInfo(assemblyPath);

            // Check file size (suspicious if too small or too large)
            if (fileInfo.Length < 1024)
            {
                warnings.Add("Assembly file is unusually small");
            }
            else if (fileInfo.Length > 50 * 1024 * 1024) // 50MB
            {
                warnings.Add("Assembly file is unusually large");
            }

            // Check for suspicious file attributes
            if (fileInfo.Attributes.HasFlag(FileAttributes.Hidden))
            {
                threats.Add(new DetectedThreat
                {
                    Name = "HiddenFile",
                    Category = "Behavioral Analysis",
                    Severity = ThreatSeverity.Low,
                    Description = "Assembly has hidden file attribute",
                    Location = assemblyPath,
                    ConfidenceScore = 0.3
                });
            }
        }
        catch (Exception ex)
        {
            errors.Add($"Basic heuristic check failed: {ex.Message}");
        }
    }

    /// <summary>
    /// Performs assembly metadata analysis.
    /// </summary>
    private async Task PerformAssemblyMetadataAnalysisAsync(string assemblyPath, List<DetectedThreat> threats, List<string> warnings, List<string> errors, CancellationToken cancellationToken)
    {
        await Task.CompletedTask; // Make async for consistency

        try
        {
            var assembly = Assembly.LoadFrom(assemblyPath);
            var types = assembly.GetTypes();

            // Check for suspicious type names
            var suspiciousPatterns = new[] { "malware", "virus", "trojan", "exploit", "hack", "inject" };

            foreach (var type in types)
            {
                var typeName = type.Name.ToLowerInvariant();
                foreach (var pattern in suspiciousPatterns)
                {
                    if (typeName.Contains(pattern))
                    {
                        threats.Add(new DetectedThreat
                        {
                            Name = "SuspiciousTypeName",
                            Category = "Pattern Detection",
                            Severity = ThreatSeverity.Medium,
                            Description = $"Type name contains suspicious pattern: {pattern}",
                            Location = $"{assemblyPath}:{type.FullName}",
                            ConfidenceScore = 0.6
                        });
                    }
                }
            }

            // Check for excessive P/Invoke usage (potential indicator of system tampering)
            var pinvokeCount = 0;
            foreach (var type in types)
            {
                var methods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
                pinvokeCount += methods.Count(m => m.GetCustomAttribute<System.Runtime.InteropServices.DllImportAttribute>() != null);
            }

            if (pinvokeCount > 20) // Arbitrary threshold
            {
                warnings.Add($"Assembly contains {pinvokeCount} P/Invoke declarations, which may indicate low-level system access");
            }
        }
        catch (BadImageFormatException)
        {
            errors.Add("Assembly appears to be corrupted or invalid");
        }
        catch (ReflectionTypeLoadException ex)
        {
            warnings.Add($"Some types could not be loaded during analysis: {ex.Message}");
        }
        catch (Exception ex)
        {
            errors.Add($"Assembly metadata analysis failed: {ex.Message}");
        }
    }

    /// <summary>
    /// Performs file signature analysis.
    /// </summary>
    private async Task PerformFileSignatureAnalysisAsync(string assemblyPath, List<DetectedThreat> threats, List<string> warnings, List<string> errors, CancellationToken cancellationToken)
    {
        try
        {
            using var fileStream = File.OpenRead(assemblyPath);
            using var sha256 = SHA256.Create();

            var hashBytes = await sha256.ComputeHashAsync(fileStream, cancellationToken);
            var hashString = Convert.ToHexString(hashBytes);

            // In a real implementation, you would check against known malware hashes
            // For now, we'll just log the hash for reference
            _logger.LogDebug("Assembly SHA256 hash: {Hash}", hashString);

            // Check file header for .NET assembly signature
            fileStream.Seek(0, SeekOrigin.Begin);
            var headerBytes = new byte[4];
            await fileStream.ReadAsync(headerBytes, cancellationToken);

            // Check for DOS header (MZ signature)
            if (headerBytes[0] != 0x4D || headerBytes[1] != 0x5A) // "MZ"
            {
                warnings.Add("File does not have expected DOS header signature");
            }
        }
        catch (Exception ex)
        {
            errors.Add($"File signature analysis failed: {ex.Message}");
        }
    }

    /// <summary>
    /// Calculates the overall confidence score based on detected threats.
    /// </summary>
    private static double CalculateConfidenceScore(List<DetectedThreat> threats)
    {
        if (threats.Count == 0)
        {
            return 0.0; // No threats detected
        }

        // Calculate weighted average confidence based on threat severity
        var totalWeight = 0.0;
        var weightedSum = 0.0;

        foreach (var threat in threats)
        {
            var weight = threat.Severity switch
            {
                ThreatSeverity.Critical => 4.0,
                ThreatSeverity.High => 3.0,
                ThreatSeverity.Medium => 2.0,
                ThreatSeverity.Low => 1.0,
                _ => 1.0
            };

            totalWeight += weight;
            weightedSum += threat.ConfidenceScore * weight;
        }

        return totalWeight > 0 ? weightedSum / totalWeight : 0.0;
    }

    /// <summary>
    /// Creates a failure result for the scan.
    /// </summary>
    private static MalwareScanResult CreateFailureResult(TimeSpan duration, List<string> errors, List<string> warnings)
    {
        return new MalwareScanResult
        {
            IsSuccess = false,
            IsMalwareDetected = false,
            ConfidenceScore = 0.0,
            DetectedThreats = Array.Empty<DetectedThreat>(),
            Warnings = warnings.AsReadOnly(),
            Errors = errors.AsReadOnly(),
            ScanDuration = duration,
            ScanMethods = ["Failed"],
            DetectedPatterns = Array.Empty<string>(),
            BehavioralFlags = Array.Empty<string>()
        };
    }

    /// <summary>
    /// Scans multiple assemblies concurrently for malware.
    /// </summary>
    /// <param name="assemblyPaths">Paths to the assemblies to scan.</param>
    /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
    /// <returns>Dictionary of scan results keyed by assembly path.</returns>
    public async Task<Dictionary<string, MalwareScanResult>> ScanMultipleAssembliesAsync(
        IEnumerable<string> assemblyPaths,
        CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        ArgumentNullException.ThrowIfNull(assemblyPaths);

        var tasks = assemblyPaths.Select(async path =>
        {
            try
            {
                var result = await ScanAssemblyAsync(path, cancellationToken);
                return new KeyValuePair<string, MalwareScanResult>(path, result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to scan assembly: {AssemblyPath}", path);
                var failureResult = CreateFailureResult(TimeSpan.Zero, [ex.Message], []);
                return new KeyValuePair<string, MalwareScanResult>(path, failureResult);
            }
        });

        var results = await Task.WhenAll(tasks);
        return results.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    /// <summary>
    /// Computes SHA256 hash of the specified file.
    /// </summary>
    /// <param name="filePath">Path to the file to hash.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>SHA256 hash as hexadecimal string.</returns>
    private static async Task<string> ComputeFileHashAsync(string filePath, CancellationToken cancellationToken)
    {
        using var sha256 = SHA256.Create();
        using var fileStream = File.OpenRead(filePath);
        var hashBytes = await sha256.ComputeHashAsync(fileStream, cancellationToken);
        return Convert.ToHexString(hashBytes);
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            _logger.LogDebug("MalwareScanner disposed");
        }
    }

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        if (!_disposed)
        {
            _disposed = true;
            _logger.LogDebug("MalwareScanner disposed asynchronously");
            await Task.CompletedTask;
        }
    }
}