// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Diagnostics;
using global::System.Security.Cryptography;
using Microsoft.Extensions.Logging;

namespace DotCompute.Algorithms.Types.Security
{

/// <summary>
/// Service for scanning assemblies for malware and suspicious patterns.
/// </summary>
public class MalwareScanningService : IDisposable
{
    private readonly ILogger<MalwareScanningService>? _logger;
    private readonly MalwareScanningOptions _options;
    private readonly SemaphoreSlim _scanSemaphore;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="MalwareScanningService"/> class.
    /// </summary>
    /// <param name="logger">Optional logger for diagnostics.</param>
    /// <param name="options">Scanning options.</param>
    public MalwareScanningService(
        ILogger<MalwareScanningService>? logger = null,
        MalwareScanningOptions? options = null)
    {
        _logger = logger;
        _options = options ?? new MalwareScanningOptions();
        _scanSemaphore = new SemaphoreSlim(_options.MaxConcurrentScans);
    }

    /// <summary>
    /// Scans an assembly for malware and suspicious patterns.
    /// </summary>
    /// <param name="assemblyPath">Path to the assembly file.</param>
    /// <returns>The scan result.</returns>
    public async Task<MalwareScanResult> ScanAssemblyAsync(string assemblyPath)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        ArgumentException.ThrowIfNullOrWhiteSpace(assemblyPath);

        if (!File.Exists(assemblyPath))
        {
            return new MalwareScanResult
            {
                IsClean = false,
                ThreatLevel = ThreatLevel.High,
                ThreatDescription = "Assembly file not found",
                DetectionMethod = "File validation"
            };
        }

        await _scanSemaphore.WaitAsync();
        try
        {
            _logger?.LogDebug("Starting malware scan for {AssemblyPath}", assemblyPath);
            var stopwatch = Stopwatch.StartNew();

            var result = await PerformComprehensiveScanAsync(assemblyPath);
            result.ScanDuration = stopwatch.Elapsed;

            _logger?.LogDebug("Malware scan completed for {AssemblyPath}: Clean={IsClean}, ThreatLevel={ThreatLevel}",
                assemblyPath, result.IsClean, result.ThreatLevel);

            return result;
        }
        finally
        {
            _scanSemaphore.Release();
        }
    }

    /// <summary>
    /// Scans multiple assemblies in parallel.
    /// </summary>
    /// <param name="assemblyPaths">Paths to the assembly files.</param>
    /// <returns>Dictionary mapping assembly paths to scan results.</returns>
    public async Task<Dictionary<string, MalwareScanResult>> ScanMultipleAssembliesAsync(
        IEnumerable<string> assemblyPaths)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        ArgumentNullException.ThrowIfNull(assemblyPaths);

        var tasks = assemblyPaths.Select(async path =>
        {
            var result = await ScanAssemblyAsync(path);
            return new KeyValuePair<string, MalwareScanResult>(path, result);
        });

        var results = await Task.WhenAll(tasks);
        return results.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    /// <summary>
    /// Performs comprehensive scanning using multiple methods.
    /// </summary>
    /// <param name="assemblyPath">Path to the assembly.</param>
    /// <returns>Scan result.</returns>
    private async Task<MalwareScanResult> PerformComprehensiveScanAsync(string assemblyPath)
    {
        var result = new MalwareScanResult
        {
            IsClean = true,
            ThreatLevel = ThreatLevel.None,
            ScanMethods = new List<string>()
        };

        // Hash-based scanning
        if (_options.EnableHashScanning)
        {
            await PerformHashBasedScanAsync(assemblyPath, result);
        }

        // Pattern-based scanning
        if (_options.EnablePatternScanning)
        {
            await PerformPatternBasedScanAsync(assemblyPath, result);
        }

        // Behavioral analysis
        if (_options.EnableBehavioralAnalysis)
        {
            await PerformBehavioralAnalysisAsync(assemblyPath, result);
        }

        // Windows Defender integration (if enabled and available)
        if (_options.EnableWindowsDefender && OperatingSystem.IsWindows())
        {
            await PerformWindowsDefenderScanAsync(assemblyPath, result);
        }

        // Determine overall result
        if (result.DetectedPatterns.Count > 0 || result.BehavioralFlags.Count > 0)
        {
            result.IsClean = false;
            result.ThreatLevel = CalculateThreatLevel(result);
            result.ThreatDescription = GenerateThreatDescription(result);
        }

        return result;
    }

    /// <summary>
    /// Performs hash-based malware detection.
    /// </summary>
    private async Task PerformHashBasedScanAsync(string assemblyPath, MalwareScanResult result)
    {
        result.ScanMethods.Add("Hash-based");
        
        try
        {
            using var sha256 = SHA256.Create();
            using var fileStream = File.OpenRead(assemblyPath);
            var hashBytes = await sha256.ComputeHashAsync(fileStream);
            var hash = Convert.ToHexString(hashBytes);

            // In a real implementation, this would check against known malware hashes
            // For now, we'll check against a mock blacklist
            var knownMalwareHashes = new HashSet<string>
            {
                "DEADBEEFCAFEBABE1234567890ABCDEF", // Mock malware hash
                "1234567890ABCDEFDEADBEEFCAFEBABE"  // Mock malware hash
            };

            if (knownMalwareHashes.Contains(hash.ToUpperInvariant()
            {
                result.IsClean = false;
                result.ThreatLevel = ThreatLevel.Critical;
                result.DetectionMethod = "Hash-based detection";
                result.ThreatDescription = "Known malware detected by hash signature";
            }
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Hash-based scan failed for {AssemblyPath}", assemblyPath);
            result.Warnings.Add("Hash-based scan failed");
        }
    }

    /// <summary>
    /// Performs pattern-based malware detection.
    /// </summary>
    private async Task PerformPatternBasedScanAsync(string assemblyPath, MalwareScanResult result)
    {
        result.ScanMethods.Add("Pattern-based");
        
        try
        {
            var content = await File.ReadAllTextAsync(assemblyPath);
            
            foreach (var pattern in _options.SuspiciousPatterns)
            {
                if (content.Contains(pattern, StringComparison.OrdinalIgnoreCase))
                {
                    result.DetectedPatterns.Add(pattern);
                }
            }

            // Check for obfuscation patterns
            var obfuscationPatterns = new[]
            {
                "ConfusedByAttribute",
                "DotfuscatorAttribute",
                "SmartAssemblyAttribute"
            };

            foreach (var pattern in obfuscationPatterns)
            {
                if (content.Contains(pattern, StringComparison.OrdinalIgnoreCase))
                {
                    result.BehavioralFlags.Add($"Obfuscation detected: {pattern}");
                }
            }
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Pattern-based scan failed for {AssemblyPath}", assemblyPath);
            result.Warnings.Add("Pattern-based scan failed");
        }
    }

    /// <summary>
    /// Performs behavioral analysis of the assembly.
    /// </summary>
    private async Task PerformBehavioralAnalysisAsync(string assemblyPath, MalwareScanResult result)
    {
        result.ScanMethods.Add("Behavioral analysis");
        
        try
        {
            var fileInfo = new FileInfo(assemblyPath);
            
            // Check file size (unusually large assemblies might be suspicious)
            if (fileInfo.Length > 100 * 1024 * 1024) // 100 MB
            {
                result.BehavioralFlags.Add("Unusually large assembly size");
            }

            // Check for multiple entry points or exports
            // In a real implementation, this would analyze the PE structure
            await Task.Delay(10); // Simulate analysis time
            
            // Mock behavioral analysis
            var fileName = Path.GetFileName(assemblyPath);
            if (fileName.Contains("hack", StringComparison.OrdinalIgnoreCase) ||
                fileName.Contains("crack", StringComparison.OrdinalIgnoreCase) ||
                fileName.Contains("keygen", StringComparison.OrdinalIgnoreCase))
            {
                result.BehavioralFlags.Add("Suspicious filename pattern");
            }
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Behavioral analysis failed for {AssemblyPath}", assemblyPath);
            result.Warnings.Add("Behavioral analysis failed");
        }
    }

    /// <summary>
    /// Performs Windows Defender scan if available.
    /// </summary>
    private async Task PerformWindowsDefenderScanAsync(string assemblyPath, MalwareScanResult result)
    {
        result.ScanMethods.Add("Windows Defender");
        
        try
        {
            // Mock Windows Defender integration
            // In practice, this would use WinRT APIs or PowerShell cmdlets
            await Task.Delay(100); // Simulate scan time
            
            // For now, assume clean unless suspicious patterns detected
            result.Warnings.Add("Windows Defender scan simulated");
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Windows Defender scan failed for {AssemblyPath}", assemblyPath);
            result.Warnings.Add("Windows Defender scan failed");
        }
    }

    /// <summary>
    /// Calculates the overall threat level based on scan results.
    /// </summary>
    private static ThreatLevel CalculateThreatLevel(MalwareScanResult result)
    {
        var score = 0;
        score += result.DetectedPatterns.Count * 2;
        score += result.BehavioralFlags.Count;

        return score switch
        {
            0 => ThreatLevel.None,
            1 => ThreatLevel.Low,
            2 or 3 => ThreatLevel.Medium,
            4 or 5 => ThreatLevel.High,
            _ => ThreatLevel.Critical
        };
    }

    /// <summary>
    /// Generates a threat description based on scan results.
    /// </summary>
    private static string GenerateThreatDescription(MalwareScanResult result)
    {
        var threats = new List<string>();
        
        if (result.DetectedPatterns.Count > 0)
        {
            threats.Add($"{result.DetectedPatterns.Count} suspicious patterns detected");
        }
        
        if (result.BehavioralFlags.Count > 0)
        {
            threats.Add($"{result.BehavioralFlags.Count} behavioral flags raised");
        }

        return string.Join(", ", threats);
    }

    /// <summary>
    /// Disposes the service resources.
    /// </summary>
    public void Dispose()
    {
        if (!_disposed)
        {
            _scanSemaphore?.Dispose();
            _disposed = true;
        }
    }
}

/// <summary>
/// Options for malware scanning.
/// </summary>
public class MalwareScanningOptions
{
    /// <summary>
    /// Gets or sets whether hash-based scanning is enabled.
    /// </summary>
    public bool EnableHashScanning { get; set; } = true;

    /// <summary>
    /// Gets or sets whether pattern-based scanning is enabled.
    /// </summary>
    public bool EnablePatternScanning { get; set; } = true;

    /// <summary>
    /// Gets or sets whether behavioral analysis is enabled.
    /// </summary>
    public bool EnableBehavioralAnalysis { get; set; } = true;

    /// <summary>
    /// Gets or sets whether Windows Defender integration is enabled.
    /// </summary>
    public bool EnableWindowsDefender { get; set; } = false;

    /// <summary>
    /// Gets or sets the maximum number of concurrent scans.
    /// </summary>
    public int MaxConcurrentScans { get; set; } = 2;

    /// <summary>
    /// Gets or sets the scan timeout.
    /// </summary>
    public TimeSpan ScanTimeout { get; set; } = TimeSpan.FromMinutes(2);

    /// <summary>
    /// Gets the list of suspicious patterns to detect.
    /// </summary>
    public List<string> SuspiciousPatterns { get; } = new()
    {
        "CreateProcess",
        "VirtualAlloc",
        "LoadLibrary",
        "GetProcAddress",
        "WriteProcessMemory",
        "ReadProcessMemory",
        "CreateRemoteThread",
        "SetWindowsHookEx",
        "keylogger",
        "backdoor",
        "rootkit"
    };
}

/// <summary>
/// Result of a malware scan.
/// </summary>
public class MalwareScanResult
{
    /// <summary>
    /// Gets or sets whether the assembly is clean (no threats detected).
    /// </summary>
    public bool IsClean { get; set; } = true;

    /// <summary>
    /// Gets or sets the detected threat level.
    /// </summary>
    public ThreatLevel ThreatLevel { get; set; } = ThreatLevel.None;

    /// <summary>
    /// Gets or sets the threat description.
    /// </summary>
    public string? ThreatDescription { get; set; }

    /// <summary>
    /// Gets or sets the primary detection method.
    /// </summary>
    public string? DetectionMethod { get; set; }

    /// <summary>
    /// Gets the list of detected suspicious patterns.
    /// </summary>
    public List<string> DetectedPatterns { get; } = new();

    /// <summary>
    /// Gets the list of behavioral flags.
    /// </summary>
    public List<string> BehavioralFlags { get; } = new();

    /// <summary>
    /// Gets the list of scan warnings.
    /// </summary>
    public List<string> Warnings { get; } = new();

    /// <summary>
    /// Gets the list of scan methods used.
    /// </summary>
    public List<string> ScanMethods { get; } = new();

    /// <summary>
    /// Gets or sets the scan duration.
    /// </summary>
    public TimeSpan ScanDuration { get; set; }
}}
