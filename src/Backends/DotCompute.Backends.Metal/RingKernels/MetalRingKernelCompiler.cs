// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Text;
using DotCompute.Abstractions.Kernels;
using DotCompute.Abstractions.RingKernels;
using Microsoft.Extensions.Logging;

namespace DotCompute.Backends.Metal.RingKernels;

/// <summary>
/// Compiles C# ring kernel definitions to Metal Shading Language (MSL) persistent kernels.
/// </summary>
/// <remarks>
/// Generates MSL code for persistent kernels with:
/// - Threadgroup barriers for synchronization
/// - Lock-free message queues using atomic operations
/// - Persistent kernel loop with activation control
/// - Thread-grid-stride loops for work distribution
/// </remarks>
public sealed partial class MetalRingKernelCompiler : IDisposable
{
    private readonly ILogger<MetalRingKernelCompiler> _logger;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="MetalRingKernelCompiler"/> class.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    public MetalRingKernelCompiler(ILogger<MetalRingKernelCompiler> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Compiles a ring kernel definition to Metal Shading Language source code.
    /// </summary>
    /// <param name="kernelDefinition">Kernel definition metadata.</param>
    /// <param name="sourceCode">C# source code to translate.</param>
    /// <param name="config">Ring kernel configuration.</param>
    /// <returns>Generated MSL source code.</returns>
    public string CompileToMSL(
        KernelDefinition kernelDefinition,
        string sourceCode,
        RingKernelConfig config)
    {
        ArgumentNullException.ThrowIfNull(kernelDefinition);
        ArgumentException.ThrowIfNullOrWhiteSpace(sourceCode);
        ArgumentNullException.ThrowIfNull(config);

        _logger.LogInformation(
            "Compiling ring kernel '{KernelName}' (ID: {KernelId}) to MSL",
            kernelDefinition.Name,
            config.KernelId);

        var mslSource = new StringBuilder(4096);

        // Include necessary headers
        GenerateHeaders(mslSource);

        // Generate message queue structure
        GenerateMessageQueueStructure(mslSource, config);

        // Generate control structure
        GenerateControlStructure(mslSource);

        // Generate persistent kernel
        GeneratePersistentKernel(mslSource, kernelDefinition, config);

        var result = mslSource.ToString();
        _logger.LogDebug("Generated {Length} bytes of MSL code", result.Length);

        return result;
    }

    private static void GenerateHeaders(StringBuilder sb)
    {
        sb.AppendLine("// Auto-generated Metal Shading Language persistent ring kernel");
        sb.AppendLine("// DO NOT EDIT - Generated by MetalRingKernelCompiler");
        sb.AppendLine();
        sb.AppendLine("#include <metal_stdlib>");
        sb.AppendLine("#include <metal_atomic>");
        sb.AppendLine("using namespace metal;");
        sb.AppendLine();
    }

    private static void GenerateMessageQueueStructure(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("// Lock-free ring buffer message queue");
        sb.AppendLine("template<typename T>");
        sb.AppendLine("struct MessageQueue {");
        sb.AppendLine("    device T* buffer;                    // Message buffer");
        sb.AppendLine("    int capacity;                        // Queue capacity (power of 2)");
        sb.AppendLine("    device atomic_int* head;             // Dequeue position (atomic)");
        sb.AppendLine("    device atomic_int* tail;             // Enqueue position (atomic)");
        sb.AppendLine();
        sb.AppendLine("    bool try_enqueue(const T& message) device {");
        sb.AppendLine("        int current_tail = atomic_load_explicit(tail, memory_order_relaxed);");
        sb.AppendLine("        int next_tail = (current_tail + 1) & (capacity - 1);");
        sb.AppendLine("        int current_head = atomic_load_explicit(head, memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        if (next_tail == current_head) {");
        sb.AppendLine("            return false; // Queue full");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim slot using compare-and-swap");
        sb.AppendLine("        if (atomic_compare_exchange_strong_explicit(tail, &current_tail, next_tail,");
        sb.AppendLine("                                                     memory_order_release,");
        sb.AppendLine("                                                     memory_order_relaxed)) {");
        sb.AppendLine("            buffer[current_tail] = message;");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine("        return false; // Lost race");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    bool try_dequeue(thread T& message) device {");
        sb.AppendLine("        int current_head = atomic_load_explicit(head, memory_order_relaxed);");
        sb.AppendLine("        int current_tail = atomic_load_explicit(tail, memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        if (current_head == current_tail) {");
        sb.AppendLine("            return false; // Queue empty");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        int next_head = (current_head + 1) & (capacity - 1);");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim slot using compare-and-swap");
        sb.AppendLine("        if (atomic_compare_exchange_strong_explicit(head, &current_head, next_head,");
        sb.AppendLine("                                                     memory_order_release,");
        sb.AppendLine("                                                     memory_order_relaxed)) {");
        sb.AppendLine("            message = buffer[current_head];");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine("        return false; // Lost race");
        sb.AppendLine("    }");
        sb.AppendLine("};");
        sb.AppendLine();
    }

    private static void GenerateControlStructure(StringBuilder sb)
    {
        sb.AppendLine("// Kernel control structure");
        sb.AppendLine("struct KernelControl {");
        sb.AppendLine("    atomic_int active;       // 1 = active, 0 = inactive");
        sb.AppendLine("    atomic_int terminate;    // 1 = terminate requested");
        sb.AppendLine("    atomic_long msg_count;   // Messages processed");
        sb.AppendLine("};");
        sb.AppendLine();
    }

    private static void GeneratePersistentKernel(
        StringBuilder sb,
        KernelDefinition kernelDef,
        RingKernelConfig config)
    {
        var kernelName = SanitizeKernelName(config.KernelId);

        sb.AppendLine(System.Globalization.CultureInfo.InvariantCulture, $"// Persistent ring kernel: {kernelName}");

        // Build kernel declaration
        sb.AppendLine(System.Globalization.CultureInfo.InvariantCulture, $"kernel void {kernelName}_kernel(");
        sb.AppendLine("    device MessageQueue<char>* input_queue  [[buffer(0)]],  // Generic message queue (placeholder)");
        sb.AppendLine("    device MessageQueue<char>* output_queue [[buffer(1)]],");
        sb.AppendLine("    device KernelControl* control           [[buffer(2)]],");
        sb.AppendLine("    device void* user_data                  [[buffer(3)]],");
        sb.AppendLine("    constant int& data_size                 [[buffer(4)]],");
        sb.AppendLine("    uint thread_id [[thread_position_in_grid]],");
        sb.AppendLine("    uint threadgroup_id [[threadgroup_position_in_grid]],");
        sb.AppendLine("    uint thread_in_threadgroup [[thread_position_in_threadgroup]],");
        sb.AppendLine("    uint threads_per_threadgroup [[threads_per_threadgroup]])");
        sb.AppendLine("{");
        sb.AppendLine("    // Get thread indices");
        sb.AppendLine("    uint tid = thread_in_threadgroup;");
        sb.AppendLine("    uint bid = threadgroup_id;");
        sb.AppendLine("    uint global_tid = thread_id;");
        sb.AppendLine();

        if (config.Mode == RingKernelMode.Persistent)
        {
            GeneratePersistentLoop(sb, config);
        }
        else
        {
            GenerateEventDrivenLoop(sb, config);
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GeneratePersistentLoop(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("    // Persistent kernel loop");
        sb.AppendLine("    while (true) {");
        sb.AppendLine("        // Check for termination");
        sb.AppendLine("        if (atomic_load_explicit(&control->terminate, memory_order_acquire) == 1) {");
        sb.AppendLine("            break;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Wait for activation");
        sb.AppendLine("        while (atomic_load_explicit(&control->active, memory_order_acquire) == 0) {");
        sb.AppendLine("            if (atomic_load_explicit(&control->terminate, memory_order_acquire) == 1) {");
        sb.AppendLine("                return;");
        sb.AppendLine("            }");
        sb.AppendLine("            // Brief sleep to reduce power consumption");
        sb.AppendLine("            threadgroup_barrier(mem_flags::mem_none);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Process messages");
        sb.AppendLine("        char msg_buffer[256]; // Message buffer (placeholder)");
        sb.AppendLine("        if (input_queue->try_dequeue(msg_buffer)) {");
        sb.AppendLine("            // TODO: Process message based on kernel logic");
        sb.AppendLine("            // This is where the translated C# code goes");
        sb.AppendLine();
        sb.AppendLine("            // Update message counter");
        sb.AppendLine("            atomic_fetch_add_explicit(&control->msg_count, 1L, memory_order_relaxed);");
        sb.AppendLine();
        sb.AppendLine("            // Send result (if needed)");
        sb.AppendLine("            // output_queue->try_enqueue(result_msg);");
        sb.AppendLine("        }");
        sb.AppendLine();

        if (config.Domain == RingKernelDomain.GraphAnalytics)
        {
            sb.AppendLine("        // Graph analytics: Synchronize after message processing");
            sb.AppendLine("        threadgroup_barrier(mem_flags::mem_device);");
        }

        sb.AppendLine("    }");
    }

    private static void GenerateEventDrivenLoop(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("    // Event-driven mode: process available messages and exit");
        sb.AppendLine("    char msg_buffer[256];");
        sb.AppendLine("    int processed = 0;");
        sb.AppendLine();
        sb.AppendLine("    while (input_queue->try_dequeue(msg_buffer)) {");
        sb.AppendLine("        // TODO: Process message based on kernel logic");
        sb.AppendLine();
        sb.AppendLine("        atomic_fetch_add_explicit(&control->msg_count, 1L, memory_order_relaxed);");
        sb.AppendLine("        processed++;");
        sb.AppendLine();
        sb.AppendLine("        // Limit burst processing");
        sb.AppendLine(System.Globalization.CultureInfo.InvariantCulture, $"        if (processed >= {config.Capacity}) {{");
        sb.AppendLine("            break;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static string SanitizeKernelName(string kernelId)
    {
        // Replace non-alphanumeric characters with underscores
        var sanitized = new StringBuilder(kernelId.Length);
        foreach (var c in kernelId)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(c);
            }
            else
            {
                sanitized.Append('_');
            }
        }
        return sanitized.ToString();
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _logger.LogDebug("Disposing MetalRingKernelCompiler");
        _disposed = true;
    }
}
