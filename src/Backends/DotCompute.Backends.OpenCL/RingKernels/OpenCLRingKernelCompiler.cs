// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Globalization;
using System.Text;
using DotCompute.Abstractions.Kernels;
using DotCompute.Abstractions.RingKernels;
using Microsoft.Extensions.Logging;

namespace DotCompute.Backends.OpenCL.RingKernels;

/// <summary>
/// Compiles C# ring kernel definitions to OpenCL C persistent kernels.
/// </summary>
/// <remarks>
/// Generates OpenCL C code for persistent kernels with:
/// - Work-group level synchronization via barriers
/// - Lock-free message queues using atomic operations
/// - Persistent kernel loop with activation control
/// - Global and local memory management
/// </remarks>
public sealed class OpenCLRingKernelCompiler : IDisposable
{
    private readonly ILogger<OpenCLRingKernelCompiler> _logger;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenCLRingKernelCompiler"/> class.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    public OpenCLRingKernelCompiler(ILogger<OpenCLRingKernelCompiler> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Compiles a ring kernel definition to OpenCL C source code.
    /// </summary>
    /// <param name="kernelDefinition">Kernel definition metadata.</param>
    /// <param name="sourceCode">C# source code to translate.</param>
    /// <param name="config">Ring kernel configuration.</param>
    /// <returns>Generated OpenCL C source code.</returns>
    public string CompileToOpenCLC(
        KernelDefinition kernelDefinition,
        string sourceCode,
        RingKernelConfig config)
    {
        ArgumentNullException.ThrowIfNull(kernelDefinition);
        ArgumentException.ThrowIfNullOrWhiteSpace(sourceCode);
        ArgumentNullException.ThrowIfNull(config);

        _logger.LogInformation(
            "Compiling ring kernel '{KernelName}' (ID: {KernelId}) to OpenCL C",
            kernelDefinition.Name,
            config.KernelId);

        var oclSource = new StringBuilder(4096);

        // Include necessary pragmas and headers
        GenerateHeaders(oclSource);

        // Generate message queue structure
        GenerateMessageQueueStructure(oclSource, config);

        // Generate control structure
        GenerateControlStructure(oclSource);

        // Generate persistent kernel
        GeneratePersistentKernel(oclSource, kernelDefinition, config);

        var result = oclSource.ToString();
        _logger.LogDebug("Generated {Length} bytes of OpenCL C code", result.Length);

        return result;
    }

    private static void GenerateHeaders(StringBuilder sb)
    {
        sb.AppendLine("// Auto-generated OpenCL C persistent ring kernel");
        sb.AppendLine("// DO NOT EDIT - Generated by OpenCLRingKernelCompiler");
        sb.AppendLine();
        sb.AppendLine("#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable");
        sb.AppendLine("#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable");
        sb.AppendLine("#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable");
        sb.AppendLine();
    }

    private static void GenerateMessageQueueStructure(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("// Lock-free ring buffer message queue");
        sb.AppendLine("typedef struct {");
        sb.AppendLine("    __global char* buffer;              // Message buffer");
        sb.AppendLine("    int capacity;                       // Queue capacity (power of 2)");
        sb.AppendLine("    __global volatile atomic_int* head; // Dequeue position (atomic)");
        sb.AppendLine("    __global volatile atomic_int* tail; // Enqueue position (atomic)");
        sb.AppendLine("} MessageQueue;");
        sb.AppendLine();

        // Helper functions for message queue operations
        sb.AppendLine("// Try to enqueue a message (returns 1 on success, 0 on failure)");
        sb.AppendLine("inline int try_enqueue(MessageQueue* queue, __local char* message, int msg_size) {");
        sb.AppendLine("    int current_tail = atomic_load_explicit(queue->tail, memory_order_relaxed, memory_scope_device);");
        sb.AppendLine("    int next_tail = (current_tail + 1) & (queue->capacity - 1);");
        sb.AppendLine("    int current_head = atomic_load_explicit(queue->head, memory_order_acquire, memory_scope_device);");
        sb.AppendLine();
        sb.AppendLine("    if (next_tail == current_head) {");
        sb.AppendLine("        return 0; // Queue full");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    // Try to claim slot using compare-exchange");
        sb.AppendLine("    int expected = current_tail;");
        sb.AppendLine("    if (atomic_compare_exchange_strong_explicit(");
        sb.AppendLine("            queue->tail, &expected, next_tail,");
        sb.AppendLine("            memory_order_release, memory_order_relaxed,");
        sb.AppendLine("            memory_scope_device)) {");
        sb.AppendLine("        // Copy message to buffer");
        sb.AppendLine("        __global char* target = queue->buffer + (current_tail * msg_size);");
        sb.AppendLine("        for (int i = 0; i < msg_size; i++) {");
        sb.AppendLine("            target[i] = message[i];");
        sb.AppendLine("        }");
        sb.AppendLine("        return 1; // Success");
        sb.AppendLine("    }");
        sb.AppendLine("    return 0; // Lost race");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("// Try to dequeue a message (returns 1 on success, 0 on failure)");
        sb.AppendLine("inline int try_dequeue(MessageQueue* queue, __local char* message, int msg_size) {");
        sb.AppendLine("    int current_head = atomic_load_explicit(queue->head, memory_order_relaxed, memory_scope_device);");
        sb.AppendLine("    int current_tail = atomic_load_explicit(queue->tail, memory_order_acquire, memory_scope_device);");
        sb.AppendLine();
        sb.AppendLine("    if (current_head == current_tail) {");
        sb.AppendLine("        return 0; // Queue empty");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    int next_head = (current_head + 1) & (queue->capacity - 1);");
        sb.AppendLine();
        sb.AppendLine("    // Try to claim slot using compare-exchange");
        sb.AppendLine("    int expected = current_head;");
        sb.AppendLine("    if (atomic_compare_exchange_strong_explicit(");
        sb.AppendLine("            queue->head, &expected, next_head,");
        sb.AppendLine("            memory_order_release, memory_order_relaxed,");
        sb.AppendLine("            memory_scope_device)) {");
        sb.AppendLine("        // Copy message from buffer");
        sb.AppendLine("        __global char* source = queue->buffer + (current_head * msg_size);");
        sb.AppendLine("        for (int i = 0; i < msg_size; i++) {");
        sb.AppendLine("            message[i] = source[i];");
        sb.AppendLine("        }");
        sb.AppendLine("        return 1; // Success");
        sb.AppendLine("    }");
        sb.AppendLine("    return 0; // Lost race");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateControlStructure(StringBuilder sb)
    {
        sb.AppendLine("// Kernel control structure");
        sb.AppendLine("typedef struct {");
        sb.AppendLine("    __global volatile atomic_int* active;      // 1 = active, 0 = inactive");
        sb.AppendLine("    __global volatile atomic_int* terminate;   // 1 = terminate requested");
        sb.AppendLine("    __global volatile atomic_long* msg_count;  // Messages processed");
        sb.AppendLine("} KernelControl;");
        sb.AppendLine();
    }

    private static void GeneratePersistentKernel(
        StringBuilder sb,
        KernelDefinition kernelDef,
        RingKernelConfig config)
    {
        string kernelName = SanitizeKernelName(config.KernelId);

        sb.AppendLine(CultureInfo.InvariantCulture, $"// Persistent ring kernel: {kernelName}");

        // Build kernel declaration
        sb.AppendLine(CultureInfo.InvariantCulture, $"__kernel void {kernelName}_kernel(");
        sb.AppendLine("    __global MessageQueue* input_queue,");
        sb.AppendLine("    __global MessageQueue* output_queue,");
        sb.AppendLine("    __global KernelControl* control,");
        sb.AppendLine("    __global void* user_data,");
        sb.AppendLine("    int data_size,");
        sb.AppendLine("    __local char* scratch)  // Local memory for message staging");
        sb.AppendLine("{");
        sb.AppendLine("    // Get thread indices");
        sb.AppendLine("    int gid = get_global_id(0);");
        sb.AppendLine("    int lid = get_local_id(0);");
        sb.AppendLine("    int group_id = get_group_id(0);");
        sb.AppendLine("    int local_size = get_local_size(0);");
        sb.AppendLine();

        if (config.Mode == RingKernelMode.Persistent)
        {
            GeneratePersistentLoop(sb, config);
        }
        else
        {
            GenerateEventDrivenLoop(sb, config);
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GeneratePersistentLoop(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("    // Persistent kernel loop");
        sb.AppendLine("    while (true) {");
        sb.AppendLine("        // Check for termination");
        sb.AppendLine("        if (atomic_load_explicit(control->terminate, memory_order_acquire, memory_scope_device) == 1) {");
        sb.AppendLine("            break;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Wait for activation");
        sb.AppendLine("        while (atomic_load_explicit(control->active, memory_order_acquire, memory_scope_device) == 0) {");
        sb.AppendLine("            if (atomic_load_explicit(control->terminate, memory_order_acquire, memory_scope_device) == 1) {");
        sb.AppendLine("                return;");
        sb.AppendLine("            }");
        sb.AppendLine("            // Yield to other work-groups (OpenCL doesn't have nanosleep)");
        sb.AppendLine("            barrier(CLK_LOCAL_MEM_FENCE);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Process messages using local memory staging");
        sb.AppendLine("        __local char msg_buffer[256];  // Message staging area");
        sb.AppendLine("        if (lid == 0) {  // Only work-item 0 tries to dequeue");
        sb.AppendLine("            if (try_dequeue(input_queue, msg_buffer, 256)) {");
        sb.AppendLine("                // TODO: Process message based on kernel logic");
        sb.AppendLine("                // This is where the translated C# code goes");
        sb.AppendLine();
        sb.AppendLine("                // Update message counter");
        sb.AppendLine("                atomic_fetch_add_explicit(control->msg_count, 1, memory_order_relaxed, memory_scope_device);");
        sb.AppendLine();
        sb.AppendLine("                // Send result (if needed)");
        sb.AppendLine("                // try_enqueue(output_queue, result_msg, 256);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        if (config.Domain == RingKernelDomain.GraphAnalytics)
        {
            sb.AppendLine("        // Graph analytics: Synchronize work-group after message processing");
            sb.AppendLine("        barrier(CLK_GLOBAL_MEM_FENCE);");
        }
        else
        {
            sb.AppendLine("        // Synchronize work-group");
            sb.AppendLine("        barrier(CLK_LOCAL_MEM_FENCE);");
        }

        sb.AppendLine("    }");
    }

    private static void GenerateEventDrivenLoop(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("    // Event-driven mode: process available messages and exit");
        sb.AppendLine("    __local char msg_buffer[256];");
        sb.AppendLine("    int processed = 0;");
        sb.AppendLine();
        sb.AppendLine("    // Only work-item 0 in each work-group processes messages");
        sb.AppendLine("    if (lid == 0) {");
        sb.AppendLine("        while (try_dequeue(input_queue, msg_buffer, 256)) {");
        sb.AppendLine("            // TODO: Process message based on kernel logic");
        sb.AppendLine();
        sb.AppendLine("            atomic_fetch_add_explicit(control->msg_count, 1, memory_order_relaxed, memory_scope_device);");
        sb.AppendLine("            processed++;");
        sb.AppendLine();
        sb.AppendLine("            // Limit burst processing");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            if (processed >= {config.Capacity}) {{");
        sb.AppendLine("                break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    // Synchronize work-group before exit");
        sb.AppendLine("    barrier(CLK_LOCAL_MEM_FENCE);");
    }

    private static string SanitizeKernelName(string kernelId)
    {
        // Replace non-alphanumeric characters with underscores
        var sanitized = new StringBuilder(kernelId.Length);
        foreach (char c in kernelId)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(c);
            }
            else
            {
                sanitized.Append('_');
            }
        }
        return sanitized.ToString();
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _logger.LogDebug("Disposing OpenCLRingKernelCompiler");
        _disposed = true;
    }
}
