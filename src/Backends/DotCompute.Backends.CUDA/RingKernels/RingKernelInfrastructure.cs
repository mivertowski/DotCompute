// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Text;

namespace DotCompute.Backends.CUDA.RingKernels;

/// <summary>
/// Provides CUDA infrastructure headers for Ring Kernel compilation.
/// </summary>
/// <remarks>
/// <para>
/// This class supplies in-memory CUDA header files that are passed to NVRTC during
/// Ring Kernel compilation. The headers define the low-level GPU data structures
/// and algorithms needed for persistent kernel message processing.
/// </para>
/// <para>
/// Headers provided:
/// <list type="bullet">
/// <item><description><c>ring_buffer.cuh</c> - Lock-free ring buffer implementation</description></item>
/// <item><description><c>message_queue.cuh</c> - Message queue with atomic operations</description></item>
/// <item><description><c>memorypack_deserializer.cuh</c> - MemoryPack deserialization support</description></item>
/// </list>
/// </para>
/// </remarks>
public static class RingKernelInfrastructure
{
    /// <summary>
    /// Header file names for NVRTC compilation.
    /// </summary>
    public static readonly string[] HeaderNames =
    [
        "ring_buffer.cuh",
        "message_queue.cuh",
        "memorypack_deserializer.cuh"
    ];

    /// <summary>
    /// Checks if CUDA source code requires Ring Kernel infrastructure headers.
    /// </summary>
    /// <param name="cudaSource">CUDA source code to check.</param>
    /// <returns>True if any Ring Kernel headers are referenced in the source.</returns>
    public static bool RequiresRingKernelHeaders(string cudaSource)
    {
        if (string.IsNullOrWhiteSpace(cudaSource))
        {
            return false;
        }

        // Check for any of our infrastructure header includes
        foreach (var headerName in HeaderNames)
        {
            if (cudaSource.Contains($"#include \"{headerName}\"", StringComparison.Ordinal))
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Gets all Ring Kernel infrastructure headers as strings.
    /// </summary>
    /// <returns>Array of header content strings matching <see cref="HeaderNames"/>.</returns>
    public static string[] GetHeaders()
    {
        return
        [
            GetRingBufferHeader(),
            GetMessageQueueHeader(),
            GetMemoryPackDeserializerHeader()
        ];
    }

    /// <summary>
    /// Gets the ring_buffer.cuh header content.
    /// </summary>
    /// <returns>CUDA C++ source code for ring buffer infrastructure.</returns>
    public static string GetRingBufferHeader()
    {
        var sb = new StringBuilder(2048);

        sb.AppendLine("// ring_buffer.cuh - Lock-free ring buffer for Ring Kernels");
        sb.AppendLine("// Auto-generated by RingKernelInfrastructure");
        sb.AppendLine();
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        sb.AppendLine("#include <cuda/atomic>");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Lock-free ring buffer for inter-kernel communication.");
        sb.AppendLine("/// Uses power-of-2 size for fast modulo via bitwise AND.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("template<typename T>");
        sb.AppendLine("struct RingBuffer {");
        sb.AppendLine("    T* data;                          // Buffer storage");
        sb.AppendLine("    unsigned int capacity;            // Must be power of 2");
        sb.AppendLine("    cuda::atomic<unsigned int>* head; // Read position");
        sb.AppendLine("    cuda::atomic<unsigned int>* tail; // Write position");
        sb.AppendLine();
        sb.AppendLine("    /// Try to write an element (producer side)");
        sb.AppendLine("    __device__ bool try_push(const T& value) {");
        sb.AppendLine("        unsigned int current_tail = tail->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        unsigned int next_tail = (current_tail + 1) & (capacity - 1);");
        sb.AppendLine("        unsigned int current_head = head->load(cuda::memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        // Check if buffer is full");
        sb.AppendLine("        if (next_tail == current_head) {");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim the slot");
        sb.AppendLine("        if (tail->compare_exchange_strong(");
        sb.AppendLine("                current_tail,");
        sb.AppendLine("                next_tail,");
        sb.AppendLine("                cuda::memory_order_release,");
        sb.AppendLine("                cuda::memory_order_relaxed)) {");
        sb.AppendLine("            data[current_tail] = value;");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return false; // Lost the race");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// Try to read an element (consumer side)");
        sb.AppendLine("    __device__ bool try_pop(T& value) {");
        sb.AppendLine("        unsigned int current_head = head->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        unsigned int current_tail = tail->load(cuda::memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        // Check if buffer is empty");
        sb.AppendLine("        if (current_head == current_tail) {");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        unsigned int next_head = (current_head + 1) & (capacity - 1);");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim the slot");
        sb.AppendLine("        if (head->compare_exchange_strong(");
        sb.AppendLine("                current_head,");
        sb.AppendLine("                next_head,");
        sb.AppendLine("                cuda::memory_order_release,");
        sb.AppendLine("                cuda::memory_order_relaxed)) {");
        sb.AppendLine("            value = data[current_head];");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return false; // Lost the race");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// Check if buffer is empty (approximate)");
        sb.AppendLine("    __device__ bool is_empty() const {");
        sb.AppendLine("        return head->load(cuda::memory_order_relaxed) == ");
        sb.AppendLine("               tail->load(cuda::memory_order_relaxed);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// Get approximate number of elements");
        sb.AppendLine("    __device__ unsigned int size() const {");
        sb.AppendLine("        unsigned int h = head->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        unsigned int t = tail->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        return (t - h) & (capacity - 1);");
        sb.AppendLine("    }");
        sb.AppendLine("};");
        sb.AppendLine();

        return sb.ToString();
    }

    /// <summary>
    /// Gets the message_queue.cuh header content.
    /// </summary>
    /// <returns>CUDA C++ source code for message queue infrastructure.</returns>
    public static string GetMessageQueueHeader()
    {
        var sb = new StringBuilder(2048);

        sb.AppendLine("// message_queue.cuh - Message queue for Ring Kernels");
        sb.AppendLine("// Auto-generated by RingKernelInfrastructure");
        sb.AppendLine();
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        sb.AppendLine("#include <cuda/atomic>");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Lock-free message queue optimized for GPU message passing.");
        sb.AppendLine("/// Uses byte buffers for MemoryPack-serialized messages.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("struct MessageQueue {");
        sb.AppendLine("    unsigned char* buffer;            // Message buffer (serialized)");
        sb.AppendLine("    unsigned int capacity;            // Queue capacity (power of 2)");
        sb.AppendLine("    unsigned int message_size;        // Size of each message in bytes");
        sb.AppendLine("    cuda::atomic<unsigned int>* head; // Dequeue position");
        sb.AppendLine("    cuda::atomic<unsigned int>* tail; // Enqueue position");
        sb.AppendLine();
        sb.AppendLine("    /// Try to enqueue a message");
        sb.AppendLine("    __device__ bool try_enqueue(const unsigned char* message) {");
        sb.AppendLine("        unsigned int current_tail = tail->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        unsigned int next_tail = (current_tail + 1) & (capacity - 1);");
        sb.AppendLine("        unsigned int current_head = head->load(cuda::memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        if (next_tail == current_head) {");
        sb.AppendLine("            return false; // Queue full");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim slot");
        sb.AppendLine("        if (tail->compare_exchange_strong(");
        sb.AppendLine("                current_tail,");
        sb.AppendLine("                next_tail,");
        sb.AppendLine("                cuda::memory_order_release,");
        sb.AppendLine("                cuda::memory_order_relaxed)) {");
        sb.AppendLine("            // Copy message to buffer");
        sb.AppendLine("            unsigned char* dest = buffer + (current_tail * message_size);");
        sb.AppendLine("            for (unsigned int i = 0; i < message_size; ++i) {");
        sb.AppendLine("                dest[i] = message[i];");
        sb.AppendLine("            }");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return false; // Lost race");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// Try to dequeue a message");
        sb.AppendLine("    __device__ bool try_dequeue(unsigned char* message) {");
        sb.AppendLine("        unsigned int current_head = head->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        unsigned int current_tail = tail->load(cuda::memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        if (current_head == current_tail) {");
        sb.AppendLine("            return false; // Queue empty");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        unsigned int next_head = (current_head + 1) & (capacity - 1);");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim slot");
        sb.AppendLine("        if (head->compare_exchange_strong(");
        sb.AppendLine("                current_head,");
        sb.AppendLine("                next_head,");
        sb.AppendLine("                cuda::memory_order_release,");
        sb.AppendLine("                cuda::memory_order_relaxed)) {");
        sb.AppendLine("            // Copy message from buffer");
        sb.AppendLine("            unsigned char* src = buffer + (current_head * message_size);");
        sb.AppendLine("            for (unsigned int i = 0; i < message_size; ++i) {");
        sb.AppendLine("                message[i] = src[i];");
        sb.AppendLine("            }");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return false; // Lost race");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// Check if queue is empty");
        sb.AppendLine("    __device__ bool is_empty() const {");
        sb.AppendLine("        return head->load(cuda::memory_order_relaxed) == ");
        sb.AppendLine("               tail->load(cuda::memory_order_relaxed);");
        sb.AppendLine("    }");
        sb.AppendLine("};");
        sb.AppendLine();

        return sb.ToString();
    }

    /// <summary>
    /// Gets the memorypack_deserializer.cuh header content.
    /// </summary>
    /// <returns>CUDA C++ source code for MemoryPack deserialization support.</returns>
    public static string GetMemoryPackDeserializerHeader()
    {
        var sb = new StringBuilder(1024);

        sb.AppendLine("// memorypack_deserializer.cuh - MemoryPack deserialization support");
        sb.AppendLine("// Auto-generated by RingKernelInfrastructure");
        sb.AppendLine();
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Placeholder for MemoryPack deserialization utilities.");
        sb.AppendLine("/// This will be auto-generated per-message-type in Phase 1 completion.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine();
        sb.AppendLine("// Note: Actual deserialization code is generated by the");
        sb.AppendLine("// MemoryPackMessageSerializer during Phase 1.1 completion.");
        sb.AppendLine("// Each message type gets its own deserialize_<TypeName> function.");
        sb.AppendLine();

        return sb.ToString();
    }
}
