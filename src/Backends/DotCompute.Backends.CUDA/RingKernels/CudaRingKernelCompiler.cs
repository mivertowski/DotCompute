// Copyright (c) 2025 Michael Ivertowski
// Licensed under the MIT License. See LICENSE file in the project root for license information.

using System.Text;
using DotCompute.Abstractions.Kernels;
using DotCompute.Abstractions.RingKernels;
using DotCompute.Backends.CUDA.Configuration;
using DotCompute.Backends.CUDA.Native;
using Microsoft.Extensions.Logging;

namespace DotCompute.Backends.CUDA.RingKernels;

/// <summary>
/// Compiles C# ring kernel definitions to CUDA C persistent kernels.
/// </summary>
/// <remarks>
/// Generates CUDA C code for persistent kernels with:
/// - Cooperative groups for synchronization
/// - Lock-free message queues using atomics
/// - Persistent kernel loop with activation control
/// - Grid-stride loops for work distribution
/// </remarks>
public sealed class CudaRingKernelCompiler : IDisposable
{
    private readonly ILogger<CudaRingKernelCompiler> _logger;
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="CudaRingKernelCompiler"/> class.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    public CudaRingKernelCompiler(ILogger<CudaRingKernelCompiler> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Compiles a ring kernel definition to CUDA C source code.
    /// </summary>
    /// <param name="kernelDefinition">Kernel definition metadata.</param>
    /// <param name="sourceCode">C# source code to translate.</param>
    /// <param name="config">Ring kernel configuration.</param>
    /// <returns>Generated CUDA C source code.</returns>
    public string CompileToCudaC(
        KernelDefinition kernelDefinition,
        string sourceCode,
        RingKernelConfig config)
    {
        ArgumentNullException.ThrowIfNull(kernelDefinition);
        ArgumentException.ThrowIfNullOrWhiteSpace(sourceCode);
        ArgumentNullException.ThrowIfNull(config);

        _logger.LogInformation(
            "Compiling ring kernel '{KernelName}' (ID: {KernelId}) to CUDA C",
            kernelDefinition.Name,
            config.KernelId);

        var cudaSource = new StringBuilder(4096);

        // Include necessary headers
        GenerateHeaders(cudaSource, config);

        // Generate message queue structure
        GenerateMessageQueueStructure(cudaSource, config);

        // Generate control structure
        GenerateControlStructure(cudaSource);

        // Generate persistent kernel
        GeneratePersistentKernel(cudaSource, kernelDefinition, config);

        // Generate helper functions
        GenerateHelperFunctions(cudaSource, config);

        var result = cudaSource.ToString();
        _logger.LogDebug("Generated {Length} bytes of CUDA C code", result.Length);

        return result;
    }

    private static void GenerateHeaders(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("// Auto-generated CUDA C persistent ring kernel");
        sb.AppendLine("// DO NOT EDIT - Generated by CudaRingKernelCompiler");
        sb.AppendLine();
        sb.AppendLine("#include <cuda_runtime.h>");
        sb.AppendLine("#include <cooperative_groups.h>");
        sb.AppendLine("#include <cuda/atomic>");
        sb.AppendLine();
        sb.AppendLine("// Configuration constants");
        sb.AppendLine($"#define MAX_MESSAGE_SIZE {config.MaxInputMessageSize}");
        sb.AppendLine();
        sb.AppendLine("// VectorAdd message serialization");
        sb.AppendLine("#include \"VectorAddSerialization.cu\"");
        sb.AppendLine();
        sb.AppendLine("namespace cg = cooperative_groups;");
        sb.AppendLine();
    }

    private static void GenerateMessageQueueStructure(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("// Lock-free ring buffer message queue");
        sb.AppendLine("template<typename T>");
        sb.AppendLine("struct MessageQueue {");
        sb.AppendLine("    T* buffer;              // Message buffer");
        sb.AppendLine("    int capacity;           // Queue capacity (power of 2)");
        sb.AppendLine("    cuda::atomic<int>* head; // Dequeue position");
        sb.AppendLine("    cuda::atomic<int>* tail; // Enqueue position");
        sb.AppendLine();
        sb.AppendLine("    __device__ bool try_enqueue(const T& message) {");
        sb.AppendLine("        int current_tail = tail->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        int next_tail = (current_tail + 1) & (capacity - 1);");
        sb.AppendLine("        int current_head = head->load(cuda::memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        if (next_tail == current_head) {");
        sb.AppendLine("            return false; // Queue full");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim slot");
        sb.AppendLine("        if (tail->compare_exchange_strong(current_tail, next_tail,");
        sb.AppendLine("                                           cuda::memory_order_release,");
        sb.AppendLine("                                           cuda::memory_order_relaxed)) {");
        sb.AppendLine("            buffer[current_tail] = message;");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine("        return false; // Lost race");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    __device__ bool try_dequeue(T& message) {");
        sb.AppendLine("        int current_head = head->load(cuda::memory_order_relaxed);");
        sb.AppendLine("        int current_tail = tail->load(cuda::memory_order_acquire);");
        sb.AppendLine();
        sb.AppendLine("        if (current_head == current_tail) {");
        sb.AppendLine("            return false; // Queue empty");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        int next_head = (current_head + 1) & (capacity - 1);");
        sb.AppendLine();
        sb.AppendLine("        // Try to claim slot");
        sb.AppendLine("        if (head->compare_exchange_strong(current_head, next_head,");
        sb.AppendLine("                                           cuda::memory_order_release,");
        sb.AppendLine("                                           cuda::memory_order_relaxed)) {");
        sb.AppendLine("            message = buffer[current_head];");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine("        return false; // Lost race");
        sb.AppendLine("    }");
        sb.AppendLine("};");
        sb.AppendLine();
    }

    private static void GenerateControlStructure(StringBuilder sb)
    {
        sb.AppendLine("// Kernel control structure");
        sb.AppendLine("struct KernelControl {");
        sb.AppendLine("    cuda::atomic<int> active;      // 1 = active, 0 = inactive");
        sb.AppendLine("    cuda::atomic<int> terminate;   // 1 = terminate requested");
        sb.AppendLine("    cuda::atomic<long> msg_count;  // Messages processed");
        sb.AppendLine("};");
        sb.AppendLine();
    }

    private void GeneratePersistentKernel(
        StringBuilder sb,
        KernelDefinition kernelDef,
        RingKernelConfig config)
    {
        string kernelName = SanitizeKernelName(config.KernelId);

        sb.AppendLine($"// Persistent ring kernel: {kernelName}");

        // Build kernel declaration - ensure __global__ void are together for tests
        if (config.Mode == RingKernelMode.Persistent)
        {
            sb.AppendLine($"extern \"C\" __global__ void __launch_bounds__(256, 2) {kernelName}_kernel(");
        }
        else
        {
            sb.AppendLine($"extern \"C\" __global__ void {kernelName}_kernel(");
        }
        sb.AppendLine("    MessageQueue<char>* input_queue,  // Generic message queue (placeholder)");
        sb.AppendLine("    MessageQueue<char>* output_queue,");
        sb.AppendLine("    KernelControl* control,");
        sb.AppendLine("    void* user_data,");
        sb.AppendLine("    int data_size)");
        sb.AppendLine("{");
        sb.AppendLine("    // Get thread and block indices");
        sb.AppendLine("    int tid = threadIdx.x;");
        sb.AppendLine("    int bid = blockIdx.x;");
        sb.AppendLine("    int global_tid = bid * blockDim.x + tid;");
        sb.AppendLine();
        sb.AppendLine("    // Cooperative groups for synchronization");
        sb.AppendLine("    cg::grid_group grid = cg::this_grid();");
        sb.AppendLine("    cg::thread_block block = cg::this_thread_block();");
        sb.AppendLine();

        if (config.Mode == RingKernelMode.Persistent)
        {
            GeneratePersistentLoop(sb, config);
        }
        else
        {
            GenerateEventDrivenLoop(sb, config);
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GeneratePersistentLoop(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("    // Persistent kernel loop");
        sb.AppendLine("    while (true) {");
        sb.AppendLine("        // Check for termination");
        sb.AppendLine("        if (control->terminate.load(cuda::memory_order_acquire) == 1) {");
        sb.AppendLine("            break;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Wait for activation");
        sb.AppendLine("        while (control->active.load(cuda::memory_order_acquire) == 0) {");
        sb.AppendLine("            if (control->terminate.load(cuda::memory_order_acquire) == 1) {");
        sb.AppendLine("                return;");
        sb.AppendLine("            }");
        sb.AppendLine("            __nanosleep(1000); // 1 microsecond");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Process VectorAdd messages");
        sb.AppendLine("        unsigned char input_buffer[MAX_MESSAGE_SIZE];");
        sb.AppendLine("        unsigned char output_buffer[MAX_MESSAGE_SIZE];");
        sb.AppendLine();
        sb.AppendLine("        if (input_queue->try_dequeue(input_buffer)) {");
        sb.AppendLine("            // Process VectorAdd: Deserialize request -> Compute -> Serialize response");
        sb.AppendLine("            bool success = process_vector_add_message(");
        sb.AppendLine("                input_buffer, MAX_MESSAGE_SIZE,");
        sb.AppendLine("                output_buffer, MAX_MESSAGE_SIZE);");
        sb.AppendLine();
        sb.AppendLine("            if (success) {");
        sb.AppendLine("                // Enqueue response to output queue");
        sb.AppendLine("                output_queue->try_enqueue(output_buffer);");
        sb.AppendLine();
        sb.AppendLine("                // Update message counter");
        sb.AppendLine("                control->msg_count.fetch_add(1, cuda::memory_order_relaxed);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        if (config.Domain == RingKernelDomain.GraphAnalytics)
        {
            sb.AppendLine("        // Graph analytics: Synchronize after message processing");
            sb.AppendLine("        grid.sync();");
        }

        sb.AppendLine("    }");
    }

    private static void GenerateEventDrivenLoop(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("    // Event-driven mode: process available messages and exit");
        sb.AppendLine("    char msg_buffer[256];");
        sb.AppendLine("    int processed = 0;");
        sb.AppendLine();
        sb.AppendLine("    while (input_queue->try_dequeue(msg_buffer)) {");
        sb.AppendLine("        // TODO: Process message based on kernel logic");
        sb.AppendLine();
        sb.AppendLine("        control->msg_count.fetch_add(1, cuda::memory_order_relaxed);");
        sb.AppendLine("        processed++;");
        sb.AppendLine();
        sb.AppendLine("        // Limit burst processing");
        sb.AppendLine($"        if (processed >= {config.QueueCapacity}) {{");
        sb.AppendLine("            break;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static void GenerateHelperFunctions(StringBuilder sb, RingKernelConfig config)
    {
        sb.AppendLine("// Helper functions");
        sb.AppendLine();
        sb.AppendLine("// Initialize message queue");
        sb.AppendLine("extern \"C\"");
        sb.AppendLine("cudaError_t init_message_queue(");
        sb.AppendLine("    MessageQueue<char>** queue,");
        sb.AppendLine("    int capacity)");
        sb.AppendLine("{");
        sb.AppendLine("    // Allocate queue structure");
        sb.AppendLine("    MessageQueue<char>* q;");
        sb.AppendLine("    cudaMalloc(&q, sizeof(MessageQueue<char>));");
        sb.AppendLine();
        sb.AppendLine("    // Allocate buffer");
        sb.AppendLine("    cudaMalloc(&q->buffer, capacity * 256); // 256 bytes per message");
        sb.AppendLine("    q->capacity = capacity;");
        sb.AppendLine();
        sb.AppendLine("    // Allocate atomic counters");
        sb.AppendLine("    cudaMalloc(&q->head, sizeof(cuda::atomic<int>));");
        sb.AppendLine("    cudaMalloc(&q->tail, sizeof(cuda::atomic<int>));");
        sb.AppendLine();
        sb.AppendLine("    // Initialize counters to zero");
        sb.AppendLine("    cudaMemset(q->head, 0, sizeof(cuda::atomic<int>));");
        sb.AppendLine("    cudaMemset(q->tail, 0, sizeof(cuda::atomic<int>));");
        sb.AppendLine();
        sb.AppendLine("    *queue = q;");
        sb.AppendLine("    return cudaGetLastError();");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static string SanitizeKernelName(string kernelId)
    {
        // Replace non-alphanumeric characters with underscores
        var sanitized = new StringBuilder(kernelId.Length);
        foreach (char c in kernelId)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(c);
            }
            else
            {
                sanitized.Append('_');
            }
        }
        return sanitized.ToString();
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _logger.LogDebug("Disposing CudaRingKernelCompiler");
        _disposed = true;
    }
}
